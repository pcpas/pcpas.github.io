<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>3DGS学习笔记</title>
    <link href="/2024/04/21/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/21/3DGS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>3DGS Learning Notes</h1><h2 id="1-概述">1 概述</h2><p>3D 高斯泼溅技术（3D Gaussian Splatting，简称3DGS）由 <a href="https://huggingface.co/papers/2308.04079">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a> 一文首次提出。作为一种光栅化技术，3D 高斯泼溅可用于实时且逼真地渲染从一小组图像中学到的场景。</p><p>具体来说，给定一组图像，我们利用SFM方法将其转化为一组稀疏点云，以此为基元3D高斯的均值初始值，通过迭代优化，得到完整的场景模型。</p><h2 id="2-3D高斯">2 3D高斯</h2><p>3D高斯可以看作一个椭球体，位置由其均值决定，大小由其协方差决定；高斯的颜色使用球谐函数表示，因为从不同的方向看上去高斯可能呈现不同的颜色；最后每个3D高斯还拥有自己的不透明度。</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><msup><mi mathvariant="normal">∣</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><msup><mo stretchy="false">)</mo><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msup><mi mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(x)=\frac{1}{ | \Sigma|^{1 / 2} (2 \pi)^{3 / 2}} \exp \left(-\frac{1}{2}(\mathbf{x}-\mu)^{T} \Sigma^{-1}(\mathbf{x}-\mu)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.954em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.296em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣Σ</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3/2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>三维高斯的协方差矩阵是一个半正定的实对称矩阵，因此它一定可以被正交对角化：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>Q</mi><mi mathvariant="normal">Λ</mi><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=Q \Lambda Q^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0858em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord">Λ</span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">\Lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Λ</span></span></span></span>是特征值矩阵，又因为其半正定性，因此可以进行分解：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>Q</mi><msup><mi mathvariant="normal">Λ</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup><msup><mi mathvariant="normal">Λ</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup><msup><mi>Q</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=Q \Lambda^{\frac{1}{2}} \Lambda^{\frac{1}{2}}Q^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1985em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Λ</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mrow><annotation encoding="application/x-tex">\Lambda^{\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.954em;"></span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>是对角矩阵，其转置等于自身，因此可以写为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">(</mo><mi>Q</mi><msup><mi mathvariant="normal">Λ</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi mathvariant="normal">Λ</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></msup><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msup><mi>Q</mi><mi>T</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma=(Q\Lambda^{\frac{1}{2}})((\Lambda^{\frac{1}{2}})^TQ^T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.254em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">((</span><span class="mord"><span class="mord">Λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>这里的$\Lambda^{\frac{1}{2}} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">和</span></span></span></span>Q$有自己的物理意义，可以理解为高斯椭球的Scaling和Rotating，因此有：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>R</mi><mi>S</mi><msup><mi>S</mi><mi>T</mi></msup><msup><mi>R</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\Sigma=RSS^TR^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">RS</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="3-初始化">3 初始化</h2><p>首先，我们需要获取一组欲建模场景的图像，并使用运动恢复结构 (Structure from Motion，SfM) 方法从一组图像中估计出3D点云。我们可以直接调用 <a href="https://colmap.github.io/">COLMAP</a> 库来完成这一步。</p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240429162200528.png" alt="image-20240429162200528"></p><p>接下来，把每个点建模成一个 3D 高斯图像。从 SfM 数据中，我们能推断出每个高斯图像的位置和颜色。这对于一般的光栅化已经够用了，但如果要产生更高质量的表征的话，我们还需要对每个高斯图像进行训练，以推断出更精细的位置和颜色，并推断出协方差（即大小）和透明度。</p><h2 id="4-训练">4 训练</h2><p>与神经网络类似，3DGS使用随机梯度下降法进行训练，但这里没有神经网络的层的概念 (都是 3D 高斯函数)。</p><p>训练步骤如下:</p><ol><li>用当前所有可微高斯图像渲染出图像 (稍后详细介绍)</li><li>根据渲染图像和真实图像之间的差异计算损失</li><li>根据损失调整每个高斯图像的参数</li><li>根据情况对当前相关高斯图像进行自动致密化及修剪（densify_and_prune）</li></ol><p>步骤 1-3 比较简单，下面稍微解释一下第 4 步的工作:</p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240421222005501.png" alt="image-20240421222005501" style="zoom:50%;" /><ul><li>如果某高斯图像的梯度很大 (即它错得比较离谱)，则对其进行分割或克隆<ul><li>如果该高斯图像很小，则克隆它</li><li>如果该高斯图像很大，则将其分割</li></ul></li><li>如果该高斯图像的 alpha 太低，则将其删除</li></ul><p>这么做能帮助高斯图像更好地拟合精细的细节，同时修剪掉不必要的高斯图像。</p><h2 id="5-可微的高斯光栅化">5 可微的高斯光栅化</h2><p>渲染器可微代表着我们可以用随机梯度下降法来训练它，因此这样的渲染方法非常重要。</p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240421221359455.png" alt="image-20240421221359455"></p><p>上面是3D GS 光栅化的示意图。</p><p>(a) Splatting步骤将 3D 高斯函数投影到2D图像空间中。</p><p>(b) 3D GS 将图像分成多个不重叠的块，即tile。</p><p>© 3D GS 复制覆盖多个瓷砖的高斯函数，为每个副本分配一个标识符，即tile ID。</p><p>(d) 通过渲染排序后的高斯函数，我们可以获得tile内的所有像素。</p><p>那么3D高斯函数该如何进行投影，每个像素点最终的颜色又是如何计算出来的呢？</p><p>首先我们看一个NeRf-style的体渲染方程：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>c</mi><mi>i</mi></msub><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>δ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><msub><mi>T</mi><mi>i</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>c</mi><mi>i</mi></msub><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>δ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>σ</mi><mi>j</mi></msub><msub><mi>δ</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">(</mo><munder><munder><mrow><mn>1</mn><mo>−</mo><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><msub><mi>σ</mi><mi>i</mi></msub><msub><mi>δ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo stretchy="true">⏟</mo></munder><msub><mi>α</mi><mi>i</mi></msub></munder><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><munder><munder><mrow><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><msub><mi>σ</mi><mi>j</mi></msub><msub><mi>δ</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow></mrow><mo stretchy="true">⏟</mo></munder><mrow><mn>1</mn><mo>−</mo><msub><mi>α</mi><mi>j</mi></msub></mrow></munder></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>c</mi><mi>i</mi></msub><msub><mi>α</mi><mi>i</mi></msub><munder><munder><mrow><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><msub><mi>α</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow></mrow><mo stretchy="true">⏟</mo></munder><mtext>transmittance </mtext></munder></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}C(p) &amp; =\sum_{i=1}^{N} c_{i}\left(1-\exp \left(-\sigma_{i} \delta_{i}\right)\right) T_{i} \\&amp; =\sum_{i=1}^{N} c_{i}\left(1-\exp \left(-\sigma_{i} \delta_{i}\right)\right) \exp \left(-\sum_{j=1}^{i-1} \sigma_{j} \delta_{j}\right) \\&amp; =\sum_{i=1}^{N} c_{i}( \underbrace{1-\exp \left(-\sigma_{i} \delta_{i}\right))}_{\alpha_{i}} \prod_{j=1}^{i-1} \underbrace{\exp \left(-\sigma_{j} \delta_{j}\right)}_{1-\alpha_{j}} \\&amp; =\sum_{i=1}^{N} c_{i} \alpha_{i} \underbrace{\prod_{j=1}^{i-1}\left(1-\alpha_{j}\right)}_{\text {transmittance }}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:15.7166em;vertical-align:-7.6083em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:8.1083em;"><span style="top:-10.1083em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span><span style="top:-6.7023em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"></span></span><span style="top:-3.1602em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"></span></span><span style="top:0.7507em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:7.6083em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:8.1083em;"><span style="top:-10.1083em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-6.7023em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span><span style="top:-3.1602em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-1.6006em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0037em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span class="svg-align" style="top:-2.102em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.898em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4995em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-1.4148em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0037em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span class="svg-align" style="top:-2.0659em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0379em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9341em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7825em;"><span></span></span></span></span></span></span></span><span style="top:0.7507em;"><span class="pstrut" style="height:3.8283em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.0824em;"><span class="pstrut" style="height:3.8117em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">transmittance </span></span></span></span></span><span style="top:-3.8117em;"><span class="pstrut" style="height:3.8117em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span class="svg-align" style="top:-1.7499em;"><span class="pstrut" style="height:3.8117em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-3.8117em;"><span class="pstrut" style="height:3.8117em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0618em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7293em;"><span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:7.6083em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>是体密度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>是采样间距，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>是不透明度。</p><p>3D高斯公式为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><msup><mi mathvariant="normal">∣</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><msup><mo stretchy="false">)</mo><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mfrac><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><msup><mi mathvariant="normal">Σ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi>μ</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">p(x)=\frac{1}{ | \Sigma|^{1 / 2} (2 \pi)^{3 / 2}} \exp \left(-\frac{1}{2}(\mathbf{x}-\mu)^{T} \Sigma^{-1}(\mathbf{x}-\mu)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.404em;vertical-align:-0.954em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.296em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣Σ</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1/2</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3/2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>这里我们将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>理解为这个高斯对空间中某点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>的影响。我们忽略其归一化项，通过不透明度进行加权，得到公式：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mi>exp</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo fence="true">(</mo><mi>p</mi><mo>−</mo><msub><mi>μ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><msubsup><mi mathvariant="normal">Σ</mi><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo fence="true">(</mo><mi>p</mi><mo>−</mo><msub><mi>μ</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f_{i}(p)=\sigma\left(\alpha_{i}\right) \exp \left(-\frac{1}{2}\left(p-\mu_{i}\right) \Sigma_{i}^{-1}\left(p-\mu_{i}\right)\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.433em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.267em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>其中不透明度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>α</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma(\alpha_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，应用 sigmoid 函数将参数映射到 [0, 1] 区间。</p><p>因此上述的体渲染方程就可以被改写为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>N</mi></mrow></munder><msub><mi>c</mi><mi>i</mi></msub><msubsup><mi>f</mi><mi>i</mi><mrow><mn>2</mn><mi>D</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><munder><munder><mrow><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><msubsup><mi>f</mi><mi>j</mi><mrow><mn>2</mn><mi>D</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><mo stretchy="true">⏟</mo></munder><mtext>transmittance </mtext></munder></mrow><annotation encoding="application/x-tex">C(p)=\sum_{i \in N} c_{i} f_{i}^{2 D}(p) \underbrace{\prod_{j=1}^{i-1}\left(1-f_{j}^{2 D}(p)\right)}_{\text {transmittance }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.5409em;vertical-align:-2.7293em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.0824em;"><span class="pstrut" style="height:3.8117em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">transmittance </span></span></span></span></span><span style="top:-3.8117em;"><span class="pstrut" style="height:3.8117em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span class="svg-align" style="top:-1.7499em;"><span class="pstrut" style="height:3.8117em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"/></svg></span></span></span><span style="top:-3.8117em;"><span class="pstrut" style="height:3.8117em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8117em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.453em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0618em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7293em;"><span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mrow><mn>2</mn><mi>D</mi></mrow></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_i^{2D}(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>表示第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>个3D高斯函数的2D投影在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>点的不透明度。</p><p>如何进行投影呢？</p><p>首先，我们需要通过相机的外参矩阵View Matrix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> 将坐标从世界坐标系转换到相机坐标系：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy="false">[</mo><mi>R</mi><mo>∣</mo><mi mathvariant="bold-italic">t</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="left left left left" columnlines="none none solid" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>2</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>r</mi><mrow><mn>3</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mn>3</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">W=[R \mid \boldsymbol{t}]=\left[\begin{array}{lll|l}r_{1,1} &amp; r_{1,2} &amp; r_{1,3} &amp; t_{1} \\r_{2,1} &amp; r_{2,2} &amp; r_{2,3} &amp; t_{2} \\r_{3,1} &amp; r_{3,2} &amp; r_{3,3} &amp; t_{3}\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">t</span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="vertical-separator" style="height:3.6em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-1.55em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>接着，我们需要根据相机的内参矩阵计算出其投影矩阵。投影矩阵的作用是将坐标从相机坐标系转换为光线坐标系，也可以理解为图片坐标系。</p><p>相机内参矩阵的一般形式可以写为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>f</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>s</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>f</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>y</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">K=\left(\begin{array}{ccc}f_{x} &amp; s &amp; x_{0} \\0 &amp; f_{y} &amp; y_{0} \\0 &amp; 0 &amp; 1\end{array}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.875em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="3.600em" viewBox="0 0 875 3600"><path d="M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,-36,557 l0,84c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189l0,-92c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.875em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="3.600em" viewBox="0 0 875 3600"><path d="M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,9c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558l0,-144c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>这样的形式是根据相机本身的性质，如焦距和主点位置决定的。如果我们给出投影前视椎体的对应坐标，一般性地，我们也可以将透视矩阵写作：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>r</mi><mo>+</mo><mi>l</mi></mrow><mrow><mi>r</mi><mo>−</mo><mi>l</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>t</mi><mo>−</mo><mi>b</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi>t</mi><mo>+</mo><mi>b</mi></mrow><mrow><mi>t</mi><mo>−</mo><mi>b</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>−</mo><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>−</mo><mi>n</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mo>−</mo><mn>2</mn><mi>f</mi><mi>n</mi></mrow><mrow><mi>f</mi><mo>−</mo><mi>n</mi></mrow></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">K=\left(\begin{array}{cccc}\frac{2 n}{r-l} &amp; 0 &amp; \frac{r+l}{r-l} &amp; 0 \\0 &amp; \frac{2 n}{t-b} &amp; \frac{t+b}{t-b} &amp; 0 \\0 &amp; 0 &amp; \frac{-(f+n)}{f-n} &amp; \frac{-2 f n}{f-n} \\0 &amp; 0 &amp; -1 &amp; 0\end{array}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.258em;vertical-align:-2.379em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.875em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,-36,557 l0,1284c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189l0,-1292c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.879em;"><span style="top:-5.0089em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.7254em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3121em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-0.991em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.379em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.879em;"><span style="top:-5.0089em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.7254em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3121em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-0.991em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.379em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.879em;"><span style="top:-5.0089em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.7254em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.3121em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.991em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.379em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.879em;"><span style="top:-5.0089em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.7254em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.3121em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.991em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.379em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.875em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="4.800em" viewBox="0 0 875 4800"><path d="M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1209c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558l0,-1344c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>值得注意的是，这里给出的透视矩阵是遵循<a href="https://www.songho.ca/opengl/gl_projectionmatrix.html">OpenGL规范</a>的，矩阵的形式根据坐标系和正则立方体的不同，形式上会产生差别。</p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240429172822712.png" alt="投影矩阵如何发挥作用" style="zoom:50%;" /><p>这里我们根据已知数据，使用的投影矩阵为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><msub><mi>f</mi><mi>x</mi></msub><mi mathvariant="normal">/</mi><mi>w</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><msub><mi>f</mi><mi>y</mi></msub><mi mathvariant="normal">/</mi><mi>h</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>f</mi><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>2</mn><mi>f</mi><mi>n</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>f</mi><mo>−</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">K=\left[\begin{array}{cccc}2 f_{x} / w &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 2 f_{y} / h &amp; 0 &amp; 0 \\0 &amp; 0 &amp; (f+n) /(f-n) &amp; -2 f n /(f-n) \\0 &amp; 0 &amp; 1 &amp; 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal">h</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>f</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f_x,f_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是相机的焦距，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>是输出图片的尺寸，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>是近远裁剪平面。</p><p>此时，求投影世界坐标系中的3D高斯的均值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">μ</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\mu}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span></span></span>在NDC坐标系的坐标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">t</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">t</span></span></span></span></span></span>公式为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold-italic">t</mi><mo>=</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>t</mi><mi>w</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mi>K</mi><mi>W</mi><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>μ</mi><mi>x</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>μ</mi><mi>y</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>μ</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\boldsymbol{t}=\begin{array}{c}\left[\begin{array}{c}t_x \\t_y \\t_z \\t_w\end{array}\right]=K W\left[\begin{array}{c}\mu_{x} \\\mu_{y} \\\mu_{z} \\1\end{array}\right] \\\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">t</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:4.65em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M403 1759 V84 H666 V0 H319 V1759 v1200 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:6.8em;"></span><span style="width:0.667em;height:4.800em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="4.800em" viewBox="0 0 667 4800"><path d="M347 1759 V0 H0 V84 H263 V1759 v1200 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v1200 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p>但是，值得注意的是，这样的投影变换是非线性的。3D高斯进行这样的变化后，投影得到的形状将不再满足高斯分布，而这点是我们不希望看到的。</p><p>注意到非线性变换是局部线性的，而这种局部的线性变换可以使用其雅可比矩阵表示：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>J</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>f</mi><mi>x</mi></msub><mi mathvariant="normal">/</mi><msub><mi>t</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>f</mi><mi>x</mi></msub><msub><mi>t</mi><mi>x</mi></msub><mi mathvariant="normal">/</mi><msubsup><mi>t</mi><mi>z</mi><mn>2</mn></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>f</mi><mi>y</mi></msub><mi mathvariant="normal">/</mi><msub><mi>t</mi><mi>z</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>f</mi><mi>y</mi></msub><msub><mi>t</mi><mi>y</mi></msub><mi mathvariant="normal">/</mi><msubsup><mi>t</mi><mi>z</mi><mn>2</mn></msubsup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">J=\left[\begin{array}{ccc}f_{x} / t_{z} &amp; 0 &amp; -f_{x} t_{x} / t_{z}^{2} \\0 &amp; f_{y} / t_{z} &amp; -f_{y} t_{y} / t_{z}^{2} \\0 &amp; 0 &amp; 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.667em" height="3.600em" viewBox="0 0 667 3600"><path d="M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v0 v1759 h84z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>因此，我们粗略地认为某一3D高斯的投影变换可以使用其均值点的雅可比矩阵等效，故投影后仍能保持2D高斯的性质，协方差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>J</mi><mi>W</mi><mi mathvariant="normal">Σ</mi><msup><mi>W</mi><mi>T</mi></msup><msup><mi>J</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">{\Sigma}^{\prime}=JW\Sigma W^T J^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord"><span class="mord">Σ</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>终于，我们得到了投影后的2D高斯，其均值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold-italic">t</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6349em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">t</span></span></span></span></span></span>，协方差为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^{\prime}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>​，其第三维代表其深度，在排序时会用到，其他时候可以不用考虑。</p><p>最后把数据代入渲染方程(9)就可以顺利算出每个像素的颜色了！</p><h2 id="6-损失函数">6 损失函数</h2><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">L</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false">)</mo><msub><mi mathvariant="script">L</mi><mn>1</mn></msub><mo>+</mo><mi>λ</mi><msub><mi mathvariant="script">L</mi><mtext>D-SSIM </mtext></msub></mrow><annotation encoding="application/x-tex">\mathcal{L}=(1-\lambda) \mathcal{L}_{1}+\lambda \mathcal{L}_{\text {D-SSIM }}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">D-SSIM </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>方法的损失函数比较简单，为L1_loss和D-SSIM loss的加权和，权重为超参数。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>3DGS</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码优化</title>
    <link href="/2023/11/26/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <url>/2023/11/26/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1>代码优化</h1><h2 id="前言">前言</h2><p>写代码优化真的很难。尤其是如果在前期自作聪明地用一些“简便方法”完成了代码生成，而没有保存足够的信息，或者生成的结构有问题的话，可能会非常非常痛苦。一定要保持头脑足够清醒。</p><p>此外，另一个重要的事情是保证优化之间相互兼容。有些优化可能会破坏原有的结构和信息，导致接下来的优化无法叠加上去，这一点一定要考虑清楚。</p><p>下面简单介绍一下我做的优化。</p><h2 id="中端优化">中端优化</h2><h3 id="函数内联">函数内联</h3><p>将简单的叶函数直接内联到调用者的代码块中，减少栈保存的开销。</p><h3 id="尾递归优化">尾递归优化</h3><p>尾递归是指递归函数中的递归调用发生在函数的最后一步。编译器可以将尾递归优化为迭代形式，从而避免递归调用造成的额外开销。针对迭代，也就是循环形式，则使用循环外提。</p><h3 id="循环外提">循环外提</h3><p>对于循环中无需进行循环的代码进行外提，从而减少代码的重复执行次数。</p><h3 id="常量传播">常量传播</h3><p>这个优化说实话比较简单，并且非常容易直接集成在代码生成时完成。基本思路为在代码生成时如果遇到可以计算的常量就直接算出来，而不是申请寄存器来存放常量计算的结果。此处不赘述。</p><p>值得注意的是常数数组的优化。不仅直接取其中元素时可以直接优化为常量，如果将常数数组作为参数传递给函数，函数中取其中的值也可以优化为常量。</p><h3 id="死代码删除">死代码删除</h3><p>死代码删除分为三步：</p><ol><li>删除掉不可达基本块、函数。</li><li>构建定义使用链。</li><li>根据定义使用链删除掉无用的死代码。</li></ol><p>删除死代码需要遍历有用函数中的每条指令，并沿着def-use链构建有用指令的<strong>闭包</strong>。最基本的一些有用指令包括alloc指令、br指令，ret指令，调用函数的call指令。</p><p>寻找闭包的过程其实是一个递归：先将基本的有用指令进行标记，随后标记每条有用指令用到的value，并接着递归寻找其用到的value，从而构建一个有用指令的闭包。</p><p>然后将不在闭包内的所有指令全部删除即可。记得维护整体的数据结构的信息，因为之后还有别的优化要做。</p><h3 id="消除公共表达式">消除公共表达式</h3><p>我只做了基本块内的消除公共表达式。</p><p>消除公共表达式可以分为两步：</p><ol><li>构建基本块的DAG图</li><li>根据DAG图导出指令</li></ol><h3 id="窥孔优化">窥孔优化</h3><p>我只做了比较简单的窥孔优化。</p><p>中端：</p><ol><li>删除条件恒为假的<code>br</code>指令。</li><li>将条件恒为真的<code>br</code>指令去掉条件，这样在翻译为mips时就不会翻译成<code>bnz。</code></li></ol><h2 id="后端优化">后端优化</h2><h3 id="寄存器分配">寄存器分配</h3><p>设定<code>s0-5</code>（或者任何你喜欢的寄存器）为全局寄存器，其他可用寄存器为临时寄存器。</p><p>使用此前计算出的基本块的in和out集合构建冲突图，使用图着色算法为变量分配全局寄存器。</p><p>这里笔者只做到了基本块程度的冲突图，因此分配的精细度有欠缺，体现在竞速点里非常明显。因此建议还是做一下精确到每条指令的图着色，会对竞速的分数大有益处！</p><h3 id="窥孔优化-2">窥孔优化</h3><ol><li>删除没用的J指令。</li><li>优化for循环的基本块顺序以减少J指令。</li><li>删除形如<code>addui $t1 $t1 0</code>或者<code>move $t0 $t0</code>的无用指令。</li><li>合并冗余的指令。</li></ol><h3 id="乘除模优化">乘除模优化</h3><ul><li>乘法优化为对操作数为常数的指令进行优化，方法是乘法转换为左移和加法操作</li><li>除法优化为将指令转化为乘法指令再进行乘法指令优化</li><li>取模运算转化为乘除指令再优化：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mtext> </mtext></mrow><annotation encoding="application/x-tex">a \ % \ b = a -a/b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace"> </span></span></span></span></li></ul><h4 id="其他的小优化">其他的小优化</h4><p>还做了一些小优化，比如说MIPS叶子函数不需要保存ra；调用函数时只保存尽可能少的寄存器等，此处不一一列举。</p><h2 id="总结">总结</h2><p>一开始在MIPS生成时写了一个简单的寄存器分配，没有引入全局寄存器，而是将全部的全局变量存入内存。我居然没有意识到这是不够的，反而觉得已经达到了最优，因此一直没有做最重要的图着色寄存器分配。后面意识到的时候已经来不及了，只能匆匆做一个简单版，效果很差。因此我认为优化一定要先做一些显然普适、有效的大优化，再慢慢由浅入深；此外先想好再动手也是很重要的一点。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>MIPS</tag>
      
      <tag>代码优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标代码生成</title>
    <link href="/2023/11/19/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <url>/2023/11/19/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1>目标代码生成之MIPS</h1><h2 id="总体结构">总体结构</h2><p>所有MIPS代码生成的部分都属于包<code>backend</code>，结构如下：</p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231212142956012.png" alt="image-20231212142956012" style="zoom:50%;" /><p>接下来我们具体介绍一下：</p><ol><li><code>MIPSInst</code>包：这个包用于存放MPIS的指令，分为Syscall指令，I型指令，J型指令，和R型指令，这四个类又继承于基类<code>MInstruction</code>。</li><li><code>MIPSTable</code>包：这个包用于存放MIPS生成过程中的符号表和符号类。</li><li><code>MIPSValues</code>包：这个包用于存放MIPS生成中的Value类。所有Value都要实现接口<code>MValue</code>，包括MemAddr、Label、MInstruction、MFucntion、MBasicBlock、Register等。此外，还有接口<code>Immediate</code>用于表示MIPS中的立即数，<code>FrameStack</code>中的占位符<code>Placeholder</code>类和<code>ImmediateNumber</code>类实现了这个接口。</li><li><code>BackController</code>类：这个类用于生成和管理<code>MIPSBuilder</code>、<code>RegisterManager</code>等单例类，并控制文件的读写。</li><li><code>MIPSBuilder</code>类：这个类是生成MIPS代码的主类，通过分析此前生成的LLVM代码来生成对应的MIPS代码。</li><li><code>RegisterManager</code>类：这个类用于管理和分配寄存器。</li></ol><h2 id="指令的翻译">指令的翻译</h2><p>在开始翻译之前，我们首先需要理清思路。以一段简单的C语言代码为例：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a=<span class="hljs-number">2</span>,b[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,c;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>;    y = x+y;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>生成LLVM中间代码为：</p><div class="code-wrapper"><pre><code class="hljs assembly">@a = dso_local global i32 2@b = dso_local global [3 x i32] [i32 1, i32 2, i32 3]@c = dso_local global i32 0define dso_local i32 @main ()&#123;%1 = alloca i32store i32 1, i32* %1%2 = alloca i32store i32 2, i32* %2%3 = load i32, i32* %1%4 = load i32, i32* %2%5 = add i32 %3, %4store i32 %5, i32* %2ret i32 0&#125;</code></pre></div><blockquote><p>⚠️注意：我们的任务是将生成的LLVM中间代码翻译为MIPS汇编代码，因此不应该在生成时继续依赖原始的C代码。</p></blockquote><p>可以看出，在目标代码生成的过程中，我们需要存放在符号表里的是全局变量和使用<code>alloc</code>指令申请的变量（即C语言中的局部变量）</p><p>因为在此阶段我们不考虑优化，因此全部的局部变量我们都存放在内存中。</p><p>故符号表为：</p><table><thead><tr><th>name</th><th>symbolType</th></tr></thead><tbody><tr><td>a</td><td>GLOBAL</td></tr><tr><td>b</td><td>GLOBAL</td></tr><tr><td>c</td><td>GLOBAL</td></tr><tr><td>%1</td><td>MEM</td></tr><tr><td>%2</td><td>MEM</td></tr></tbody></table><p>由于我们在编写LLVM时每次访问某个变量都会重新申请寄存器存放其值，LLVM中每个寄存器（除了存放变量地址的寄存器外）都只会被访问一次。通过这个性质，我们容易知道，当代码中同时未被访问的临时寄存器不超过10个（MIPS中只有10个$t寄存器）时，临时变量都不需要写入内存。</p><p>在目标代码生成阶段，<strong>我们暂时有理由相信同时需要准备的临时寄存器不超过10个</strong>。因为这样的样例非常强。把寄存器的分配统一留到后面代码优化时可能是个更节省时间的选择。</p><p>基于如上假设，指令的翻译将会变的非常简单。</p><h3 id="alloc">alloc</h3><div class="code-wrapper"><pre><code class="hljs assembly">%1 = alloca i32</code></pre></div><p>显然，这对应着一个需要存入内存和符号表的变量，但是没有被使用。因此，我们只需要在符号表记录下其位置，而不需要翻译为任何命令。</p><p>值得注意的是，对于普通变量和数组指针，我们只需要申请一个word的空间就够了，但是对于局部数组，我们要根据数组内元素的数量申请n个wrod。</p><h3 id="store">store</h3><p>赋值有四种情况：</p><ol><li>给局部普通变量赋值</li><li>给局部数组变量赋值</li><li>给全局普通变量赋值</li><li>给全局数组变量赋值</li><li>给参数普通和数组变量赋值</li></ol><p>我们来依次分析这四种情况：</p><p><strong>情况一： 给局部普通变量赋值</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;</code></pre></div><p>LLVM</p><div class="code-wrapper"><pre><code class="hljs assembly">%7 = alloca i32store i32 1, i32* %7</code></pre></div><p>这种情况下，%7所对应的一定是MIPS栈空间的一段内存地址，且符号表中已经记录，直接查表即可。</p><p>此外，如果store的值是常量(除了0)的话，要先把常量load进临时寄存器，然后再sw。</p><p>MIPS</p><div class="code-wrapper"><pre><code class="hljs assembly">li $t0 1sw $t0 offset($fp)</code></pre></div><p><strong>情况二： 给局部数组变量赋值</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">1</span>]=&#123;<span class="hljs-number">1</span>&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">%8 = alloca [1 x i32]%9 = getelementptr [1 x i32], [1 x i32]* %8, i32 0, i32 0store i32 1, i32* %9</code></pre></div><p>这种情况下，此前我们一定已经翻译了<code>%9 = getelementptr [1 x i32], [1 x i32]* %8, i32 0, i32 0</code>这条指令。这条取址指令也不用翻译为任何MIPS指令，只需要将标识符<code>%9</code>和其对应的地址记录在符号表中。因此查表就可以得到%9对应的偏移</p><div class="code-wrapper"><pre><code class="hljs assembly">li $t0 1sw $t0 offset($fp)</code></pre></div><p><strong>情况三： 给全局普通变量赋值</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//a是全局变量</span>a = <span class="hljs-number">3</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">store i32 3, i32* @a</code></pre></div><p>这种情况下，我们的做法甚至更简单。</p><div class="code-wrapper"><pre><code class="hljs assembly">li $t0 3sw $t0 a</code></pre></div><p><strong>情况四： 给全局数组变量赋值</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//b是全局数组</span>b[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs assembly">%8 = getelementptr [3 x i32], [3 x i32]* @b, i32 0, i32 2store i32 10, i32* %8</code></pre></div><p>这种情况下，此前我们一定已经翻译了<code>%8 = getelementptr [3 x i32], [3 x i32]* @b, i32 0, i32 2</code>这条指令。这条取址指令也不用翻译为任何MIPS指令，只需要将标识符<code>%8</code>和其对应的地址记录在符号表中。因此查表就可以得到%8对应的地址。</p><div class="code-wrapper"><pre><code class="hljs assembly">li $t0 10sw $t0 offset(b)</code></pre></div><p><strong>情况五：给参数普通和数组变量赋值</strong></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b[])</span>&#123;  a = <span class="hljs-number">5</span>;b[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;&#125;</code></pre></div><p>这一点会比较神奇。我们知道llvm对于传参的处理是要先保存在本地的寄存器中，然后再进行取用，这其实与MIPS的机制不太符合。</p><p>因为MIPS每个函数的栈帧会专门留出传参区域供后续函数使用，因此重复的保存似乎显得非常多余。</p><div class="code-wrapper"><pre><code class="hljs assembly">define dso_local void @fun (i32 %0, i32* %1)&#123;//保存参数%3 = alloca i32store i32 %0, i32* %3%4 = alloca i32*store i32* %1, i32** %4//函数开始store i32 5, i32* %3%5 = load i32*, i32** %4%6 = getelementptr i32, i32* %5, i32 0store i32 10, i32* %6ret void&#125;</code></pre></div><p>因此，我们在保存参数的阶段可以不要直接翻译，而是把<code>%3</code>，<code>%4</code>及其对应的内存地址直接存入符号表。</p><p>这样，对于<code>  a = 5;</code>的处理就与前文完全一致，为</p><div class="code-wrapper"><pre><code class="hljs assembly">li $t0 10sw $t0 %3</code></pre></div><p>而对于<code>b[0] = 10;</code>我们反推回去：<code>%6</code>一定存放了其对应的地址记录，<code>%5</code>存放了<code>%4</code>对应的地址，故也与前文无异。</p><p><strong>所以总结下来，store的翻译不会因为情况不同而产生不同的处理方式，直接查表即可。</strong></p><p>最后补充一下rt不是立即数的情况，如：</p><div class="code-wrapper"><pre><code class="hljs assembly">store i32 %7, i32* %8</code></pre></div><p>这种情况下，<code>%7</code>也成了需要查表访问的对象。根据LLVM的性质，我们知道在此之前一定会有一个<code>load</code>语句帮我们将<code>%7</code>放在临时寄存器中并记录在符号表里，因此我们直接查表使用即可。</p><h3 id="load">load</h3><p>只会有这三种情况</p><div class="code-wrapper"><pre><code class="hljs assembly">load i32, i32* %4 load i32*, i32** %5load [3 x i32]*, [3 x i32]** %6</code></pre></div><p>调用load时，我们有理由相信<code>%4 %5 %6</code>三个标识符已经在表里了。</p><p>所以直接查表翻译即可。</p><h3 id="getelementptr">getelementptr</h3><p>在LLVM中，只有在使用数组的时候会用到getelementptr，因此我们考虑全局数组、局部数组和参数数组三种情况：</p><ol><li><strong>全局数组和局部数组</strong></li></ol><div class="code-wrapper"><pre><code class="hljs assembly">%16 = getelementptr [3 x i32], [3 x i32]* @b, i32 0, i32 2%17 = load i32, i32* %16%18 = getelementptr [2 x i32], [2 x i32]* %8, i32 0, i32 0%19 = load i32, i32* %18</code></pre></div><p>对于全局数组来说，基地址即为<code>@b</code>，而在mips中直接根据维度计算出偏移即可，因此可以翻译为：</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span> <span class="hljs-keyword">b </span><span class="hljs-number">3</span>*<span class="hljs-number">0</span>+<span class="hljs-number">1</span>*<span class="hljs-number">2</span><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">t0</span><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span> getReg(%<span class="hljs-number">8</span>) <span class="hljs-number">2</span>*<span class="hljs-number">0</span>+<span class="hljs-number">1</span>*<span class="hljs-number">0</span><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t2</span> $<span class="hljs-built_in">t0</span></code></pre></div><p>但是需要注意的是，<code>getelementptr</code>后面的偏移量有可能不是常数而是寄存器的值，这时候就得先取出来了。</p><ol start="2"><li><strong>参数数组</strong></li></ol><p>这部分比较复杂，先不说明。若有时间再具体介绍。</p><h2 id="总结">总结</h2><p>MIPS生成指导书给出的教程比较简略，因此需要发挥自己的主观能动性，先学习和了解MIPS的基本知识，如寄存器用法、函数调用等，然后根据自己的中间代码进行生成。生成的我累死了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>MIPS</tag>
      
      <tag>代码生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间代码生成</title>
    <link href="/2023/11/15/%E7%94%9F%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/11/15/%E7%94%9F%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1>LLVM中间代码生成</h1><h2 id="总体结构">总体结构</h2><p>中间代码生成器相关的类我全部放在了包<code>IR</code>中，结构如下：</p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231212135953120.png" alt="image-20231212135953120" style="zoom:25%;" /><p>其中：</p><ol><li><code>IRTable</code>包中存放了中间代码生成过程中使用的符号表结构以及符号类。</li><li><code>Value</code>包中存放了LLVM中所有的Value类，其中<code>IRValue</code>是所有Value的基类，Fucntion、BasicBlock和Value分别代表LLVM中的函数、基本块和临时寄存器。<ol><li><code>ConstVal</code>和<code>GlobalVar</code>代表常量和全局变量，继承自Value。</li><li><code>Instruction</code>包中存放了所有的LLVM指令类。指令类存在一个基类<code>Instruction</code>,所有的指令类都继承自这个基类。</li><li><code>Use</code>和<code>User</code>是为了代码优化，后续应该还会继续优化，因此先按下不表。</li></ol></li><li><code>MideController</code>是整个过程的控制类，也负责生成和管理<code>Visitor</code>和<code>IRBuildFactory</code>的单例和文件的读写。</li><li><code>Visitor</code>和<code>IRBuildFactory</code>两个类相互协助生成LLVM，其中<code>Visitor</code>分析抽象语法树，<code>IRBuildFactory</code>根据Visitor得到的信息生成对应的LLVM代码。</li></ol><p>因为指导书的内容已经较为详细具体，因此这里仅补充一个专题。</p><h2 id="专题：变量的声明和使用">专题：变量的声明和使用</h2><p>这部分比较难，所以开一个专题专门分析一下。</p><h3 id="一、普通类型变量">一、普通类型变量</h3><p>普通类型变量即<code>Btype</code>类型变量，因其不涉及指针和数据的操作，是最简单的变量类型。</p><p>源程序：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a0 = <span class="hljs-number">0</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> a1 =<span class="hljs-number">1</span>;    a0 = <span class="hljs-number">2</span>;    a1 = <span class="hljs-number">3</span>;    func1(a0);    func1(a1);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="1-全局变量">1. 全局变量</h4><p>让我们将目光聚焦于生成的LLVM代码的全局变量部分：</p><div class="code-wrapper"><pre><code class="hljs assembly">@a0 = global i32 0, align 4define i32 @main() &#123;...  store i32 2, i32* @a0, align 4  %3 = load i32, i32* @a0, align 4  call void @func1(i32 %3)...&#125;</code></pre></div><p>可以看到，声明时，全局变量标识符<code>@a0</code>存放了其内存地址，类型为<code>Btype*</code>。</p><p>为其赋值时可直接使用<code>  store i32 2, i32* @a0, align 4</code></p><p>取其值时可直接使用<code>  %3 = load i32, i32* @a0, align 4</code>。</p><h4 id="2-局部变量">2. 局部变量</h4><div class="code-wrapper"><pre><code class="hljs assembly">define i32 @main() &#123;  %2 = alloca i32, align 4  store i32 1, i32* %2, align 4  store i32 3, i32* %2, align 4  %4 = load i32, i32* %2, align 4  call void @func1(i32 %4)&#125;</code></pre></div><p>可以看到，为了声明一个局部变量，我们需要使用到<code>  %2 = alloca i32, align 4</code></p><p>此时<code>%2</code>寄存器存放了这个局部变量在内存中的指针，故<code>%2</code>的类型为<code>Btype*</code>。</p><p>同理，当我们想要给局部变量赋值时，只要向这段地址写入对应的值即可，<code>  store i32 3, i32* %2, align 4</code>，特别地，局部变量的初始化也可以看做是为其赋值。</p><p>取其值时可直接使用<code>%4 = load i32, i32* %2, align 4</code>。</p><h3 id="二、数组类型变量">二、数组类型变量</h3><p>这部分非常复杂，话不多说，上代码。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> a0[<span class="hljs-number">1</span>];<span class="hljs-type">int</span> b0[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b[])</span>&#123;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> c[][<span class="hljs-number">1</span>])</span>&#123;    a;    b[<span class="hljs-number">0</span>];    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];    func1(b[<span class="hljs-number">0</span>], c[<span class="hljs-number">0</span>]);    func2(a, b, c);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> a1[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-type">int</span> b1[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = &#123;&#123;<span class="hljs-number">0</span>&#125;&#125;;    a0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    b0[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    b1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    func1(a0[<span class="hljs-number">0</span>], a0);    func1(a1[<span class="hljs-number">0</span>], a1);    func2(b0[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], b0[<span class="hljs-number">0</span>], b0);    func2(b1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], b1[<span class="hljs-number">0</span>], b1);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="1-全局数组">1. 全局数组</h4><div class="code-wrapper"><pre><code class="hljs assembly">@a0 = global [1 x i32] zeroinitializer, align 4@b0 = global [1 x [1 x i32]] zeroinitializer, align 4define i32 @main() &#123;...  store i32 1, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0), align 4  store i32 1, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4...  %9 = load i32, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0), align 4  call void @func1(i32 %9, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0))  ...  %13 = load i32, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4  call void @func2(i32 %13, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), [1 x i32]* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0))  ret i32 0&#125;</code></pre></div><p>首先，在声明上，<code>@a0</code>和<code>@b0</code>仍然存放着对应数组的指针，类型分别为<code>[1 x i32]*</code>和<code>[1 x [1 x i32]]*</code>。</p><p>这里我们先假设赋值语句只会对数组中的<strong>一个基本类型值</strong>进行赋值，那么，赋值的过程如下：</p><ol><li>根据数组标识符后的偏移值取得该“基本类型值”的内存中的指针</li><li>向这段地址写入值</li></ol><div class="code-wrapper"><pre><code class="hljs assembly">store i32 1, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0), align 4store i32 1, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4</code></pre></div><p>使用其值时，逻辑会更加复杂。</p><p>这里我们以<code>b0</code>为例：</p><ol><li>当我们要取<code>b[0][0]</code>时：</li></ol><div class="code-wrapper"><pre><code class="hljs assembly">%13 = load i32, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4</code></pre></div><ol start="2"><li>当我们要取<code>b[0]</code>时：</li></ol><p>按照朴素的理解，猜想应该是：</p><div class="code-wrapper"><pre><code class="hljs assembly">[1 x 32i]* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0)</code></pre></div><p>但是其实应该是：</p><div class="code-wrapper"><pre><code class="hljs assembly">i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0)</code></pre></div><p>可以看到，这两个命令对地址<code>@b0</code>的getelementptr操作完全相同，只是<code>b[0][0]</code>多了一个取值的操作。</p><p>也就是说，在取址会故意多取一层，这与我们在处理函数形参时完全对应。</p><ol start="3"><li>同样的，直接取<code>b0</code>时：</li></ol><div class="code-wrapper"><pre><code class="hljs assembly">[1 x i32]* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0)</code></pre></div><h4 id="2-局部数组">2. 局部数组</h4><div class="code-wrapper"><pre><code class="hljs assembly">define i32 @main() #0 &#123;...  %2 = alloca [1 x i32], align 4  %3 = alloca [1 x [1 x i32]], align 4  %4 = bitcast [1 x i32]* %2 to i8*  call void @llvm.memset.p0i8.i64(i8* align 4 %4, i8 0, i64 4, i1 false)  %5 = bitcast [1 x [1 x i32]]* %3 to i8*  call void @llvm.memset.p0i8.i64(i8* align 4 %5, i8 0, i64 4, i1 false)  ...  %6 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0  store i32 1, i32* %6, align 4  %7 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0  %8 = getelementptr inbounds [1 x i32], [1 x i32]* %7, i64 0, i64 0  store i32 1, i32* %8, align 4  ...  %10 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0  %11 = load i32, i32* %10, align 4  %12 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0  call void @func1(i32 %11, i32* %12)...  %14 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0  %15 = getelementptr inbounds [1 x i32], [1 x i32]* %14, i64 0, i64 0  %16 = load i32, i32* %15, align 4  %17 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 1  %18 = getelementptr inbounds [1 x i32], [1 x i32]* %17, i64 0, i64 0  %19 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0  call void @func2(i32 %16, i32* %18, [1 x i32]* %19)  ret i32 0&#125;</code></pre></div><p>首先在声明时，与普通类型变量类似，数组类型变量也会先申请空间：</p><div class="code-wrapper"><pre><code class="hljs assembly">%2 = alloca [1 x i32], align 4%3 = alloca [1 x [1 x i32]], align 4</code></pre></div><p>这段代码中的初始化部分引入了新的复杂指令和函数，故先不看。我们也可以采用赋值和<code>zeroinitialier</code>来进行初始化。</p><p>那么怎么对数组元素进行赋值呢？与全局数组类似，先取得对应元素的指针，然后直接赋值即可：</p><div class="code-wrapper"><pre><code class="hljs assembly">%6 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0store i32 1, i32* %6, align 4%7 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0%8 = getelementptr inbounds [1 x i32], [1 x i32]* %7, i64 0, i64 0store i32 1, i32* %8, align 4</code></pre></div><p>最后，<strong>使用的方法</strong>也和全局数组一致完全一致，这里就不再赘述。</p><h3 id="三、函数中的形参">三、函数中的形参</h3><div class="code-wrapper"><pre><code class="hljs assembly">define void @func2(i32 %0, i32* %1, [1 x i32]* %2) #0 &#123;  %4 = alloca i32, align 4  %5 = alloca i32*, align 8  %6 = alloca [1 x i32]*, align 8  store i32 %0, i32* %4, align 4  store i32* %1, i32** %5, align 8  store [1 x i32]* %2, [1 x i32]** %6, align 8  %7 = load i32, i32* %4, align 4  %8 = load i32*, i32** %5, align 8  %9 = getelementptr inbounds i32, i32* %8, i64 0  %10 = load i32, i32* %9, align 4  %11 = load [1 x i32]*, [1 x i32]** %6, align 8  %12 = getelementptr inbounds [1 x i32], [1 x i32]* %11, i64 0  %13 = getelementptr inbounds [1 x i32], [1 x i32]* %12, i64 0, i64 0  %14 = load i32, i32* %13, align 4  %15 = load i32*, i32** %5, align 8  %16 = getelementptr inbounds i32, i32* %15, i64 0  %17 = load i32, i32* %16, align 4  %18 = load [1 x i32]*, [1 x i32]** %6, align 8  %19 = getelementptr inbounds [1 x i32], [1 x i32]* %18, i64 0  %20 = getelementptr inbounds [1 x i32], [1 x i32]* %19, i64 0, i64 0  call void @func1(i32 %17, i32* %20)  %21 = load i32, i32* %4, align 4  %22 = load i32*, i32** %5, align 8  %23 = load [1 x i32]*, [1 x i32]** %6, align 8  call void @func2(i32 %21, i32* %22, [1 x i32]* %23)  ret void&#125;</code></pre></div><p>可以看到，函数<code>@func2</code>一共接受了三种类型的参数：<code>i32</code>, <code>i32*</code>, <code>[1 x i32]*</code>，我们分别来看看如何使用。</p><h4 id="1-普通类型变量">1. 普通类型变量</h4><div class="code-wrapper"><pre><code class="hljs assembly">define void @func2(i32 %0, i32* %1, [1 x i32]* %2) #0 &#123;  %4 = alloca i32, align 4  store i32 %0, i32* %4, align 4  ...  &#125;</code></pre></div><p>可以看到，我们只要新建一个局部变量来接受此变量即可。</p><h4 id="2-数组类型变量">2. 数组类型变量</h4><p>首先我们需要注意到，无论数组类型形参的如何定义，始终都会以指针的形式出现。</p><p>如下两种写法最后生成的llvm代码会完全一致。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> c[][<span class="hljs-number">1</span>])</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b[<span class="hljs-number">1</span>], <span class="hljs-type">int</span> c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])</span>;</code></pre></div><p>首先，我们仍然需要新建局部变量来存放指针类型的值：</p><div class="code-wrapper"><pre><code class="hljs assembly">%5 = alloca i32*, align 8%6 = alloca [1 x i32]*, align 8store i32* %1, i32** %5, align 8store [1 x i32]* %2, [1 x i32]** %6, align 8</code></pre></div><p>接下来让我们看看赋值,已经知道赋值的流程为：取得元素地址-&gt;store，</p><p>回忆一下怎么给普通的数组元素赋值：</p><div class="code-wrapper"><pre><code class="hljs assembly">%6 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0store i32 1, i32* %6, align 4%7 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0%8 = getelementptr inbounds [1 x i32], [1 x i32]* %7, i64 0, i64 0store i32 1, i32* %8, align 4</code></pre></div><p>这里的<code>%2</code>和<code>%3</code>寄存器的数据类型是<code>[1 x i32]*</code>和<code>[1 x [1 x i32]]*</code>，而我们的<code>%5</code>和<code>%6</code>的数据类型分别是<code>i32**</code>和<code>[1 x i32]**</code>。</p><p>因此，我们要先使用load取得<code>%8</code>和<code>%9</code>，类型分别为<code>i32*</code>和<code>[1 x i32]*</code>，再使用<code>getelementptr</code>拿到对应位置的元素。</p><div class="code-wrapper"><pre><code class="hljs assembly">%8 = load i32*, i32** %5, align 8%9 = getelementptr inbounds i32, i32* %8, i64 0store i32 1, i32* %9, align 4%10 = load [1 x i32]*, [1 x i32]** %6, align 8%11 = getelementptr inbounds [1 x i32], [1 x i32]* %10, i64 0%12 = getelementptr inbounds [1 x i32], [1 x i32]* %11, i64 0, i64 0store i32 2, i32* %12, align 4</code></pre></div><p>在使用上，与之前的数组类似，分为以下几种情况：这里我们以<code>c</code>为例：</p><ol><li>当我们要取<code>c[0][0]</code>时：</li></ol><div class="code-wrapper"><pre><code class="hljs assembly">%11 = load [1 x i32]*, [1 x i32]** %6, align 8%12 = getelementptr inbounds [1 x i32], [1 x i32]* %11, i64 0%13 = getelementptr inbounds [1 x i32], [1 x i32]* %12, i64 0, i64 0%14 = load i32, i32* %13, align 4</code></pre></div><ol start="2"><li>当我们要取<code>c[0]</code>时：</li></ol><div class="code-wrapper"><pre><code class="hljs assembly">%18 = load [1 x i32]*, [1 x i32]** %6, align 8%19 = getelementptr inbounds [1 x i32], [1 x i32]* %18, i64 0%20 = getelementptr inbounds [1 x i32], [1 x i32]* %19, i64 0, i64 0</code></pre></div><p>可以看到，这两个命令对地址<code>@c</code>的getelementptr操作完全相同，只是<code>c[0][0]</code>多了一个取值的操作。</p><p>也就是说，在取址会故意多取一层，这与我们在处理函数形参时完全对应。</p><ol start="3"><li>同样的，直接取<code>b0</code>时：</li></ol><div class="code-wrapper"><pre><code class="hljs assembly">%23 = load [1 x i32]*, [1 x i32]** %6, align 8</code></pre></div><h2 id="总结">总结</h2><p>这次的实验真的很难，而且时间也比较紧凑。</p><p>主要的难点主要是数组、尤其是参数数组的处理以及逻辑语句，包括短路求值的处理，建议一边写文档一遍梳理思路，再写代码。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>LLVM</tag>
      
      <tag>代码生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何设计一个高并发系统</title>
    <link href="/2023/10/15/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/10/15/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1>0️⃣前言</h1><p>这篇文章写于作者在上2023秋季学期的软件系统分析与设计课时，针对课程要求设计的高并发和高性能学术成果分享平台的需求，所撰写的一篇笔记。囊括了笔者在网上所进行的一些学习和调研的结果。由于水平有限，难免出现不准确和错误，敬请批评指正。</p><h1>1️⃣如何设计一个高并发系统</h1><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231015161318179.png" alt="image-20231015161318179"></p><h1>2️⃣DNS和CDN</h1><h2 id="一、什么是DNS">一、什么是DNS</h2><ol><li><strong>DNS的定义</strong>：DNS是一个用于将人类可读的域名（<a href="http://xn--www-eo8e.baidu.com">如www.baidu.com</a>）转换成计算机可理解的IP地址（如192.168.1.1）的系统。</li><li><strong>DNS的作用</strong>：当你在浏览器中输入一个域名，<a href="http://xn--www-uc0ep96b.baidu.com">例如www.baidu.com</a>，你的计算机无法直接理解它，因此需要通过DNS来将域名翻译成对应的IP地址，以便连接到正确的服务器。</li><li><strong>DNS解析过程</strong>：当你请求DNS服务器解析一个域名时，DNS服务器首先检查它的缓存，如果已经保存了这个域名的IP地址，它会直接返回这个IP地址，以提高解析速度。如果缓存中没有相关记录，DNS服务器会按照递归的方式查询其他DNS服务器，直到找到该域名对应的IP地址。</li><li><strong>层层递归查询</strong>：例如，<a href="http://xn--www-x69d424ee11d2jd5x0a.baidu.com">当你要访问www.baidu.com</a>，首先向全球13个根服务器之一发起请求，询问.com域名的地址，然后它会将你引导到负责.com域名的名称服务器，再询问baidu.com域名的地址。这一层层的递归查询最终将找到你需要的IP地址。</li></ol><h2 id="二、CDN的基本原理和基础架构">二、CDN的基本原理和基础架构</h2><p>CDN是将源站<a href="https://www.zhihu.com/search?q=%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A193768864%7D">内容分发</a>至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、<a href="https://www.zhihu.com/search?q=%E7%9B%B4%E6%92%AD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A193768864%7D">直播</a>等场景。</p><p><strong>最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：</strong></p><ol><li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给<strong>CNAME指向的CDN专用DNS服务器</strong>。</li><li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</li><li>用户向CDN的全局负载均衡设备发起内容URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>区域负载均衡设备选择一台缓存服务器，考虑用户位置、请求内容和服务器负载情况。</li><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ol><p><img src="https://picx.zhimg.com/80/v2-7d4409a2d13943df2ca9c15defaec8c6_1440w.webp?source=1940ef5c" alt="img"></p><h2 id="三、CDN的应用">三、CDN的应用</h2><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离。动态文件可以结合<a href="https://www.zhihu.com/search?q=%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A193768864%7D">云服务器</a>ECS，静态资源如各类型图片、html、css、js文件等，建议结合 <a href="https://www.zhihu.com/search?q=%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A193768864%7D">对象存储</a>OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p><p><strong>架构示意图</strong></p><p><img src="https://picx.zhimg.com/80/v2-69de8db0b2538c59753bc6d39d66a4fd_1440w.webp?source=1940ef5c" alt="img"></p><h1>3️⃣Nginx</h1><p>Nginx（发音为&quot;engine-x&quot;）是一款高性能的开源反向代理服务器、负载均衡器和Web服务器。它具有出色的性能、稳定性和灵活性，常用于托管网站、应用程序和服务。</p><blockquote><p>**web服务器：**负责处理和响应用户请求，一般也称为http服务器，如 Apache、IIS、Nginx</p><p>**应用服务器：**存放和运行系统程序的服务器，负责处理程序中的业务逻辑，如 Tomcat、Weblogic、Jboss（现在大多数应用服务器也包含了web服务器的功能）</p></blockquote><h2 id="一、为什么要学习Nginx？">一、为什么要学习Nginx？</h2><p>Nginx 是全球排名前三的服务器，并且近年来用户增长非常快。</p><p>有人统计，世界上约有三分之一的网址采用了Nginx。在大型网站的架构中，Nginx被普遍使用，如 百度、阿里、腾讯、京东、网易、新浪、大疆等。</p><p>Nginx 安装简单，配置简洁，作用却无可替代。Nginx 是运维和后端的必修课，也是前端进阶的必修课。</p><p>因为掌握了Nginx，能让前端站得更高，更好的设计系统架构，更好的选择问题的解决方案，更好的服务业务开发。</p><h2 id="二、Ningx的应用">二、Ningx的应用</h2><h3 id="1-动静分离">1. 动静分离</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/17/171867d175eae45f~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>如上图所示，动静分离其实就是 Nginx 服务器将接收到的请求分为<strong>动态请求</strong>和<strong>静态请求</strong>。</p><p>静态请求直接从 nginx 服务器所设定的根目录路径去取对应的资源，动态请求转发给真实的后台（前面所说的应用服务器，如图中的Tomcat）去处理。</p><p>这样做不仅能给应用服务器减轻压力，将后台api接口服务化，还能将前后端代码分开并行开发和部署。</p><h3 id="2-反向代理">2. 反向代理</h3><p><strong>反向代理</strong>（Reverse Proxy）是一种网络服务器的部署方式，它代表服务器处理客户端请求，并将这些请求转发给一个或多个后端服务器。与传统的正向代理（Forward Proxy）不同，正向代理是代表客户端访问外部资源，而反向代理代表服务器提供服务。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/16/17183720f7a66978~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>反向代理应用十分广泛，CDN 服务就是反向代理经典的应用场景之一。除此之外，反向代理也是实现负载均衡的基础，很多大公司的架构都应用到了反向代理。</p><h3 id="3-负载均衡">3.  负载均衡</h3><p>在服务器集群中，Nginx 可以将接收到的客户端请求“均匀地”（严格讲并不一定均匀，可以通过设置权重）分配到这个集群中所有的服务器上。这个就叫做<strong>负载均衡</strong>。</p><p><strong>负载均衡的作用</strong></p><ul><li>分摊服务器集群压力</li><li>保证客户端访问的稳定性</li></ul><p>前面也提到了，负载均衡可以解决分摊服务器集群压力的问题。除此之外，Nginx还带有<strong>健康检查</strong>（服务器心跳检查）功能，会定期轮询向集群里的所有服务器发送健康检查请求，来检查集群中是否有服务器处于异常状态。</p><p>一旦发现某台服务器异常，那么在这以后代理进来的客户端请求都不会被发送到该服务器上（直健康检查发现该服务器已恢复正常），从而保证客户端访问的稳定性。</p><h2 id="三、参考资料">三、参考资料</h2><p><strong>Nginx 极简教程</strong>  <a href="https://github.com/dunwu/nginx-tutorial">https://github.com/dunwu/nginx-tutorial</a></p><p><strong>Nginx 文档</strong>. [cn]<a href="https://blog.redis.com.cn/doc/">https://blog.redis.com.cn/doc/</a> [en]<a href="https://nginx.org/en/docs/">https://nginx.org/en/docs/</a></p><p><strong>连前端都看得懂的《Nginx 入门指南》</strong>  <a href="https://juejin.cn/post/6844904129987526663">https://juejin.cn/post/6844904129987526663</a></p><h1>4️⃣ElasticSearch</h1><h2 id="一、什么是ElasticSearch">一、什么是ElasticSearch</h2><p>Elasticsearch是一个基于Apache Lucene™的开源搜索引擎，无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。<br>但是，Lucene只是一个库。想要发挥其强大的作用，你需使用Java并要将其集成到你的应用中。Lucene非常复杂，你需要深入的了解检索相关知识来理解它是如何工作的。<br>Elasticsearch也是使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过简单连贯的RESTful API让全文搜索变得简单并隐藏Lucene的复杂性。<br>不过，Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供：</p><ul><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li><li>实时分析的分布式搜索引擎</li><li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li></ul><p>而且，所有的这些功能被集成到一台服务器，你的应用可以通过简单的RESTful API、各种语言的客户端甚至命令行与之交互。上手Elasticsearch非常简单，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。Elasticsearch在Apache 2 license下许可使用，可以免费下载、使用和修改。</p><h2 id="二、ElasticSearch的使用">二、ElasticSearch的使用</h2><h3 id="1-ES构建索引-Hash分表">1. ES构建索引+Hash分表</h3><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231015172644192.png" alt="image-20231015172644192"></p><h3 id="2-不能把ES当作存储数据库">2. 不能把ES当作存储数据库</h3><ol><li>非关系型表达，大量的反范式存储，导致维护基础数据异常(新增异常，修改异常，删除异常)，需要MySQL做托底</li><li>不支持事务，一致性需要自己维护</li><li>从存储的角度来说，Elasticsearch是基于“字段”的，大行超多字段性能并不好</li></ol><h3 id="3-ES如何与MySQL保持一致">3. ES如何与MySQL保持一致</h3><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231015173358383.png" alt="image-20231015173358383"></p><h2 id="三、参考资料-2">三、参考资料</h2><p><strong>一天学会ES全文搜索引擎查询 Elasticsearch简单入门教程</strong>  <a href="https://www.bilibili.com/video/BV1Qh411e7Dq/">https://www.bilibili.com/video/BV1Qh411e7Dq/</a></p><p><strong>【IT老齐268】ElasticSearch与MySQL如何搭配，很多人都弄错了</strong>  <a href="https://www.bilibili.com/video/BV1H84y1e7AF/">https://www.bilibili.com/video/BV1H84y1e7AF/</a></p><h1>5️⃣RocketMQ</h1><h2 id="一、什么是RocketMQ">一、什么是RocketMQ</h2><p><strong>RocketMQ</strong>作为一款纯java、分布式、队列模型的开源消息中间件，支持事务消息、顺序消息、批量消息、定时消息、消息回溯等主流<strong>消息队列</strong>。</p><blockquote><p><strong>消息队列</strong></p><p>消息队列（Message Queue，简称MQ）是在消息的传输过程中保存消息的容器，其实本质就是一个保存数据的队列，多用于分布式系统之间进行通信。</p></blockquote><p>消息是指在应用之间传送的数据，消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。向消息队列中存放数据的叫做生产者，从消息队列中获取数据的叫做消费者。</p><p><img src="https://pic3.zhimg.com/80/v2-82e3a9c130e3bbaebc46f6b96679d71e_1440w.webp" alt="img"></p><p>消息中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和终一致性的系统架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。</p><h2 id="二、RocketMQ的应用">二、RocketMQ的应用</h2><ol><li><p><strong>异步处理</strong><br>异步处理，就是将一些非核心的业务流程以异步并行的方式执行，从而减少请求响应时间，提高系统吞吐量。</p><p>以注册为例，用户注册成功后，系统需要发送注短信注册成功通知，以及赠送注册成功的积分等一系列业务处理。假设用户注册10ms，短信通知和增加积分各100ms，不考虑网络等其他开销，则串行方式的总耗时是210ms。由于短信通知与增加积分为非核心流程，为了提升系统响应性能，从而把它改造为异步。用户注册后写入消息10ms左右立即返回成功给客户端，无需等待耗时较久的同步(短信+积分)就可以返回，从而极大的提升了系统的吞吐量。<br>所以异步的典型场景就是将比较耗时而且不需要即时（同步）返回结果的操作，通过消息队列来实现异步化。</p></li><li><p><strong>应用解耦</strong><br>应用解耦，顾名思义就是解除应用系统之间的耦合依赖。通过消息队列，使得每个应用系统不必受其他系统影响，可以更独立自主。<br>以电商系统为例，用户下单后，订单系统需要通知积分系统。一般的做法是：订单系统直接调用积分系统的接口。这就使得应用系统间的耦合特别紧密。如果积分系统无法访问，则积分处理失败，从而导致订单失败。<br>加入消息队列之后，用户下单后，订单系统完成下单业务后，将消息写入消息队列，返回用户订单下单成功。积分系统通过订阅下单消息的方式获取下单通知消息，从而进行积分操作。实现订单系统与库存系统的应用解耦。如果，在下单时积分系统系统异常，也不会影响用户正常下单。</p></li><li><p><strong>流量削峰</strong><br>流量削峰也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。<br>以秒杀活动为例，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列，后台系统根据消息队列中的消息信息，进行秒杀业务处理。<br>服务器接收到用户的请求后，首先写入消息队列，后台系统根据消息队列中的请求信息，做后续业务处理。假如消息队列长度超过大数量，则直接抛弃用户请求或跳转到错误页面。</p></li><li><p><strong>消息通讯</strong></p><p>消息通讯是指应用间的数据通信。消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等点对点通讯。</p></li></ol><h2 id="三、参考资料-3">三、参考资料</h2><p><strong>什么是消息列队MQ</strong>  <a href="https://zhuanlan.zhihu.com/p/653446497">https://zhuanlan.zhihu.com/p/653446497</a></p><p><strong>RocketMQ官方文档</strong> <a href="https://rocketmq.apache.org/zh/docs/">https://rocketmq.apache.org/zh/docs/</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>高并发</tag>
      
      <tag>CDN</tag>
      
      <tag>Nginx</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误处理和符号表</title>
    <link href="/2023/10/09/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2023/10/09/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1>错误处理和符号表</h1><h2 id="前言">前言</h2><p>之前的部分一直都没管错误处理和符号表，其实这也是不太对的，因为这两个部分会贯穿我们编译的全过程。</p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231010104043778.png" alt="image-20231010104043778"></p><p>本次实验的目的就是去补充错误处理和符号表这两个之前未曾完善的部分。</p><h2 id="错误处理">错误处理</h2><table><thead><tr><th>错误类型</th><th>错误类别码</th><th>解释</th><th>对应文法及出错符号 ( … 表示省略该条规则后续部分)</th></tr></thead><tbody><tr><td>非法符号</td><td>a</td><td>格式字符串中出现非法字符报错行号为 <strong><FormatString></strong> 所在行数。</td><td><FormatString> → ‘“‘{<Char>}’”</td></tr><tr><td>名字重定义</td><td>b</td><td>函数名或者变量名在<strong>当前作用域</strong>下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 <strong><Ident></strong> 所在行数。</td><td><ConstDef>→<Ident> … <VarDef>→<Ident> … <Ident> … <FuncDef>→<FuncType><Ident> … <FuncFParam> → <BType> <Ident> …</td></tr><tr><td>未定义的名字</td><td>c</td><td>使用了未定义的标识符报错行号为 <strong><Ident></strong> 所在行数。</td><td><LVal>→<Ident> … <UnaryExp>→<Ident> …</td></tr><tr><td>函数参数个数不匹配</td><td>d</td><td>函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td><td><UnaryExp>→<Ident>‘(’[<FuncRParams>]‘)’</td></tr><tr><td>函数参数类型不匹配</td><td>e</td><td>函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td><td><UnaryExp>→<Ident>‘(’[<FuncRParams>]‘)’</td></tr><tr><td>无返回值的函数存在不匹配的return语句</td><td>f</td><td>报错行号为 <strong>‘return’</strong> 所在行号。</td><td><Stmt>→‘return’ {‘[’<Exp>’]’}‘;’</td></tr><tr><td>有返回值的函数缺少return语句</td><td>g</td><td>只需要考虑函数末尾是否存在return语句，<strong>无需考虑数据流</strong>。报错行号为函数<strong>结尾的’}’</strong> 所在行号。</td><td><FuncDef> → <FuncType> <Ident> ‘(’ [<FuncFParams>] ‘)’ <Block> <MainFuncDef> → ‘int’ ‘main’ ‘(’ ‘)’ <Block></td></tr><tr><td>不能改变常量的值</td><td>h</td><td><LVal>为常量时，不能对其修改。报错行号为 <strong><LVal></strong> 所在行号。</td><td><Stmt>→<LVal>‘=’ <Exp>‘;’ <Stmt>→<LVal>‘=’ ‘getint’ ‘(’ ‘)’ ‘;’</td></tr><tr><td>缺少分号</td><td>i</td><td>报错行号为分号<strong>前一个非终结符</strong>所在行号。</td><td><Stmt>,<ConstDecl>及<VarDecl>中的’;’</td></tr><tr><td>缺少右小括号’)’</td><td>j</td><td>报错行号为右小括号<strong>前一个非终结符</strong>所在行号。</td><td>函数调用(<UnaryExp>)、函数定义(<FuncDef>)及<Stmt>中的’)’</td></tr><tr><td>缺少右中括号’]’</td><td>k</td><td>报错行号为右中括号<strong>前一个非终结符</strong>所在行号。</td><td>数组定义(<ConstDef>,<VarDef>,<FuncFParam>)和使用(<LVal>)中的’]’</td></tr><tr><td>printf中格式字符与表达式个数不匹配</td><td>l</td><td>报错行号为 <strong>‘printf’</strong> 所在行号。</td><td><Stmt> →‘printf’‘(’<FormatString>{,<Exp>}’)’‘;’</td></tr><tr><td>在非循环块中使用break和continue语句</td><td>m</td><td>报错行号为 <strong>‘break’</strong> 与 <strong>’continue’</strong> 所在行号。</td><td><Stmt>→‘break’‘;’ <Stmt>→‘continue’‘;’</td></tr></tbody></table><h3 id="错误的分类">错误的分类</h3><p>根据以上的错误规则，我们可以将错误分为三类：</p><ol><li>在词法分析阶段可以检查的错误：a</li><li>在语法分析阶段可以检查的错误：i、j、k</li><li>需要借助符号表进行检查的错误：其他错误</li></ol><p>其中第一类和第三类错误我们可以在语义分析中一边建立符号表，一边进行检测；而第二类错误我们必须要在语法分析阶段就识别并局部化，否则会影响到后续的工作。</p><h3 id="错误的局部化">错误的局部化</h3><p>在正确构建语法树的前提下，第一类和第三类错误的局部化是自动的。唯有第二类错误可能严重破坏语法树的构建，导致程序RE或者构建出完全错误的语法树，所以我们这里需要着重分析一下<strong>第二类错误</strong>。</p><p>在之前的代码中，我有不少地方的判断都是依赖于<code>;])</code>这三个符号，如果这三个符号发生缺失，程序有时会RE，有时会导致语法树完全畸形。</p><p>此外，如果缺少这三个符号，语法树会不完整，导致在错误处理时取对应位置的结点时会取到错误的结点。</p><p>这里我采取的措施是：</p><ol><li>在语法分析时，遇到要处理回溯的问题时，<strong>不要使用</strong><code>;])</code>这三个符号做判断。（尽管这样会变得更简单）</li><li>如果发现了这三个符号缺失，添加错误后在语法树中<strong>手动补充这个缺失</strong>。（因为这三个符号的有无并不影响实际的分析，补充后后期工作会变得更加简洁）</li></ol><h3 id="函数内部的错误检查">函数内部的错误检查</h3><p>虽然说正统的栈式符号表中，函数被调用时才开始建符号表。但是在我们的SysY语言中，在函数的定义处直接建表检查也是可以的，甚至会简化一些流程，因此这里我就偷懒直接检查了。</p><h2 id="总体设计">总体设计</h2><p>因为此处的错误处理需要处理的错误较少，仅需要粗粒度的判断即可。如果在之前递归下降子程序的类中进行设计，不仅工作量巨大，并且由于并不知道遍历抽象语法树时的最终要求，在之后生成中间代码的步骤中还可能面临多处重构的风险，故我单独将这部分抽出来，单独遍历一遍来找错误，以减少编码量和重构风险。</p><p>注意，这样的设计在总体来看不是最优的，而且会导致结构性地对错误的遗漏和性能的下降（Maybe），但是从完成任务的角度，我认为这样的设计是蛮不错的。</p><p>具体来说，我建立了两个类：</p><p><code>SysYException</code>和<code>ExceptionHandler</code>，显然地，<code>SysYException</code>是错误类，而对语法树遍历找错误、错误的添加和输出等任务主要在<code>ExceptionHandler</code>类中完成。</p><p>此外，错误处理的分析需要先建立符号表，所以我还在<code>frontend</code>中添加了一个<code>symbolTable</code>包，包括<code>SymbolTable</code>,<code>Symbol</code>,<code>VarSymbol</code>和<code>FuncSymbol</code>四个类。</p><p><code>SymbolTable</code>是符号表类，用于存储符号表。</p><p><code>Symbol</code>是符号基类，<code>VarSymbol</code>和<code>FuncSymbol</code>都继承于它，分别为变量符号和函数符号。</p><p>此时的文件树为：</p><div class="code-wrapper"><pre><code class="hljs nestedtext">-MyCompiler<span class="hljs-bullet">-</span> <span class="hljs-string">exception</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">SysException.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">ExceptionHandler.java</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">tree</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">BasicNode.java</span>    ... //其他节点类    <span class="hljs-bullet">-</span> <span class="hljs-string">symbolTable</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Symbol</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">SymbolTable</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">VarSymbol</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">FuncSymbol</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Unit.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Factory.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokens.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokenizer.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Scanner.java</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Compiler.java</span></code></pre></div><h3 id="SymbolTable">SymbolTable</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SymbolTable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Symbol&gt; symbolMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <span class="hljs-comment">//符号表主体</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SymbolTable parent; <span class="hljs-comment">//指向父节点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> inLoop;<span class="hljs-comment">//是否在循环中</span>  <span class="hljs-comment">//指定符号表是否在循环中</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SymbolTable</span><span class="hljs-params">(SymbolTable parent, <span class="hljs-type">boolean</span> inLoop)</span> &#123;&#125;  <span class="hljs-comment">//继承父符号表的循环情况</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SymbolTable</span><span class="hljs-params">(SymbolTable parent)</span> &#123;...&#125;    <span class="hljs-keyword">public</span> Symbol <span class="hljs-title function_">findSymbol</span><span class="hljs-params">(String name)</span>&#123;...&#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInLoop</span><span class="hljs-params">()</span>&#123;...&#125;    <span class="hljs-keyword">public</span> Symbol <span class="hljs-title function_">findSymbolInAll</span><span class="hljs-params">(String name)</span>&#123;...&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSymbol</span><span class="hljs-params">(Symbol symbol)</span>&#123;...&#125;&#125;</code></pre></div><h3 id="Symbol">Symbol</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Symbol</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Symbol</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;&#125;<span class="hljs-comment">//变量类符号</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VarSymbol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Symbol</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> dimension;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isConst;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VarSymbol</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> dimension, <span class="hljs-type">boolean</span> isConst)</span> &#123;...&#125;&#125;<span class="hljs-comment">//函数类符号</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FuncSymbol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Symbol</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> returnType retType;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> List&lt;FuncFParam&gt; params;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Block block;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FuncSymbol</span><span class="hljs-params">(String name, returnType retType, List&lt;FuncFParam&gt; params, Block block)</span> &#123;...&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">returnType</span>&#123;        INT,        VOID;    &#125;&#125;</code></pre></div><h3 id="ExceptionHandler">ExceptionHandler</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandler</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BufferedWriter bufferedWriter;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;SysYException&gt; errors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//存放所有的错误</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SymbolTable</span> <span class="hljs-variable">rootTable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SymbolTable</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">//全局符号表</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExceptionHandler</span><span class="hljs-params">(BufferedWriter bufferedWriter)</span> &#123;...&#125;<span class="hljs-comment">//添加错误</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addError</span><span class="hljs-params">(SysYException e)</span> &#123;...&#125;<span class="hljs-comment">//获得错误数</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;...&#125;<span class="hljs-comment">//打印全部错误，便与调试</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printErrors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;...&#125;  <span class="hljs-comment">//遍历抽象语法树分析错误</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">analyseError</span><span class="hljs-params">(CompUnit compUnit)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; compUnit.derivations.size(); i++) &#123;            <span class="hljs-type">Unit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> compUnit.derivations.get(i);            <span class="hljs-keyword">if</span> (unit <span class="hljs-keyword">instanceof</span> ConstDecl) &#123;                analyseConstDecl(rootTable, (ConstDecl) unit);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit <span class="hljs-keyword">instanceof</span> VarDecl) &#123;                analyseVarDecl(rootTable, (VarDecl) unit);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit <span class="hljs-keyword">instanceof</span> FuncDef) &#123;                analyseFuncDef(rootTable, (FuncDef) unit);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit <span class="hljs-keyword">instanceof</span> MainFuncDef) &#123;                analyseMainFuncDef(rootTable, (MainFuncDef) unit);            &#125;        &#125;    &#125;  <span class="hljs-comment">//更多的analyse函数，递归遍历抽象语法树</span>  ...    <span class="hljs-comment">//一些重要的工具函数，用于简化代码</span>    ...&#125;</code></pre></div><h3 id="SysYException">SysYException</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysYException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;SysYException&gt;&#123;    <span class="hljs-keyword">public</span> ExceptionKind kind;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> line;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SysYException</span><span class="hljs-params">(ExceptionKind kind, <span class="hljs-type">int</span> line)</span> &#123;        <span class="hljs-built_in">this</span>.kind = kind;        <span class="hljs-built_in">this</span>.line = line;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> line+<span class="hljs-string">&quot; &quot;</span>+kind.code;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(SysYException o)</span> &#123;        <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.line, o.line);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExceptionKind</span> &#123;        ILLEGAL_SYMBOL(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;格式字符串中出现非法字符&quot;</span>),...        ERROR(<span class="hljs-string">&quot;unexpected error&quot;</span>, <span class="hljs-string">&quot;未知错误&quot;</span>);        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String code;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String description;        ExceptionKind(String s, String description) &#123;            <span class="hljs-built_in">this</span>.code = s;            <span class="hljs-built_in">this</span>.description = description;        &#125;    &#125;&#125;</code></pre></div><h2 id="总结">总结</h2><p>这次实验比语法分析感觉有又困难了一些，而且想通过测试的调试难度也明显增加，太可怕了。。。</p><p>这更突出一开始构思好架构，增加代码的完善性和稳健性的重要性。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>词法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语法分析</title>
    <link href="/2023/09/30/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/30/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1>语法分析</h1><h2 id="前言">前言</h2><p>在上一次实验中，我们完成了词法分析，并在Scanner中保存了Token表，这是极好的。</p><p>今天的任务是再次遍历所有token，形成对应的语法树。我使用的分析方法是递归下降子程序法，而需要注意的问题是程序中存在的左递归和回溯。</p><h2 id="分析语法">分析语法</h2><p>要构造对应的语法树，我们首先必须充分了解想要分析的语法规则。</p><p>实验中的语法规则如下表所示：</p><table><thead><tr><th>名称</th><th>符号</th><th>推导结果</th><th>备注</th></tr></thead><tbody><tr><td>编译单元</td><td>CompUnit</td><td>{Decl} {FuncDef} MainFuncDef</td><td></td></tr><tr><td>声明</td><td>Decl</td><td>ConstDecl<br />VarDecl</td><td></td></tr><tr><td>常量声明</td><td>ConstDecl</td><td>‘const’ BType ConstDef { ‘,’ ConstDef } ‘;’</td><td></td></tr><tr><td>基本类型</td><td>BType</td><td>‘int’</td><td></td></tr><tr><td>常数定义</td><td>ConstDef</td><td>Ident { ‘[’ ConstExp ‘]’ } ‘=’ ConstInitVal</td><td></td></tr><tr><td>常量初值</td><td>ConstInitVal</td><td>ConstExp<br />‘{’ [ ConstInitVal { ‘,’ ConstInitVal } ] ‘}’</td><td></td></tr><tr><td>变量声明</td><td>VarDecl</td><td>BType VarDef { ‘,’ VarDef } ‘;’<br />Ident { ‘[’ ConstExp ‘]’ } ‘=’ InitVal</td><td></td></tr><tr><td>变量初值</td><td>InitVal</td><td>Exp<br />‘{’ [ InitVal { ‘,’ InitVal } ] ‘}’</td><td></td></tr><tr><td>函数定义</td><td>FuncDef</td><td>FuncType Ident ‘(’ [FuncFParams] ‘)’ Block</td><td></td></tr><tr><td>主函数定义</td><td>MainFuncDef</td><td>‘int’ ‘main’ ‘(’ ‘)’ Block</td><td></td></tr><tr><td>函数类型</td><td>FuncType</td><td>‘void’ <br />‘int’</td><td></td></tr><tr><td>函数形参表</td><td>FuncFParams</td><td>FuncFParam { ‘,’ FuncFParam }</td><td></td></tr><tr><td>函数形参</td><td>FuncFParam</td><td>BType Ident [‘[’ ‘]’ { ‘[’ ConstExp ‘]’ }]</td><td></td></tr><tr><td>语句块</td><td>Block</td><td>‘{’ { BlockItem } ‘}’</td><td></td></tr><tr><td>语句块项</td><td>BlockItem</td><td>Decl <br />Stmt</td><td></td></tr><tr><td>语句</td><td>Stmt</td><td>LVal ‘=’ Exp ‘;’ <br />[Exp]  ‘;’<br />Block<br />‘if’ ‘(’ Cond ‘)’ Stmt [ ‘else’ Stmt ]<br />‘for’ ‘(’ [ForStmt] ‘;’ [Cond] ‘;’ [forStmt] ‘)’ Stmt<br />‘break’ ‘;’<br />‘continue’ ‘;’<br />‘return’ [Exp] ‘;’<br />LVal ‘=’ ‘getint’‘(’‘)’‘;’<br />‘printf’‘(‘FormatString{’,‘Exp}’)’‘;’</td><td>左递归</td></tr><tr><td>语句</td><td>ForStmt</td><td>LVal ‘=’ Exp</td><td></td></tr><tr><td>表达式</td><td>Exp</td><td>AddExp</td><td></td></tr><tr><td>条件表达式</td><td>Cond</td><td>LOrExp</td><td></td></tr><tr><td>左值表达式</td><td>LVal</td><td>Ident {‘[’ Exp ‘]’}</td><td></td></tr><tr><td>基本表达式</td><td>PrimaryExp</td><td>‘(’ Exp ‘)’<br />LVal<br />Number</td><td></td></tr><tr><td>数值</td><td>Number</td><td>IntConst</td><td></td></tr><tr><td>一元表达式</td><td>UnaryExp</td><td>PrimaryExp<br />Ident ‘(’ [FuncRParams] ‘)’<br />UnaryOp UnaryExp</td><td></td></tr><tr><td>单目运算符</td><td>UnaryOp</td><td>‘+’  <br />‘-’<br />‘!’</td><td>'!'仅出现在条件表达式中</td></tr><tr><td>函数实参表</td><td>FuncRParams</td><td>Exp { ‘,’ Exp }</td><td></td></tr><tr><td>乘除模表达式</td><td>MulExp</td><td>UnaryExp<br /> (‘*’ | ‘/’  | ‘%’ ) UnaryExp</td><td>左递归</td></tr><tr><td>加减表达式</td><td>AddExp</td><td>MulExp<br />AddExp (‘+’ | ‘−’) MulExp</td><td>左递归</td></tr><tr><td>关系表达式</td><td>RelExp</td><td>AddExp<br />RelExp (‘&lt;’ | ‘&gt;’  | ‘&lt;=’ | ‘&gt;=’) AddExp</td><td>左递归</td></tr><tr><td>相等性表达式</td><td>EqExp</td><td>RelExp<br />EqExp (‘==’ | ‘!=’) RelExp</td><td>左递归</td></tr><tr><td>逻辑与表达式</td><td>LAndExp</td><td>EqExp<br />LAndExp ‘&amp;&amp;’ EqExp</td><td>左递归</td></tr><tr><td>逻辑或表达式</td><td>LOrExp</td><td>LAndExp <br />LOrExp ‘||’ LAndExp</td><td>左递归</td></tr><tr><td>常量表达式</td><td>ConstExp</td><td>AddExp</td><td>使用的Ident 必须是常量</td></tr></tbody></table><h3 id="左递归问题">左递归问题</h3><p>其中我们可以看到表达式的部分出现了很多左递归，这里我们使用改写BNF范式的做法。改写后如下所示：</p><table><thead><tr><th>名称</th><th>符号</th><th>推导结果</th></tr></thead><tbody><tr><td>乘除模表达式</td><td>MulExp</td><td>UnaryExp { (‘*’ |  ‘/’ | ‘%’ ) UnaryExp}</td></tr><tr><td>加减表达式</td><td>AddExp</td><td>MulExp { (‘+’ | ‘-’) MulExp}</td></tr><tr><td>关系表达式</td><td>RelExp</td><td>AddExp { (‘&lt;’ | ‘&gt;’ | ‘&lt;=’ | ‘&gt;=’) AddExp}</td></tr><tr><td>相等性表达式</td><td>EqExp</td><td>RelExp { (‘==’ | ‘!=’) RelExp}</td></tr><tr><td>逻辑与表达式</td><td>LAndExp</td><td>EqExp { ‘&amp;&amp;’ EqExp}</td></tr><tr><td>关系表达式</td><td>LOrExp</td><td>LAndExp { ‘||’ LAndExp}</td></tr></tbody></table><p>需要注意的是，这样做可能会导致语法树的结构较原来发生变化。输出时必须以原语法树为准!!</p><blockquote><p><strong>以AddExp为例，按照<code>MulExp &#123; ('+' \| '-') MulExp&#125;</code>这样的产生式进行分析，右边的{ (‘+’ | ‘-’) MulExp}重复几次，实际上就需要嵌套地生成几个AddExp。因此，我们必须在程序中格外注意这一点。</strong></p></blockquote><h3 id="回溯问题">回溯问题</h3><p>在多产生式的情况下，一个问题是回溯问题。我们可以通过求产生式FIRST集来预测和解决回溯问题，举个例子：</p><table><thead><tr><th>名称</th><th>符号</th><th>产生式FIRST集</th><th>备注</th></tr></thead><tbody><tr><td>编译单元</td><td>CompUnit</td><td>Decl: {“const”, “int”} FuncDef:{“void”, “int”} MainFuncDef:{“int”}</td><td>回溯</td></tr><tr><td>一元表达式</td><td>UnaryExp</td><td>PrimaryExp:{“(”, Ident, “0”,…,“9”}    {Ident}   UnaryOp:{“+”,“-”,“!”}</td><td>回溯</td></tr><tr><td>基本表达式</td><td>PrimaryExp</td><td>{‘(’}  LVal:{Ident} Number:{IntConst}</td><td>回溯</td></tr><tr><td>语句块项</td><td>BlockItem</td><td>Decl: {“const”, “int”}  Stmt{}</td><td>回溯</td></tr><tr><td>语句</td><td>Stmt</td><td>略</td><td>回溯</td></tr></tbody></table><p>这种情况下，应该使用再继续向前看，直到出现不一致时，方可区分到底是哪个产生式。</p><p>另一种方法是通过改写产生式来解决这个问题，但是这样做的问题是会破坏原来的产生式，导致想把输出调成原来的样子还要做一些额外的设计。考虑到我们并不追求性能，那就还是使用粗暴一些的方式来减少编码的难度吧！</p><p>这里值得特别说说的是Stmt，因为它的产生式实在是太复杂！</p><p>这里我们单拉出来分析分析：</p><p>Stmt</p><ul><li>Block</li><li>‘if’ ‘(’ Cond ‘)’ Stmt [ ‘else’ Stmt ]</li><li>‘for’ ‘(’ [ForStmt] ‘;’ [Cond] ‘;’ [forStmt] ‘)’ Stmt</li><li>‘break’ ‘;’ | ‘continue’ ‘;’</li><li>‘return’ [Exp] ‘;’</li><li>‘printf’‘(‘FormatString{’,‘Exp}’)’‘;’</li><li>LVal ‘=’ Exp ‘;’</li><li>[Exp] ‘;’</li><li>LVal ‘=’ ‘getint’‘(’‘)’‘;’</li></ul><p>在LVal之前的都还比较简单，但是最后三条确实非常难以区分，这里给出我的思路：</p><ol><li>如果当前的token为’;'，那么产生式一定为 ‘;’</li><li>因为Exp可以推导出LVal，因此想直接区分两者会非常困难。但是，考虑到LVal后一定会接’=‘，而Exp后一定会接’;'，因此可以考虑先把第一个语法成分放着，转而去判断后面的token，从而区分Exp和Val。</li><li>怎么才能“把第一个语法成分放着”，毕竟我们也不知道Exp和LVal的长度？一种思路是使用Exp去直接分析，由于LVal可以通过Exp推出，因此两种可能性都不会报错。当确定类型后，我们再改回正确的类型即可。</li></ol><h2 id="总体结构">总体结构</h2><p><strong>调整</strong></p><ol><li>在上次的基础上调整了<code>exception</code>包的位置，感觉应该不止前端会出现异常，所以放在外面了。</li><li><code>Factory</code>类现在保存了<code>Parser</code>类的单例。</li></ol><p><strong>新增</strong></p><ol><li><code>Unit</code>接口。Unit是语法分析的基本单位，无论是终结符还是非终结符都实现了<code>Unit</code>接口。</li><li><code>Pareser</code>类。这个类是语法分析的主要执行者，使用了递归下降子程序的方法来进行语法分析。</li><li><code>tree</code>包。包内有语法成分的基本类<code>BasicNode</code>，实现了<code>Unit</code>；以及所有的语法树的节点类，所有的语法节点都继承<code>BasicNode</code>。</li></ol><p>目前的文件结构为：</p><div class="code-wrapper"><pre><code class="hljs nestedtext">-MyCompiler<span class="hljs-bullet">-</span> <span class="hljs-string">exception</span>    -SysException.java  <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">tree</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">BasicNode.java</span>    ... //其他节点类    <span class="hljs-bullet">-</span> <span class="hljs-string">Unit.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Factory.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokens.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokenizer.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Scanner.java</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Compiler.java</span></code></pre></div><h3 id="Parser">Parser</h3><p><code>Pareser</code>类是语法分析的主要执行者，使用了递归下降子程序的方法来进行语法分析。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parser</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Scanner scanner;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExceptionHandler exceptionHandler;    <span class="hljs-keyword">public</span> CompUnit compUnit;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BufferedWriter bufferedWriter;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Parser</span><span class="hljs-params">(Scanner scanner, ExceptionHandler exceptionHandler, BufferedWriter bw)</span> &#123;...&#125;  <span class="hljs-comment">//在判断后将token插入语法树</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAfterAssert</span><span class="hljs-params">(ArrayList&lt;Unit&gt; nodes, Tokens.Token token, Tokens.TokenKind kind)</span> <span class="hljs-keyword">throws</span> SysYException &#123;...&#125;  <span class="hljs-comment">//语法分析主函数</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syntaxAnalyse</span><span class="hljs-params">(<span class="hljs-type">boolean</span> print)</span> <span class="hljs-keyword">throws</span> SysYException, IOException &#123;      ...    <span class="hljs-comment">//调用parseCompUnit(),开始递归子程序分析</span>    &#125;    <span class="hljs-keyword">private</span> CompUnit <span class="hljs-title function_">parseCompUnit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SysYException &#123;...&#125;    <span class="hljs-comment">//其他子程序定义</span>  ...          <span class="hljs-comment">//一些简化代码的工具函数</span>    ...&#125;</code></pre></div><h3 id="BasicNode">BasicNode</h3><p><code>BasicNode</code>是所有语法树节点的父类，规定了所有节点的共有属性和方法。</p><p>SysY文法中每一个非终结符都对应了一个语法树节点类。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Unit</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name;<span class="hljs-comment">//该节点的名字</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> List&lt;Unit&gt; derivations; <span class="hljs-comment">//保存下每个结点的子结点</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BasicNode</span><span class="hljs-params">(String name, List&lt;Unit&gt; units)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.derivations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(units);    &#125;      <span class="hljs-comment">//一次性输出整棵树</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> derivations.stream()                .map(Unit::toString)                .reduce((s1, s2) -&gt; s1 + <span class="hljs-string">&quot;\n&quot;</span> + s2).orElse(<span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;\n&lt;&quot;</span> + name + <span class="hljs-string">&quot;&gt;&quot;</span>;    &#125;&#125;<span class="hljs-comment">//CompUnit示例</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompUnit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicNode</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CompUnit</span><span class="hljs-params">(List&lt;Unit&gt; units)</span> &#123;        <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;CompUnit&quot;</span>, units);    &#125;&#125;</code></pre></div><h2 id="总结">总结</h2><p>这次实验开始上强度了，完整地构造语法树确实要花不少功夫。一个比较突出的感悟是比较合理的类的设计和工具方法的实现确实能够很大程度上让开发变得更加简单和丝滑。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>词法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析</title>
    <link href="/2023/09/20/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/20/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1>词法分析</h1><h2 id="总体结构">总体结构</h2><p>在上次的基础上主要新增三个类：<code>Tokens</code>、<code>Tokenizer</code>和<code>Scanner</code>。</p><p>目前的文件树长这样：</p><div class="code-wrapper"><pre><code class="hljs nestedtext">-MyCompiler  <span class="hljs-bullet">-</span> <span class="hljs-string">Frontend</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">exception</span>    -SysException.java    <span class="hljs-bullet">-</span> <span class="hljs-string">Factory.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokens.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokenizer.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Scanner.java</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Backend</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Compiler.java</span></code></pre></div><h3 id="Tokens">Tokens</h3><p>Tokens是一个代表Token的类，有两个内部类，一个是代表Token类型的枚举类TokenKind，另一个是代表一个Token对象的Token类。</p><p>其中：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tokens</span> &#123;<span class="hljs-comment">//Tokens类中会声明一些工具方法来辅助词法分析的进行，如：</span>    <span class="hljs-comment">//isExist：查询tokenName是否是Token关键词</span>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExist</span><span class="hljs-params">(String tokenName)</span> &#123;...&#125;...          <span class="hljs-comment">//define ALL kinds of token</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TokenKind</span> &#123;        IDENT(<span class="hljs-string">&quot;Ident&quot;</span>, <span class="hljs-string">&quot;IDENFR&quot;</span>),        INTCONST(<span class="hljs-string">&quot;IntConst&quot;</span>, <span class="hljs-string">&quot;INTCON&quot;</span>),        FMTSTRING(<span class="hljs-string">&quot;FormatString&quot;</span>, <span class="hljs-string">&quot;STRCON&quot;</span>),      <span class="hljs-comment">//...</span>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tag;    &#125;  <span class="hljs-comment">//Token实体类</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Unit</span>&#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><p>其中Token类承载了最多的功能：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Token</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Unit</span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-type">TokenKind</span> <span class="hljs-variable">kind</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">identValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">lineLocated</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//不同的构造函数对应不同类型的Token创建方法</span>    <span class="hljs-comment">//对于tokenName和TokenKind直接匹配的情况，可以直接识别，不需要再switch</span><span class="hljs-keyword">public</span> <span class="hljs-title function_">Token</span><span class="hljs-params">(String tokenName, Integer lineLocated)</span> &#123;&#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Token</span><span class="hljs-params">(TokenKind kind, Integer lineLocated)</span> &#123;&#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Token</span><span class="hljs-params">(TokenKind kind, String identValue, Integer lineLocated)</span> &#123;&#125;    <span class="hljs-comment">//此外还有一些get、set接口提供Token的对外访问</span>        ...    &#125;</code></pre></div><p>多样化的Token构造方法可以允许我们便捷地识别生成Token，为接下来的词法分析工作提供便利。</p><h3 id="Tokenizer">Tokenizer</h3><p><code>Tokenizer</code>是进行词法分析的类。结合我们画的状态转移图编写合适的词法分析函数，从而完成词法分析这一过程，并将所有Token存放在Scanner中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tokenizer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Tokens tokens;<span class="hljs-comment">//tokens定义了Token </span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Scanner scanner;<span class="hljs-comment">//词法分析出的tokens会存放在scanner中</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BufferedReader bufferedReader;<span class="hljs-comment">//写文件</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringBuilder sb;<span class="hljs-comment">//帮助构建Token字符串</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> charRead; <span class="hljs-comment">//保存当前读入的字符</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> curLine;<span class="hljs-comment">//保存行号</span>      Tokenizer(Tokens tokens, Scanner scanner, BufferedReader bufferedReader) &#123;...&#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, SysYException &#123;...&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lexicalAnalyse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;...&#125;    <span class="hljs-comment">//此外还有若干私有的工具方法来辅助进行词法分析，这里不细说了</span>  ...&#125;</code></pre></div><h3 id="Scanner">Scanner</h3><p><code>Scanner</code>是一个辅助类，作用是存放词法分析得到的所有token，并在语法分析中直接使用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;Tokens.Token&gt; tokens = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//存放token</span>    <span class="hljs-keyword">private</span> BufferedWriter bufferedWriter;  <span class="hljs-comment">//输出</span>    <span class="hljs-keyword">private</span> Tokens.Token token;  <span class="hljs-comment">//当前的token</span>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Scanner</span><span class="hljs-params">(BufferedWriter bufferedWriter)</span> &#123;...&#125;  <span class="hljs-comment">//在词法分析中存放token</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putToken</span><span class="hljs-params">(Tokens.Token t)</span> &#123;...&#125;    <span class="hljs-comment">//在语法分析中取用token</span>  <span class="hljs-comment">//将错误处理等复杂性隐藏在接口中，简化代码</span>    <span class="hljs-keyword">public</span> Tokens.Token <span class="hljs-title function_">next</span><span class="hljs-params">()</span>&#123;...&#125;    <span class="hljs-keyword">public</span> Tokens.Token <span class="hljs-title function_">lookAhead</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span>&#123;...&#125;      <span class="hljs-keyword">public</span> Tokens.Token <span class="hljs-title function_">getToken</span><span class="hljs-params">()</span>&#123;...&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllTokens</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;...&#125;&#125;</code></pre></div><h2 id="状态转移图">状态转移图</h2><p><code>Tokenizer</code>的主函数编写需要借助一个完整的状态转移图。所以词法分析最重要的是画状态图，把状态转移图画出来了，写代码就非常愉快了！😄</p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20230919213836456.png" alt=""></p><h2 id="总结">总结</h2><p>这次实验还是比较简单的，但是需要我们一开始把框架搭好！希望之后不会反复重构吧～～</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>词法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总体设计</title>
    <link href="/2023/09/19/%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/09/19/%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1>总体设计</h1><h2 id="前言">前言</h2><p>本次的编译器实现我准备采用<code>Java</code>语言来写，主要有三个方面的考虑：</p><ol><li>之前上过JAVA-OOP，对java的语法和面向对象编程的机制都更加熟悉。</li><li>因为我是Mac和Win双持用户，再加上考试的时候的评测机的C艹编译器也捉摸不定，想统一环境实在有些困难，此时Java虚拟机的优势就显现的非常明显了。</li><li>小伙伴们都用的Java，方便交流讨论。</li></ol><p>确定了语言之后，就可以<s>快乐的</s>开始写代码了！</p><h2 id="Javac介绍">Javac介绍</h2><p>考虑到之后还会有很多新需求，无论如何可能都没有办法避免重构，所以其实一开始也不用设计的太好啦！</p><p>但是为了能减少以后的工作量，一定程度的设计也是要有的。我没有按照课程组的推荐去参考pascals和pl0的编译器——太古老了。这从1989流传至今，甚至是用word文档保存的代码，看得人头疼。</p><p>因此，我挑挑选选，决定参考<code>javac</code>的源代码。</p><p>主要有两个优势：</p><ol><li>GitHub上有现成的源码，查看非常方便。</li><li>javac的源码是用Java语言写的，非常适合我学习借鉴；同时Java语言本身与C也比较相似，没有很大的迁移成本。</li></ol><h3 id="Javac结构初探">Javac结构初探</h3><p>源码在这里可以找到：<a href="https://github.com/openjdk/jdk/tree/master/src/jdk.compiler/share/classes/com/sun/tools/javac">https://github.com/openjdk/jdk/tree/master/src/jdk.compiler/share/classes/com/sun/tools/javac</a></p><p>这里是一篇有用的笔记：<a href="http://47.100.139.123/blog/article/26">http://47.100.139.123/blog/article/26</a></p><p>由于Java本身的复杂性，可想而知Javac也一定是一个非常非常复杂的系统。因此在看代码的过程中，我们必须化繁为简，只去看有用的和大致的骨架，方可不迷失在巨大的代码仓库中～</p><p>因此，我选择先通过编译的几个阶段划分+参考一些博客，大致确定每个阶段都有哪些部分在发挥作用，然后再去针对性地阅读对应的代码，以给我自己的编译器设计一些insights。</p><p>具体来说，在进行词法分析时，我针对性地寻找Tokenizer类，发现Tokenizer类中使用了Scanner类，又再去理解Scanner的作用和结构……</p><h2 id="总体结构">总体结构</h2><p>稍微阅读了一些源码，再结合一些前辈的经验，我写的简化版架构如下：</p><div class="code-wrapper"><pre><code class="hljs nestedtext">-MyCompiler  <span class="hljs-bullet">-</span> <span class="hljs-string">Frontend</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">exception</span>    -SysException.java    <span class="hljs-bullet">-</span> <span class="hljs-string">Factory.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokens.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Tokenizer.java</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">Scanner.java</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Backend</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Compiler.java</span></code></pre></div><p>其中：</p><ul><li><code>Compiler.java</code> 负责编译器的主体任务，包括初始化，启动和销毁。</li><li><code>Frontend</code>包负责前端工作，当然就包括本次的词法分析。<ul><li><code>Tokens.java</code>负责声明所有的Token。</li><li><code>Tokenizer.java</code>负责做词法分析。</li><li><code>Scanner.java</code>是为以后预留的类，方便后续的工作。</li><li><code>Factory.java</code>负责产生和提供Tokenizer、Scanner、Tokens等类的实例，保证单例。</li><li><code>exception</code>包里声明可能出现的异常。</li></ul></li><li><code>Backend</code>包负责后端工作，目前是个摆设。</li></ul><p>以后如果需要的话，还可以加入<code>Midend</code>中端来进行桥接。</p><h2 id="接口设计">接口设计</h2><p>因为这里还是初步设计架构，因此目前需要实现的只有<code>Compiler</code>和<code>Factory</code>两个类。</p><h3 id="Compiler">Compiler</h3><p><code>Compiler.java</code> 是程序的入口，在这里设置输出文件，并安排编译器整体的运行情况。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compiler</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;testfile.txt&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;error.txt&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, SysYException &#123;        <span class="hljs-comment">//初始化</span>      <span class="hljs-comment">//词法分析</span>      <span class="hljs-comment">//语法分析</span>      <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre></div><h3 id="Factory">Factory</h3><p>Factory是工厂类，作用是初始化并产生单例实体以供其他类调用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;  <span class="hljs-keyword">private</span> Tokens tokens;    <span class="hljs-keyword">private</span> Tokenizer tokenizer;    <span class="hljs-keyword">private</span> Scanner scanner;    <span class="hljs-keyword">private</span> Parser parser;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initCompiler</span><span class="hljs-params">(BufferedReader bufferedReader, BufferedWriter bufferedWriter)</span> &#123;        scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(bufferedWriter);        tokens = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tokens</span>();        tokenizer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tokenizer</span>(tokens, scanner, bufferedReader);        parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parser</span>(scanner, exceptionHandler, bufferedWriter);    &#125;    <span class="hljs-keyword">public</span> Tokenizer <span class="hljs-title function_">getTokenizer</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> tokenizer;    &#125;    <span class="hljs-keyword">public</span> Parser <span class="hljs-title function_">getParser</span><span class="hljs-params">()</span>&#123;      <span class="hljs-keyword">return</span> parser;    &#125;    <span class="hljs-keyword">public</span> Scanner <span class="hljs-title function_">getScanner</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> scanner;    &#125;    <span class="hljs-keyword">public</span> Tokens <span class="hljs-title function_">getTokens</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> tokens;    &#125;  <span class="hljs-comment">//...</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>编译技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
      <tag>词法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_挑战性任务-实现TLB快重填</title>
    <link href="/2023/06/22/%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1-%E5%AE%9E%E7%8E%B0TLB%E5%BF%AB%E9%87%8D%E5%A1%AB/"/>
    <url>/2023/06/22/%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1-%E5%AE%9E%E7%8E%B0TLB%E5%BF%AB%E9%87%8D%E5%A1%AB/</url>
    
    <content type="html"><![CDATA[<h1>题目</h1><p>实现TLB快重填</p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240407200928561.png" alt="image-20240407200928561"></p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240407200943261.png" alt="image-20240407200943261"></p><h1>实现思路</h1><p>总的来说，lab2挑战性任务的实现过程主要分为四个部分，分别是：</p><ol><li>将页表映射到 kseg2 区域。</li><li>初始化Context寄存器。</li><li>实现 TLB 快速重填程序。</li><li>实现一个测试程序体现重填加速效果。<br>接下来，我将一步一步地对我做的工作进行介绍。</li></ol><h2 id="将页表映射到-kseg2-区域">将页表映射到 kseg2 区域</h2><p>首先我们要明确页表映射的位置。<br>kesg2空间较大（1G），且似乎未被使用过，故可以随意选择页表的映射位置。我这里选择将页表映射到kseg的起始位置，即<code>KSEG2</code>。<br>我们知道每个进程初始化其虚拟内存是在<code>\kern\env.c</code>文件中的<code>env_setup_vm</code>函数内完成的, 函数将进程的页表映射至<code>UVPT</code>。为了在在不影响 MOS 已有的页面管理机制的情况下，将 MOS 目前的页表映射到kseg2，我没有破坏原本在<code>UVPT</code>的映射, 而是选择加入新的到<code>KSEG2</code>的映射。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span> &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span>;</span>try(page_alloc(&amp;p));p-&gt;pp_ref++;e-&gt;env_pgdir = (Pde *)page2kva(p);<span class="hljs-built_in">memcpy</span>(e-&gt;env_pgdir, base_pgdir, BY2PG);e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;p-&gt;pp_ref++;e-&gt;env_pgdir[PDX(KSEG2)] = PADDR(e-&gt;env_pgdir) | PTE_V;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="初始化Context寄存器">初始化Context寄存器</h2><p>首先要了解Contest寄存器的工作原理：<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230616204601.png" alt="image.png"><br><code>PTEBase</code>：kseg2 页表基地址的高11位。<br><code>Bad VPN</code>：出现 TLB miss 异常的地址的虚页号，与 BadVaddr 的高位相同。</p><p>这里kseg2页表基址是11位，也就是说context寄存器要求我们的页表大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup></mrow><annotation encoding="application/x-tex">2^{21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span></span></span></span></span></span></span></span>位，也即是2MB对齐的，这正好对应了用户空间的大小。<br>这里的基址需要我们自己去设置，使用<code>mtc0</code>指令即可，设置一次，后面都无需设置。</p><p>我是在<code>page_init</code>分页管理初始化函数中对CONTEXT寄存器进行设置的，调用了我在<code>tlb_asm.S</code>中定义的函数<code>tlb_init</code> 。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LEAF</span><span class="hljs-params">(tlb_init)</span></span>    <span class="hljs-selector-tag">li</span>  t0, <span class="hljs-number">0</span>xC0000000    mtc0    t0, CP0_CONTEXT    jr ra<span class="hljs-function"><span class="hljs-title">END</span><span class="hljs-params">(tlb_init)</span></span></code></pre></div><h2 id="实现-TLB-快速重填程序">实现 TLB 快速重填程序</h2><p>这是整个任务中最困难和最复杂的部分。<br>先看代码，然后我根据代码添加注释梳理实现的思路：</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 声明三个变量，分别用于暂存ra，ENTRYHI和BADVADDR的值</span><span class="hljs-meta">.data</span><span class="hljs-symbol">temp_EPC:</span><span class="hljs-meta">.word</span> <span class="hljs-number">0</span><span class="hljs-symbol">temp_ENTRYHI:</span><span class="hljs-meta">.word</span> <span class="hljs-number">0</span><span class="hljs-symbol">temp_BADVADDR:</span><span class="hljs-meta">.word</span> <span class="hljs-number">0</span><span class="hljs-meta">.text</span><span class="hljs-comment"># 快速重填函数的主体部分</span><span class="hljs-symbol">fast_tlb_refill:</span><span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><span class="hljs-keyword"></span><span class="hljs-meta">.set</span> noat<span class="hljs-comment"># 在这个函数中最好只使用k0,k1寄存器以避免未知错误</span><span class="hljs-comment"># 从对应寄存器中取出我们想要暂存的值，包括CP0_EPC,CP0_ENTRYHI,CP0_BADVADDR</span><span class="hljs-keyword">mfc0 </span><span class="hljs-built_in">k0</span>, CP0_EPCla <span class="hljs-built_in">k1</span>, temp_EPC<span class="hljs-keyword">sw </span><span class="hljs-built_in">k0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k1</span>)<span class="hljs-keyword">mfc0 </span><span class="hljs-built_in">k0</span>, CP0_ENTRYHIla <span class="hljs-built_in">k1</span>, temp_ENTRYHI<span class="hljs-keyword">sw </span><span class="hljs-built_in">k0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k1</span>)<span class="hljs-keyword">mfc0 </span><span class="hljs-built_in">k0</span>, CP0_BADVADDRla <span class="hljs-built_in">k1</span>, temp_BADVADDR<span class="hljs-keyword">sw </span><span class="hljs-built_in">k0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k1</span>)<span class="hljs-comment"># 取得CP0_CONTEXT的值</span><span class="hljs-keyword">mfc0 </span><span class="hljs-built_in">k1</span>, CP0_CONTEXT<span class="hljs-comment"># 可能会发生异常重入，重入后进入通用处理函数</span><span class="hljs-keyword">lw </span><span class="hljs-built_in">k1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k1</span>) <span class="hljs-keyword">nop</span><span class="hljs-keyword"></span><span class="hljs-comment"># 将我们获取和保存的CP0_ENTRYLO0和CP0_ENTRYHI值填入寄存器,</span>la <span class="hljs-built_in">k0</span>, temp_ENTRYHI<span class="hljs-keyword">lw </span><span class="hljs-built_in">k0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k0</span>)<span class="hljs-keyword">mtc0 </span><span class="hljs-built_in">k1</span>, CP0_ENTRYLO0<span class="hljs-keyword">mtc0 </span><span class="hljs-built_in">k0</span>, CP0_ENTRYHI<span class="hljs-comment"># 检查PTE是否有效</span><span class="hljs-keyword">andi </span><span class="hljs-built_in">k1</span>, <span class="hljs-built_in">k1</span>, PTE_V<span class="hljs-comment"># 若PTE无效，跳转至default_tlb_refill</span><span class="hljs-keyword">beqz </span><span class="hljs-built_in">k1</span>, default_tlb_refill <span class="hljs-keyword">nop</span><span class="hljs-keyword"></span><span class="hljs-comment"># 恢复CP0_EPC的值</span>la <span class="hljs-built_in">k1</span>, temp_EPC<span class="hljs-keyword">lw </span><span class="hljs-built_in">k1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k1</span>)<span class="hljs-keyword">nop</span><span class="hljs-keyword"></span><span class="hljs-comment"># TLB重填</span><span class="hljs-keyword">tlbwr</span><span class="hljs-keyword"></span><span class="hljs-keyword">nop</span><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span><span class="hljs-built_in">k1</span>rfe<span class="hljs-symbol"></span><span class="hljs-symbol">default_tlb_refill:</span><span class="hljs-comment"># 因为可能在之前发生了异常重入，导致BADVADDR和EPC的值发生变化，因此必须在这里手动填充</span>la <span class="hljs-built_in">k0</span>, temp_BADVADDRla <span class="hljs-built_in">k1</span>, temp_EPC<span class="hljs-keyword">lw </span><span class="hljs-built_in">k0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k0</span>)<span class="hljs-keyword">lw </span><span class="hljs-built_in">k1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">k1</span>)<span class="hljs-keyword">mtc0 </span><span class="hljs-built_in">k0</span>, CP0_BADVADDR <span class="hljs-comment">#恢复寄存器的值，下同</span><span class="hljs-keyword">mtc0 </span><span class="hljs-built_in">k1</span>, CP0_EPC<span class="hljs-comment"># 填好寄存器的值后跳转到通用处理</span><span class="hljs-keyword">j </span>exc_gen_entry<span class="hljs-keyword">nop</span><span class="hljs-keyword"></span><span class="hljs-meta">.set</span> <span class="hljs-built_in">at</span><span class="hljs-meta">.set</span> reorder</code></pre></div><p>这里需要注意的就是两次异常处理：<br>首先，访问Kseg2区域会经过TLB，因此可能会发生异常重入现象：<br>我们访问页面的逻辑是这样的：<br>欲访问一个页面-&gt;查找TLB-&gt;TLB Miss进入快充填程序-&gt;查找位于KSEG2的页表-&gt;查找TLB<br>如果在最后一个TLB处发生了缺页，那么也就是在异常处理的过程中再次发生异常，也就是这里所说的异常重入现象。<br>MIPS R3000的机制是在此处（KESG2）发生TLB MISS是不会进入我们的快重填程序的，而是直接进入通用异常处理程序。我们必须要对这个机制有所了解，<strong>因为二次异常的发生会破坏第一次异常寄存器所保存的现场</strong>。</p><p>第二就是如果发生PTE无效的情况，我们需要有所处理。<br>这里由于笔者时间有限等综合因素，其实没有什么很好的处理方法，故选择直接跳转至原本的通用异常处理程序进行处理。<br>由于局部性原理，这种情况发生的概率总体来看较小，故这是可以接受的。</p><p>第三我们要记得在进程销毁时无效化旧的TLB表项。</p><p>我们将页表项映射至KSEG2后，还需要在<strong>合适的时间对其无效化</strong>，如果不进行这个工作的话，<strong>可能在多进程的情况下出错。</strong></p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20240407201337033.png" alt="image-20240407201337033" style="zoom:50%;" /><h2 id="小结">小结</h2><p>到这里TLB快重填的实现部分就结束了，从代码量来看较为简单，但是考虑到资料较少，要写汇编代码，要对MOS和MIPS R3000的各种机制有深刻了解，debug困难等因素，其实难度并不低。<br>还剩一个部分，即编写一个测试程序进行测试，这部分我留在下文的测试程序部分进行说明。</p><h1>测试程序</h1><p>要求为实现一个测试程序体现重填加速效果，测试程序本身及运行测试程序得到的运行结果应具有足够的可读性。<br>其实想要测试快重填的加速效果非常简单，因为用户进程运行的过程实质上不断地在进行TLB重填，故对任何用户程序都有一定的加速效果。<br>但是为了体现出直观的差异，我们需要简单地对测试程序进行设计。<br>我们知道一个物理页框的大小是4KB，如果用于存放int数组可以容纳的长度为1024，而TLB可以容纳的表项数为32个表项，所以我们可以创建一个长度为64个页框大小的数组并循环依次访问每一个页框。<br>这样可以最大化TLB MISS的次数，使得优化过后的程序体现出速度上的明显优势。</p><p>程序：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;lib.h&gt;</span></span><span class="hljs-type">int</span> temp[<span class="hljs-number">65536</span>];<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;u_int s1, us1;s1 = get_time(&amp;us1);debugf(<span class="hljs-string">&quot;测试程序开始运行...\n&quot;</span>);debugf(<span class="hljs-string">&quot;请耐心等待\n&quot;</span>);<span class="hljs-comment">//循环访问500000次</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">500000</span> ; i++)&#123;<span class="hljs-comment">//依次访问每一个页框</span><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j &lt; <span class="hljs-number">65536</span>; j+=<span class="hljs-number">1024</span>)&#123;temp[j] = j;&#125;&#125;u_int s2, us2;s2 = get_time(&amp;us2);debugf(<span class="hljs-string">&quot;测试程序运行结束! :)\n&quot;</span>);debugf(<span class="hljs-string">&quot;总耗时约 %d 秒\n&quot;</span>, s2-s1); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>注：这里因为时间的数量级为十秒，我忽略了毫秒带来的小于1秒的差距。</p><p>使用快重填的实验结果：<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230616225058.png" alt="image.png"></p><p>不使用快重填的实验结果：<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230616225303.png" alt="image.png"></p><p>对比发现，在测试程序上，快重填的速度大约为原方法的4.5倍，取得了较好的效果😊</p><h1>实现过程中遇到的问题及相应的解决方案</h1><p>我认为本实验任务和其他任务的一个明显特点就是其他实验都是写C语言代码，但是这个实验需要写汇编代码。<br>LAB2的挑战性任务从代码量来看较为简单，但是考虑到资料较少，要写汇编代码，要对MOS和MIPS R3000的各种机制有深刻了解，debug困难等因素，其实难度并不低。<br>下面我罗列一下我遇到的主要问题和解决方案。</p><h2 id="怎么将页表映射到KSEG2上">怎么将页表映射到KSEG2上</h2><p>这里其实非常考验对于页表映射的理解，需要对我们是怎样建立页表从物理空间到内核空间，再到用户空间的映射有一个全面的把握，过程非常复杂。<br>但是其实我们也可以化繁为简，抓住主要因素。<br>我们要重点理解<code>env_setup_vm</code>函数中的这行代码：</p><div class="code-wrapper"><pre><code class="hljs c">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;</code></pre></div><p>其实当时的思考题也让我们去重点理解了，但是现在看来我对它的理解还是略显不足，<br>通过去梳理和理解这个过程，就可以知道其实映射很简单，就是再添加下列代码即可。</p><div class="code-wrapper"><pre><code class="hljs c">p-&gt;pp_ref++;e-&gt;env_pgdir[PDX(KSEG2)] = PADDR(e-&gt;env_pgdir) | PTE_V;</code></pre></div><h2 id="怎么理解TLB-Miss的处理过程">怎么理解TLB Miss的处理过程</h2><p>TLB miss 异常与其他异常不同，在访问用户空间 <code>kuseg</code> 地址，触发 TLB miss 异常时，CPU 的 PC 不会跳转到通用的异常处理程序入口，而是跳转到专用的处理程序入口。在我们的 MOS 中，通用异常入口位于 <code>0x80000080</code>，TLB miss 异常专用入口位于 <code>0x80000000</code>。目前的 MOS 没有实现 TLB miss 的专用快速重填程序，而是在此处直接跳转至通用异常入口进行处理。</p><p>所以实现TLB的快重填实际上是要求我们完成<code>0x80000000</code>处的这个处理函数。</p><p>（这里也要注意，访问 <code>kseg2</code>地址时不会进入<code>0x80000000</code> ，而是直接进入<code>0x80000080</code>， 这一点也卡了我很久。）</p><p>如果我们不知道原本的TLB Miss是如何处理的，那么就很难去理解实验到底要求我们去做什么。所以在此之前我们先来学习一下通用的异常处理流程。</p><h3 id="通用异常处理流程">通用异常处理流程</h3><p>首先，在<code>kernel.lds</code>中增加如下代码, 为操作系统增加异常分发功能:</p><div class="code-wrapper"><pre><code class="hljs c">. = <span class="hljs-number">0x80000000</span>;.tlb_miss_entry : &#123;*(.text.tlb_miss_entry)&#125;. = <span class="hljs-number">0x80000080</span>;.exc_gen_entry : &#123;*(.text.exc_gen_entry)&#125;</code></pre></div><p>这里不需要进行任何改动.</p><p>经过这里的声明, 系统在发生异常的时候就知道该去访问哪里来解决异常, 接下来我们在<code>entry.S</code>文件中完成我们两个异常处理函数</p><div class="code-wrapper"><pre><code class="hljs c">.section .text.tlb_miss_entrytlb_miss_entry:j       exc_gen_entry.section .text.exc_gen_entryexc_gen_entry:SAVE_ALLmfc0 t0, CP0_CAUSEandi t0, <span class="hljs-number">0x7c</span>lw t0, exception_handlers(t0)jr t0</code></pre></div><p>可以看到, 在原本的MOS中, TLB Miss后虽然会交给<code>tlb_miss_entry</code>处理, 但是实际上<code>tlb_miss_entry</code>又会紧接着转交给<code>exc_gen_entry</code>这一通用处理程序.</p><ol><li>首先，指令SAVE_ALL被执行。这是一个宏指令，它将所有通用寄存器保存在栈上，以便在处理异常时能够恢复它们的值。</li><li>接下来，mfc0指令用于将CP0_CAUSE寄存器的内容加载到t0寄存器中。CP0_CAUSE寄存器包含了异常的原因码以及其他相关的标志位。</li><li>最后, 通过异常码跳转到对应的处理程序中, 开始异常处理, 这里借用了<code>exception_handlers</code>函数, 该函数在<code>traps.c</code>文件中声明:</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> (*exception_handlers[<span class="hljs-number">32</span>])(<span class="hljs-type">void</span>) = &#123;    [<span class="hljs-number">0</span> ... <span class="hljs-number">31</span>] = handle_reserved,    [<span class="hljs-number">0</span>] = handle_int,    [<span class="hljs-number">2</span> ... <span class="hljs-number">3</span>] = handle_tlb,&#125;;</code></pre></div><p>这里我们学习一下通用寄存器的TLB Miss的异常处理方法<code>handle_int</code>, 来启发我们如何编写我们自己的快速重填函数.<br>值得注意的是, <code>CP0_CAUSE</code>又将TLB Miss分为了2, 3两个异常码(load和store), 但是MOS中用了一个统一的处理函数进行处理.</p><p><code>handle_int</code>是在<code>genex.S</code>文件中进行定义的:</p><div class="code-wrapper"><pre><code class="hljs mipsasm">NESTED(handle_tlb, TF_SIZE + <span class="hljs-number">8</span>, <span class="hljs-built_in">zero</span>)<span class="hljs-keyword">move </span>   <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">sp</span><span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, -<span class="hljs-number">8</span><span class="hljs-keyword">jal </span>    do_tlb_refill<span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, <span class="hljs-number">8</span><span class="hljs-keyword">j </span>      ret_from_exceptionEND(handle_tlb)</code></pre></div><ol><li>首先, <code>move</code>指令将当前栈指针（sp）的值复制到寄存器a0中, 以便作为参数传递给<code>do_tlb_refill</code>.</li><li>然后，<code>addiu</code>指令将栈指针向下调整8个字节，为<code>do_tlb_refill</code>函数的局部变量或其他需要的数据腾出空间。</li><li>接着，<code>jal</code>指令调用<code>do_tlb_refill</code>函数。<code>jal</code>指令会将当前指令的地址（返回地址）保存到链接寄存器（$ra）中，并跳转到目标函数的地址。</li><li>在<code>do_tlb_refill</code>函数执行完毕后，<code>addiu</code>指令将栈指针恢复回原来的位置，以释放先前分配的局部变量的空间。</li><li>最后，<code>j</code>指令跳转到<code>ret_from_exception</code>，这是一个通用的异常返回例程，用于从异常处理中返回到正常的执行流程中。</li></ol><p>这里涉及到<code>do_tlb_refill</code>和<code>ret_from_exception</code>两个值得研究的函数, 我们先看看<code>ret_from_exception</code>有何作用:</p><div class="code-wrapper"><pre><code class="hljs mipsasm">FEXPORT(ret_from_exception)RESTORE_SOME<span class="hljs-keyword">lw </span>     <span class="hljs-built_in">k0</span>, TF_EPC(<span class="hljs-built_in">sp</span>)<span class="hljs-keyword">lw </span>     <span class="hljs-built_in">sp</span>, TF_REG29(<span class="hljs-built_in">sp</span>) <span class="hljs-comment">/* Deallocate stack */</span><span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><span class="hljs-keyword"></span><span class="hljs-keyword">jr </span>     <span class="hljs-built_in">k0</span>rfe<span class="hljs-meta">.set</span> reorder</code></pre></div><ol><li>首先函数执行了<code>RESTORE_SOME</code>指令, 这和之前进入异常通用处理程序执行的<code>SAVE ALL</code>一样是宏指令, 在<code>stackframe.h</code>函数中被提前定义。这两个宏函数是用于在异常处理过程中保存和恢复寄存器状态的工具。这两个宏函数一起工作，用于在异常处理过程中保存寄存器状态，并在异常处理结束后恢复寄存器状态。这样可以确保异常处理完成后，程序能够正确地恢复到异常发生之前的状态，并继续执行。</li><li>然后，lw指令从栈中加载<code>TF_EPC(sp)</code>的值到k0寄存器中。<code>TF_EPC</code>是异常发生时保存的EPC（Exception Program Counter）寄存器的偏移量，用于存储引发异常的指令地址。</li><li>紧接着，lw指令从栈中加载<code>TF_REG29(sp)</code>的值到sp寄存器中。<code>TF_REG29</code>是异常发生时保存的栈指针的偏移量，通过加载它的值到sp寄存器，可以恢复之前的栈指针状态。</li><li>然后，<code>jr</code>指令将跳转到k0寄存器中存储的地址，也就是之前保存的EPC值。这样，程序将继续执行引发异常的指令之后的代码。</li><li>最后，<code>rfe</code>指令用于从异常处理中返回，并恢复处理器的状态。</li></ol><p>可以看到, 其实<code>ret_from_exception</code>做的是一个异常处理后恢复现场的工作, 而主要的异常处理的过程是在<code>do_tlb_mod</code>中完成的</p><p>现在我们来看看<code>do_tlb_refill</code>的内容:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-class">.data</span>tlb_refill_ra:<span class="hljs-selector-class">.word</span> <span class="hljs-number">0</span><span class="hljs-selector-class">.text</span><span class="hljs-function"><span class="hljs-title">NESTED</span><span class="hljs-params">(do_tlb_refill, <span class="hljs-number">0</span>, zero)</span></span>mfc0    a0, CP0_BADVADDRmfc0    a1, CP0_ENTRYHIsrl     a1, a1, <span class="hljs-number">6</span>andi    a1, a1, <span class="hljs-number">0</span>b111111sw      ra, tlb_refill_rajal     _do_tlb_refilllw      ra, tlb_refill_ramtc0    v0, CP0_ENTRYLO0<span class="hljs-comment">// See &lt;IDT R30xx Family Software Reference Manual&gt; Chapter 6-8</span>nop<span class="hljs-comment">/* Hint: use &#x27;tlbwr&#x27; to write CP0.EntryHi/Lo into a random tlb entry. */</span><span class="hljs-comment">/* Exercise 2.10: Your code here. */</span>tlbwrjr      ra<span class="hljs-function"><span class="hljs-title">END</span><span class="hljs-params">(do_tlb_refill)</span></span></code></pre></div><p><code>do_tlb_refill</code>函数的主要作用是传参并调用了<code>_do_tlb_refill</code>函数，真正的处理在<code>_do_tlb_refill</code>函数中进行。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Overview:</span><span class="hljs-comment"> *  Refill TLB.</span><span class="hljs-comment"> */</span>Pte _do_tlb_refill(u_long va, u_int asid) &#123;Pte *pte;<span class="hljs-keyword">while</span>(page_lookup(cur_pgdir, va, &amp;pte)==<span class="hljs-literal">NULL</span>)&#123;passive_alloc(va, cur_pgdir, asid);&#125;<span class="hljs-keyword">return</span> *pte;&#125;</code></pre></div><p>这是真正处理缺页的函数, 可以看到逻辑很简单:</p><ol><li>使用<code>page_lookup(cur_pgdir, va, &amp;pte)</code>函数去查找当前进程的页表,<ol><li>如果存在, 说明已经为这个虚拟页分配了物理页框,进入下一步</li><li>如果不存在, 那么使用<code>passive_alloc(va, cur_pgdir, asid)</code>为这页分配一个页框, 并更改页表</li></ol></li><li>返回对应的页表项</li></ol><h3 id="在此基础上建立快重填">在此基础上建立快重填</h3><p>如果理解了通用处理和快重填的关系，就知道其实我们不是要去重写通用处理，而是相当于去利用CONTEXT寄存器快速完成<code>page_lookup</code>的过程，同时也不需要那么保存那么多寄存器，省去了很多时间和工作。</p><h2 id="汇编程序编写的细节问题">汇编程序编写的细节问题</h2><p>这部分真是让人非常头疼，我下面列举一些问题，这些问题都可以通过查阅资料，反复尝试和手动调试解决，但是问题多，细节多，而且发生错误后很难定位问题，故让人非常困扰，当然也有笔者是软件学院学生，对汇编理解不够深刻的原因。</p><ul><li>nop问题：汇编程序编写过程中很多时候需要手动添加nop。什么时候添加？</li><li>寄存器问题：每个寄存器应该在何时被保存和恢复，又该如何保存和恢复哪些寄存器？</li><li>汇编函数调用问题：汇编函数之间的调用涉及到栈和sp的问题</li><li>值的保存和传递问题：有些值需要被保存和传递，我该怎样实现？</li><li>指令条数问题：笔者在实现快重填时发生了因为<code>tlb_miss_entry</code>太长和<code>exc_gen_entry</code>发生重叠的问题，怎么解决？</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab5_文件系统</title>
    <link href="/2023/05/22/OS-lab5-Summary/"/>
    <url>/2023/05/22/OS-lab5-Summary/</url>
    
    <content type="html"><![CDATA[<h1>文件系统概述</h1><p>广义上，一切带标识的、在逻辑上有完整意义的字节序列都可以称为“文件”。文件系统将外部设备中的资源抽象为文件，从而可以统一管理外部设备，实现对数据的存储、组织、访问和修改等操作。在本实验中，我们拟实现一个精简的文件系统，其中需要对<strong>三种设备</strong>进行统一管理， 即文件设备（file，即狭义的“文件”）、控制台（console）和管道（pipe）。其中，后两者将在下一个实验“管道与 Shell”中进行使用。</p><p>下图为我们文件系统的总览：<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230515141829.png" alt="image.png"></p><p>还有一张图很好的展示了不同层级的抽象函数调用关系。</p><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230522152337.png" alt="image.png"></p><h1>外部存储设备驱动</h1><p>通常，我们需要按一定顺序读写设备寄存器，来实现对外部设备的操作。为了将这种操作转化为具有通用、明确语义的接口，必须实现相应的驱动程序。在本部分，我们将实现 IDE 磁盘的用户态驱动程序，该驱动程序将通过系统调用的方式陷入内核，对磁盘镜像进行读写操作。<br>MOS已经在<code>kern/console.c</code>中使用MMIO技术为我们实现了简单的console驱动程序, 我们的实验里需要我们实现IDE 磁盘驱动，也就是下图的部分：<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230515141939.png" alt="image.png"></p><p>相比于console驱动程序, IDE的驱动程序更加复杂, 并且本次要编写的驱动程序完全运行在用户空间。</p><h2 id="内存映射-I-O-MMIO">内存映射 I/O (MMIO)</h2><p>几乎每一种 外设都是通过读写设备上的寄存器来进行数据通信，外设寄存器也称为 I/O 端口，主要用来访问 I/O 设备。外设寄存器通常包括控制寄存器、状态寄存器和数据寄存器，这些寄存器被映射到<strong>指定的物理地址空间</strong>。</p><p>IDE 磁盘驱动程序位于用户空间，用户态进程若是直接 读写内核虚拟地址将会由处理器引发一个地址错误（ADEL/S）。所以对于设备的读写必须通过 系统调用来实现。<br>因此我们引入<code>sys_write_dev</code> 和 <code>sys_read_dev</code> 两个系统调用:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//这里使用定义的宏也许会更好? </span><span class="hljs-comment">//但是因为没有引用头文件并不能使用...</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">is_illegal_pa_range</span><span class="hljs-params">(u_int pa, u_int len)</span> &#123;<span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(pa &gt;= <span class="hljs-number">0x10000000</span> &amp;&amp; pa + len &lt;= <span class="hljs-number">0x10000000</span> + <span class="hljs-number">0x20</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(pa &gt;= <span class="hljs-number">0x13000000</span> &amp;&amp; pa + len &lt;= <span class="hljs-number">0x13000000</span> + <span class="hljs-number">0x4200</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(pa &gt;= <span class="hljs-number">0x15000000</span> &amp;&amp; pa + len &lt;= <span class="hljs-number">0x15000000</span> + <span class="hljs-number">0x200</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">sys_write_dev</span><span class="hljs-params">(u_int va, u_int pa, u_int len)</span> &#123;<span class="hljs-comment">/* Exercise 5.1: Your code here. (1/2) */</span><span class="hljs-keyword">if</span>(is_illegal_va_range(va, len))<span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span>(is_illegal_pa_range(pa, len))<span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-comment">//注意地址转换</span><span class="hljs-built_in">memcpy</span>(pa+KSEG1, va, len);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">sys_read_dev</span><span class="hljs-params">(u_int va, u_int pa, u_int len)</span> &#123;<span class="hljs-comment">/* Exercise 5.1: Your code here. (2/2) */</span><span class="hljs-keyword">if</span>(is_illegal_va_range(va, len))<span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-keyword">if</span>(is_illegal_pa_range(pa, len))<span class="hljs-keyword">return</span> -E_INVAL;<span class="hljs-comment">//注意地址转换</span><span class="hljs-built_in">memcpy</span>(va, pa+KSEG1, len);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>通过这两个系统调用，我们就可以对IDE磁盘映射到内核空间的I/O寄存器进行读写了。</p><h2 id="IDE磁盘">IDE磁盘</h2><blockquote><p>下面简单介绍与磁盘相关的基本知识，首先是几个基本概念：</p><ol><li>扇区 (sector): 磁盘盘片被划分成很多扇形的区域，这些区域叫做扇区。<strong>扇区是磁盘执行读写操作的单位</strong>，一般是 <strong>512 字节</strong>。扇区的大小是一个磁盘的硬件属性。</li><li>磁道 (track): 盘片上以盘片中心为圆心，不同半径的同心圆。</li><li>柱面 (cylinder): 硬盘中，不同盘片相同半径的磁道所组成的圆柱面。</li><li>磁头 (head): 每个磁盘有两个面，每个面都有一个磁头。当对磁盘进行读写操作时，磁头在盘片上快速移动。</li></ol></blockquote><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230515144052.png" alt="image.png"><br>接下来我们看看IDE内核的I/O寄存器映射:<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230515144340.png" alt="image.png"><br>通过系统调用<code>sys_write_dev</code> 和 <code>sys_read_dev</code>,我们可以读写寄存器的值,从而实现对IDE磁盘的读写。</p><h1>文件系统结构</h1><h2 id="磁盘空间的基本布局">磁盘空间的基本布局</h2><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230519145425.png" alt="image.png"><br>不同于扇区，磁盘块是一个<strong>虚拟概念</strong>，是操作系统与磁盘交互的最小单位；操作系统将相邻的扇区组合在一起，形成磁盘块进行整体操作。<br>磁盘块的大小由操作系统决定，一般由 2 的 n 次方个扇区构成。</p><p>MOS 操作系统把磁盘最开始的一个磁盘块 (4096 字节) 当作<strong>引导扇区和分区表</strong>使用。接下来的一个磁盘块作为<strong>超级块 (Super Block)</strong>，用来描述文件系统的基本信息。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Super</span> </span><span class="hljs-class">&#123;</span> u_int s_magic; <span class="hljs-comment">// Magic number: FS_MAGIC </span>u_int s_nblocks; <span class="hljs-comment">// Total number of blocks on disk</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">s_root</span>;</span> <span class="hljs-comment">// Root directory node </span>&#125;;</code></pre></div><h2 id="磁盘资源管理">磁盘资源管理</h2><p>在文件系统中，我们使用<strong>位图 (Bitmap) 法</strong>来管理空闲的磁盘资源，用一个二进制位 bit 标识磁盘中的一个磁盘块的使用情况（1 表示空闲，0 表示占用）。<br>首先来梳理一下定义:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//disk-&gt;以磁盘块为单位</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> &#123;</span>    <span class="hljs-type">uint8_t</span> data[BY2BLK];    <span class="hljs-type">uint32_t</span> type;&#125; disk[NBLOCK];<span class="hljs-comment">//需要多少block来装位图(天花板除)</span>nbitblock = (NBLOCK + BIT2BLK - <span class="hljs-number">1</span>) / BIT2BLK;<span class="hljs-comment">//初始化时,标记为空闲</span><span class="hljs-built_in">memset</span>(disk[<span class="hljs-number">2</span> + i].data, <span class="hljs-number">0xff</span>, BY2BLK);<span class="hljs-comment">//但是如果最后有一些多余的bit,全部标记为占用</span><span class="hljs-built_in">memset</span>(disk[<span class="hljs-number">2</span> + (nbitblock - <span class="hljs-number">1</span>)].data + diff, <span class="hljs-number">0x00</span>, BY2BLK - diff);</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//bitmap-&gt;将磁盘中的位图读入文件系统(通过read_bitmap)</span><span class="hljs-comment">//bitmap数组的一个成员可以存放32位</span><span class="hljs-type">uint32_t</span> *bitmap;<span class="hljs-comment">//Mark a block as free in the bitmap</span>bitmap[blockno / <span class="hljs-number">32</span>] |= (<span class="hljs-number">1</span> &lt;&lt; (blockno % <span class="hljs-number">32</span>));</code></pre></div><h2 id="文件的描述和管理">文件的描述和管理</h2><p>操作系统要想管理一类资源，就得有相应的数据结构。对于描述和管理文件来说，一般使用 文件控制块（File 结构体）。<br>此处需要注意, 不论是f_direct数组的内容, 还是f_indirect, 都是uint32_t, 即这不是传统意义上的指针, 而是指disk数组使用的bno.</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//size为256B</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span>    <span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span>    <span class="hljs-type">uint32_t</span> f_size;     <span class="hljs-comment">// file size in bytes</span>    <span class="hljs-type">uint32_t</span> f_type;     <span class="hljs-comment">// file type</span>    <span class="hljs-type">uint32_t</span> f_direct[NDIRECT];    <span class="hljs-type">uint32_t</span> f_indirect;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory.</span>    <span class="hljs-type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed));</code></pre></div><h2 id="块缓存">块缓存</h2><p>我理解的块缓存: 因为文件进程的需要, 我们希望能使用虚拟地址直接实现对磁盘的读写, 但是实际上我们只能调用磁盘驱动非常复杂地进行操作.<br>解决办法就是将磁盘直接全部映射到文件服务进程虚拟空间的某处, 如果读取就可以直接读取, 如果发生了修改就将缓存写回磁盘, 从而提高了效率.</p><h1>梳理调用关系</h1><h2 id="ide磁盘">ide磁盘</h2><p>ide磁盘中的寄存器会映射在内核空间中, 允许我们在此基础上建立驱动读写ide.</p><h2 id="内核">内核</h2><p>内核通过接受来自驱动程序的<code>sys_read_dev</code>和<code>sys_write_dev</code>来读写寄存器</p><h2 id="磁盘驱动–ide-c">磁盘驱动–ide.c</h2><p>在驱动层次, 我们封装了<code>ide_write</code>和<code>ide_read</code>来读写磁盘, 驱动属于文件进程的一部分, 为文件提供操作磁盘的方法.</p><h2 id="文件系统底层部分–fs-c">文件系统底层部分–fs.c</h2><p>此时, 大多数操作是对进程的块缓存进行操作, 最后再调用驱动对磁盘修改.<br>下面是fs.c中提供的对缓存区的一些操作函数, 借助这些函数, 我们可以比较轻松地操作缓存区了,此时的操作主要以block为单位:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">diskaddr</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//查块对应的虚拟地址</span><span class="hljs-type">int</span> <span class="hljs-title function_">va_is_mapped</span><span class="hljs-params">(<span class="hljs-type">void</span> *va)</span><span class="hljs-type">void</span> *<span class="hljs-title function_">block_is_mapped</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//调用va_is_mapped</span><span class="hljs-type">int</span> <span class="hljs-title function_">va_is_dirty</span><span class="hljs-params">(<span class="hljs-type">void</span> *va)</span><span class="hljs-type">int</span> <span class="hljs-title function_">block_is_dirty</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//调用va_is_mapped和va_is_dirty</span><span class="hljs-comment">//为va对应的物理页加上PTE_DIRTY权限</span><span class="hljs-comment">//diskaddr, va_is_mapped, va_is_dirty, syscall_mem_map</span><span class="hljs-type">int</span> <span class="hljs-title function_">dirty_block</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//将缓存内容写入对应的磁盘块</span><span class="hljs-comment">//block_is_mapped, diskaddr, ide_write</span><span class="hljs-type">void</span> <span class="hljs-title function_">write_block</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//将磁盘块写入缓存区,将缓存的va保存在blk中返回</span><span class="hljs-type">int</span> <span class="hljs-title function_">read_block</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> **blk, u_int *isnew)</span><span class="hljs-comment">//为block申请一个物理页</span><span class="hljs-type">int</span> <span class="hljs-title function_">map_block</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//Unmap a disk block in cache(会将缓存写回)</span><span class="hljs-type">void</span> <span class="hljs-title function_">unmap_block</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//查询bitmap中block是否空闲(不涉及缓存)</span><span class="hljs-type">int</span> <span class="hljs-title function_">block_is_free</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//修改bitmap, 标记某个block为free(没有清空内容)</span><span class="hljs-type">void</span> <span class="hljs-title function_">free_block</span><span class="hljs-params">(u_int blockno)</span><span class="hljs-comment">//Search in the bitmap for a free block and allocate it.(同时会修改bitmap)</span><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_block_num</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//Allocate a block -- first find a free block in the bitmap, then map it into memory.</span><span class="hljs-comment">//调用alloc_block_num,map_block,free_block</span><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_block</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//  Initialize the file system.</span><span class="hljs-type">void</span> <span class="hljs-title function_">fs_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;    read_super();    check_write_block();    read_bitmap();&#125;</code></pre></div><p>接下来是一些更上一级的函数,这些函数的特点是以file为单位:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//找到某文件的第filebno个块在整个磁盘的bno的指针*ppdiskbno, 如果alloc=1, 那么会在没有indirect块的时候帮忙建立</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_block_walk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno, <span class="hljs-type">uint32_t</span> **ppdiskbno, u_int alloc)</span><span class="hljs-comment">//将diskbno的值设置为某文件的第filebno个块在整个磁盘的bno</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_map_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span><span class="hljs-comment">//删掉文件的第filebno个块</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_clear_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno)</span><span class="hljs-comment">//得到文件的第filebno个块的va</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_get_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno, <span class="hljs-type">void</span> **blk)</span><span class="hljs-comment">//Mark the offset/BY2BLK&#x27;th block dirty in file f.</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_dirty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int offset)</span><span class="hljs-comment">//Find a file named &#x27;name&#x27; in the directory &#x27;dir&#x27;. If found, set *file to it.</span><span class="hljs-type">int</span> <span class="hljs-title function_">dir_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dir, <span class="hljs-type">char</span> *name, <span class="hljs-keyword">struct</span> File **file)</span><span class="hljs-comment">//在dir下申请一个新的File,并借助file返回</span><span class="hljs-type">int</span> <span class="hljs-title function_">dir_alloc_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dir, <span class="hljs-keyword">struct</span> File **file)</span><span class="hljs-comment">//用path找到对应的File结构体,用pfile返回</span><span class="hljs-type">int</span> <span class="hljs-title function_">walk_path</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> File **pdir, <span class="hljs-keyword">struct</span> File **pfile, <span class="hljs-type">char</span> *lastelem)</span></code></pre></div><p>在此基础上, 还有几个最能代表这一层次的函数:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//用path找到对应的File结构体,用file返回</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_open</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> File **file)</span><span class="hljs-comment">//使用path创建文件</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_create</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> File **file)</span><span class="hljs-comment">//文件大小发生变化后, 释放不需要的磁盘块(如果更大则不做处理)</span><span class="hljs-type">void</span> <span class="hljs-title function_">file_truncate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int newsize)</span><span class="hljs-comment">//将file的缓存写入磁盘</span><span class="hljs-type">void</span> <span class="hljs-title function_">file_flush</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f)</span><span class="hljs-comment">//设置文件的大小</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_set_size</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int newsize)</span><span class="hljs-comment">//将所有的缓存写入磁盘</span><span class="hljs-type">void</span> <span class="hljs-title function_">fs_sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//关闭文件: 将相关缓存写入</span><span class="hljs-type">void</span> <span class="hljs-title function_">file_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f)</span><span class="hljs-comment">//删除文件:名字清空/磁盘块全部释放</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_remove</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span></code></pre></div><h2 id="文件系统服务层–serv-c">文件系统服务层–serv.c</h2><p>这一层次的函数主要是对来自其他进程的ipc请求进行处理.<br>本层次有一个结构体, 用来记录一个打开的文件的基本信息.</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Open</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">o_file</span>;</span> <span class="hljs-comment">// mapped descriptor for open file</span>    u_int o_fileid;      <span class="hljs-comment">// file id</span>    <span class="hljs-type">int</span> o_mode;      <span class="hljs-comment">// open mode</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">o_ff</span>;</span> <span class="hljs-comment">// va of filefd page</span>&#125;;<span class="hljs-comment">// Max number of open files in the file system at once</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXOPEN 1024</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILEVA 0x60000000</span><span class="hljs-comment">// initialize to force into data section</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Open</span> <span class="hljs-title">opentab</span>[<span class="hljs-title">MAXOPEN</span>] =</span> &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-comment">// Virtual address at which to receive page mappings containing client requests.</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> REQVA 0x0ffff000</span></code></pre></div><p>接下来是一些函数:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//Initialize file system server process.</span><span class="hljs-comment">//值得注意的是每个Open结构体是在初始化的时候确定序号和FileFd的地址</span><span class="hljs-type">void</span> <span class="hljs-title function_">serve_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//Allocate an open file.</span><span class="hljs-comment">//o传递Open结构体,返回对应的o_fileid</span><span class="hljs-type">int</span> <span class="hljs-title function_">open_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Open **o)</span><span class="hljs-comment">//Look up an open file for envid.</span><span class="hljs-type">int</span> <span class="hljs-title function_">open_lookup</span><span class="hljs-params">(u_int envid, u_int fileid, <span class="hljs-keyword">struct</span> Open **po)</span></code></pre></div><p>实际提供服务的函数, 使用ipc_recv接受请求, 其中具体的请求处理都用ipc_send来进行回复.</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">serve</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;u_int req, whom, perm;<span class="hljs-keyword">for</span> (;;) &#123;perm = <span class="hljs-number">0</span>;req = ipc_recv(&amp;whom, (<span class="hljs-type">void</span> *)REQVA, &amp;perm);<span class="hljs-comment">// All requests must contain an argument page</span><span class="hljs-keyword">if</span> (!(perm &amp; PTE_V)) &#123;debugf(<span class="hljs-string">&quot;Invalid request from %08x: no argument page\n&quot;</span>, whom);<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// just leave it hanging, waiting for the next request.</span>&#125;<span class="hljs-keyword">switch</span> (req) &#123;<span class="hljs-keyword">case</span> FSREQ_OPEN:serve_open(whom, (<span class="hljs-keyword">struct</span> Fsreq_open *)REQVA);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FSREQ_MAP:serve_map(whom, (<span class="hljs-keyword">struct</span> Fsreq_map *)REQVA);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FSREQ_SET_SIZE:serve_set_size(whom, (<span class="hljs-keyword">struct</span> Fsreq_set_size *)REQVA);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FSREQ_CLOSE:serve_close(whom, (<span class="hljs-keyword">struct</span> Fsreq_close *)REQVA);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FSREQ_DIRTY:serve_dirty(whom, (<span class="hljs-keyword">struct</span> Fsreq_dirty *)REQVA);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FSREQ_REMOVE:serve_remove(whom, (<span class="hljs-keyword">struct</span> Fsreq_remove *)REQVA);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> FSREQ_SYNC:serve_sync(whom);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:debugf(<span class="hljs-string">&quot;Invalid request code %d from %08x\n&quot;</span>, whom, req);<span class="hljs-keyword">break</span>;&#125;syscall_mem_unmap(<span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *)REQVA);&#125;&#125;</code></pre></div><p>定义的请求结构体</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//保存在fsreq.h文件中</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_OPEN 1</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_MAP 2</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_SET_SIZE 3</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_CLOSE 4</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_DIRTY 5</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_REMOVE 6</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FSREQ_SYNC 7</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_open</span> &#123;</span><span class="hljs-type">char</span> req_path[MAXPATHLEN];u_int req_omode;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_map</span> &#123;</span><span class="hljs-type">int</span> req_fileid;u_int req_offset;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_set_size</span> &#123;</span><span class="hljs-type">int</span> req_fileid;u_int req_size;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_close</span> &#123;</span><span class="hljs-type">int</span> req_fileid;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_dirty</span> &#123;</span><span class="hljs-type">int</span> req_fileid;u_int req_offset;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_remove</span> &#123;</span><span class="hljs-type">char</span> req_path[MAXPATHLEN];&#125;;</code></pre></div><p>至此, 文件系统的部分就基本结束了, 文件系统使用<code>ipc_recv</code>来接受其他进程的请求.</p><h2 id="用户服务的提供者–fd-c">用户服务的提供者–fd.c</h2><p>在用户的视角看, 对文件的一切操作其实都是通过文件描述符fd实现的.<br>因此我们从高到低, 从fd.c来分析MOS是怎么为用户进程提供服务的:<br>首先是一些值得注意的定义:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment">内存空间中有专门的地址存放文件描述符，也就是FDTABLE，这里可以看成一个数组，每个Fd占一个Page大小，可以直接用fdnum作为下标获得；此外，文件的具体数据存在FILEBASE部分的内存空间，每个文件的数据最多占PDMAP大小，也可以实现fdnum到文件数据的一一映射（FILEBASE + PDMAP * fdnum）</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFD 32</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILEBASE 0x60000000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> FDTABLE (FILEBASE - PDMAP)</span><span class="hljs-comment">//MOS中有三种dev, file,console和pipe.</span><span class="hljs-comment">//不同的dev需要绑定有自己的5个基本方法, 以便进行操作</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dev</span> &#123;</span><span class="hljs-type">int</span> dev_id;<span class="hljs-type">char</span> *dev_name;<span class="hljs-type">int</span> (*dev_read)(<span class="hljs-keyword">struct</span> Fd *, <span class="hljs-type">void</span> *, u_int, u_int);<span class="hljs-type">int</span> (*dev_write)(<span class="hljs-keyword">struct</span> Fd *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, u_int, u_int);<span class="hljs-type">int</span> (*dev_close)(<span class="hljs-keyword">struct</span> Fd *);<span class="hljs-type">int</span> (*dev_stat)(<span class="hljs-keyword">struct</span> Fd *, <span class="hljs-keyword">struct</span> Stat *);<span class="hljs-type">int</span> (*dev_seek)(<span class="hljs-keyword">struct</span> Fd *, u_int);&#125;;<span class="hljs-comment">// file descriptor</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span>u_int fd_dev_id;u_int fd_offset;u_int fd_omode;&#125;;<span class="hljs-comment">// State不同的dev的相同部分,抽象出来称为Stat</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stat</span> &#123;</span><span class="hljs-type">char</span> st_name[MAXNAMELEN];u_int st_size;u_int st_isdir;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dev</span> *<span class="hljs-title">st_dev</span>;</span>&#125;;<span class="hljs-comment">// file descriptor + file</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span>u_int f_fileid;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span>&#125;;<span class="hljs-comment">//使用fd的id来找到对应的fd和数据</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></code></pre></div><p>下面是一些方法:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//Find the smallest i from 0 to MAXFD-1 that doesn&#x27;t have its fd page mapped</span><span class="hljs-comment">//申请fd,通过fd得到返回的fd</span><span class="hljs-type">int</span> <span class="hljs-title function_">fd_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd **fd)</span><span class="hljs-comment">//使用syscall_mem_unmap释放fd占用的页</span><span class="hljs-type">void</span> <span class="hljs-title function_">fd_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd)</span><span class="hljs-comment">//Find the &#x27;Fd&#x27; page for the given fd number.</span><span class="hljs-type">int</span> <span class="hljs-title function_">fd_lookup</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, <span class="hljs-keyword">struct</span> Fd **fd)</span><span class="hljs-comment">//一些id,data和结构体指针的转换</span><span class="hljs-type">void</span> *<span class="hljs-title function_">fd2data</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd)</span> &#123;<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)INDEX2DATA(fd2num(fd));&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">fd2num</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd)</span> &#123;<span class="hljs-keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG;&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">num2fd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> &#123;<span class="hljs-keyword">return</span> fd * BY2PG + FDTABLE;&#125;<span class="hljs-comment">//fd主要的操作都是通过fd的序号来做的,这也和实际一致.</span><span class="hljs-comment">//关闭fd</span><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum)</span><span class="hljs-type">void</span> <span class="hljs-title function_">close_all</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//应该是复制fd吧</span><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfdnum, <span class="hljs-type">int</span> newfdnum)</span><span class="hljs-comment">//Read at most &#x27;n&#x27; bytes from &#x27;fd&#x27; at the current seek position into &#x27;buf&#x27;.</span><span class="hljs-comment">//Return the number of bytes read successfully.</span><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, <span class="hljs-type">void</span> *buf, u_int n)</span><span class="hljs-comment">//不是很懂</span><span class="hljs-type">int</span> <span class="hljs-title function_">readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, <span class="hljs-type">void</span> *buf, u_int n)</span><span class="hljs-comment">//写</span><span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, u_int n)</span><span class="hljs-comment">//单纯偏移offset</span><span class="hljs-type">int</span> <span class="hljs-title function_">seek</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, u_int offset)</span><span class="hljs-comment">//应该是初始化相关的, 目前不太清楚</span><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, <span class="hljs-keyword">struct</span> Stat *stat)</span><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> Stat *stat)</span></code></pre></div><h2 id="用户空间的二级抽象–file-c">用户空间的二级抽象–file.c</h2><p>以上的fd.c我们都是对dev进行的操作, 但是具体到我们目前的文件系统, 我们实际上需要指定我们的dev是file</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//声明了devfile这个dev</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dev</span> <span class="hljs-title">devfile</span> =</span> &#123;    .dev_id = <span class="hljs-string">&#x27;f&#x27;</span>,    .dev_name = <span class="hljs-string">&quot;file&quot;</span>,    .dev_read = file_read,    .dev_write = file_write,    .dev_close = file_close,    .dev_stat = file_stat,&#125;;</code></pre></div><p>下面是file的方法:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// Open a file (or directory).</span><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> mode)</span><span class="hljs-comment">//  Close a file descriptor</span><span class="hljs-type">int</span> <span class="hljs-title function_">file_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd)</span><span class="hljs-comment">//  Read &#x27;n&#x27; bytes from &#x27;fd&#x27; at the current seek position into &#x27;buf&#x27;.</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">file_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd, <span class="hljs-type">void</span> *buf, u_int n, u_int offset)</span><span class="hljs-comment">//  Find the virtual address of the page that maps the file block starting at &#x27;offset&#x27;.</span><span class="hljs-type">int</span> <span class="hljs-title function_">read_map</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, u_int offset, <span class="hljs-type">void</span> **blk)</span><span class="hljs-comment">//  Write &#x27;n&#x27; bytes from &#x27;buf&#x27; to &#x27;fd&#x27; at the current seek position.</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">file_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, u_int n, u_int offset)</span><span class="hljs-comment">//将dev初始化为file</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">file_stat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Fd *fd, <span class="hljs-keyword">struct</span> Stat *st)</span><span class="hljs-comment">//  Truncate or extend an open file to &#x27;size&#x27; bytes</span><span class="hljs-type">int</span> <span class="hljs-title function_">ftruncate</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, u_int size)</span><span class="hljs-comment">//  Delete a file or directory.</span><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><span class="hljs-comment">//  Synchronize disk with buffer cache</span><span class="hljs-type">int</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></code></pre></div><h2 id="用户进程与文件管理进程的通讯–fsipc-c">用户进程与文件管理进程的通讯–fsipc.c</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//首先是定义的缓存区</span>u_char fsipcbuf[BY2PG] __attribute__((aligned(BY2PG)));<span class="hljs-comment">//Send an IPC request to the file server, and wait for a reply.</span><span class="hljs-comment">//这里的type实际上是上面文件系统需要接受的类型宏</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fsipc</span><span class="hljs-params">(u_int type, <span class="hljs-type">void</span> *fsreq, <span class="hljs-type">void</span> *dstva, u_int *perm)</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fsipc</span><span class="hljs-params">(u_int type, <span class="hljs-type">void</span> *fsreq, <span class="hljs-type">void</span> *dstva, u_int *perm)</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, u_int omode, <span class="hljs-keyword">struct</span> Fd *fd)</span>the server sends<span class="hljs-comment">// send us back a mapping(也就是va) for a page containing that block.</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_map</span><span class="hljs-params">(u_int fileid, u_int offset, <span class="hljs-type">void</span> *dstva)</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_set_size</span><span class="hljs-params">(u_int fileid, u_int size)</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_close</span><span class="hljs-params">(u_int fileid)</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_dirty</span><span class="hljs-params">(u_int fileid, u_int offset)</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></code></pre></div><p>至此, 这个关系算是捋清楚了!</p><h1>速记</h1><h2 id="设备映射的物理地址">设备映射的物理地址</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//console</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CONS_ADDRESS 0x10000000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CONS_LENGTH 0x00000020</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CONS_PUTGETCHAR 0x0000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_CONS_HALT 0x0010</span><span class="hljs-comment">//disk</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_ADDRESS 0x13000000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_OFFSET 0x0000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_OFFSET_HIGH32 0x0008</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_ID 0x0010</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_START_OPERATION 0x0020</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_STATUS 0x0030</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_BUFFER 0x4000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_BUFFER_LEN 0x200</span><span class="hljs-comment">/*  Operations:  */</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_OPERATION_READ 0</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_DISK_OPERATION_WRITE 1</span><span class="hljs-comment">//rtc</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_ADDRESS 0x15000000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_LENGTH 0x00000200</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_TRIGGER_READ 0x0000</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_SEC 0x0010</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_USEC 0x0020</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_HZ 0x0100</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEV_RTC_INTERRUPT_ACK 0x0110</span></code></pre></div><h2 id="几个结构体">几个结构体</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> &#123;</span>    <span class="hljs-type">uint8_t</span> data[BY2BLK];    <span class="hljs-type">uint32_t</span> type;&#125; disk[NBLOCK];</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span>    <span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span>    <span class="hljs-type">uint32_t</span> f_size;     <span class="hljs-comment">// file size in bytes</span>    <span class="hljs-type">uint32_t</span> f_type;     <span class="hljs-comment">// file type</span>    <span class="hljs-type">uint32_t</span> f_direct[NDIRECT];    <span class="hljs-type">uint32_t</span> f_indirect;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory.</span>    <span class="hljs-type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed));</code></pre></div><h1>Debug</h1><p>这次debug的时间比较短, 但是错的地方都挺隐蔽+脑残的…<br>总结几点:</p><h2 id="for循环">for循环</h2><p>首先要对自己写的代码有一个基础的理解: 为什么要用for循环<br>接着, for循环里面的变量是什么----老是忘记在for循环里面使用变量导致错误!</p><h2 id="根据测试寻找bug">根据测试寻找bug</h2><ol><li>总体理解测试的过程, 了解有哪些测试点</li><li>卡在哪个点, 就一层层梳理函数的调用关系, 看看能不能直接找到错误函数</li><li>如果找不到或者不知道错在哪, 通过改变测试函数(特别是结合测试点)来尝试理解错误的原因</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab4_系统调用和fork</title>
    <link href="/2023/05/08/OS-lab4-Summary/"/>
    <url>/2023/05/08/OS-lab4-Summary/</url>
    
    <content type="html"><![CDATA[<p>本次实验实现了用户态的系统调用, 进程间通信和fork.<br>这是在Lab3创建了一个用户进程之后, 对用户态功能的进一步完善.</p><h1>系统调用(syscall)</h1><p>在用户态下，用户进程不能访问系统的内核空间，也就是说它一般不能存取内核使用的内 存数据，也不能调用内核函数，这一点是由体系结构保证的。然而，用户进程在特定的场景下往 往需要执行一些只能由内核完成的操作，如操作硬件、动态分配内存，以及与其他进程进行通信 等。允许在内核态执行用户程序提供的代码显然是不安全的，因此操作系统设计了一系列内核空 间中的函数，当用户进程需要进行这些操作时，会引发特定的异常以陷入内核态，由内核调用对 应的函数，从而安全地为用户进程提供受限的系统级操作，我们把这种机制称为<strong>系统调用</strong>。<br>因此, 为了深入的理解系统调用的作用, 我们必须首先理解用户态和内核态的含义和区别.</p><h1>用户态和内核态</h1><h2 id="页与页表的问题">页与页表的问题</h2><p>首先我们从一个简单的问题讲起:</p><div class="code-wrapper"><pre><code class="hljs markdown">下列六项分别存放在内存的哪里?<span class="hljs-bullet">1.</span> p<span class="hljs-bullet">2.</span> page2pa(p)<span class="hljs-bullet">3.</span> page2kva(p)<span class="hljs-bullet">4.</span> 一级页表（页目录）的存放位置<span class="hljs-bullet">5.</span> 二级页表的存放位置<span class="hljs-bullet">6.</span> 页的存放位置</code></pre></div><p>回答此问题应该从虚拟地址和物理地址两方面考虑。实际上，访问这些对象需要分内核和用户两个角色，因为内核态访问某个地址一般是通过将物理地址高位置为1转化为kseg0虚拟地址来访问的，而用户态可访问的虚拟地址只有kuseg，需要经过二级页表转换来访问物理内存。</p><p>以下是内核态视图下，这些数据的存放位置：</p><ol><li><code>p</code>: 位于 <code>pages</code> 数组。<code>pages</code> 数组是在 <code>mips_vm_init</code> 中通过 <code>alloc</code> 函数动态分配的，所以其位置位于kseg0中紧邻 <code>KSTACKTOP</code> 的上方区域。</li><li><code>page2pa(p)</code>: 表示 <code>Page *</code> 指针 <code>p</code> 代表的<strong>物理地址</strong>，可以表示物理地址的任何区域，内核态访问时一般会将其转化为kseg0虚拟地址来访问。</li><li><code>page2kva(p)</code>: 表示 <code>Page *</code> 指针 <code>p</code> 代表的物理地址转化成的kseg0虚拟地址，可以位于kseg0内存区域的任何位置。</li><li>一级页表（页目录）的存放位置：一级页表是在 <code>pmap.c</code> 中通过 <code>page_alloc</code> 分配的页，其位于物理内存的<strong>之前的某个空闲位置</strong>，对应的kseg0虚拟地址位于 <code>KSTACKTOP</code>  的上方。</li><li>二级页表的存放位置：与一级页表相同，都是通过 <code>page_alloc</code> 分配的页，对应的kseg0虚拟地址都位于 <code>KSTACKTOP</code> 的上方。</li><li>页的存放位置：一般的页都是通过 <code>page_alloc</code> 分配的，对应的kseg0虚拟地址都位于 <code>KSTACKTOP</code> 的上方。</li></ol><p>以下是用户态视图下，这些数据的存放位置：</p><ol><li><code>p</code>：在 <code>env.c</code> 中，<code>pages</code> 数组被映射到kuseg虚拟地址的 <code>UPAGES</code> 区域。</li><li><code>page2pa(p)</code>：用户态无法随意访问物理地址。</li><li><code>page2kva(p)</code>: 用户态无法访问kseg0虚拟地址。</li><li>一级页表（页目录）的存放位置：页表被映射到了kuseg的 <code>UVPT</code> 区域。根据页目录的自映射原理，结合 <code>env_setup_vm(env.c)</code> 中的最后一句，可以得出页目录的位置在 <code>UVPT + (UVPT &gt;&gt; 10)</code>。</li><li>二级页表的存放位置：位于kuseg的 <code>UVPT</code> 区域，大小为4M。</li><li>页的存放位置：对于某个进程的kuseg虚拟内存，如果存在一个虚拟地址 <code>va</code> 能够映射到该页，那么该进程就可以通过 <code>va</code> 来访问这个物理页。否则不能访问。</li></ol><p>用户态有自己独立的地址空间(但是每个地址空间都共享一部分内核空间暴露出来的部分), 但是无法直接访问和操作内核态的大部分内容, 如果想要做这件事情, 就必须通过系统调用.</p><h1>Fork</h1><p>Fork整体的实现比较自然, 但是其中有一个地方比较难以理解, 下面仔细讲讲:</p><h2 id="页写入异常">页写入异常</h2><p>我们使用了写时复制（COW）特性，这种特性也是依赖于异常处理的。<br>当用户程序写入一个在 TLB 中被标记为不可写入（无 PTE_D）的页面时，MIPS 会陷入页写入异常（TLB Mod）， 我们在异常向量组中为其注册了一个处理函数 <code>handle_mod</code>，这一函数会跳转到 <code>kern/tlbex.c</code>中的<code>do_tlb_mod</code> 函数中，这个函数正是处理页写入异常的内核函数。对于需要写时复制（COW） 的页面，我们只需取消其 PTE_D 标记，即可在它们被写入时触发 <code>do_tlb_mod</code> 中的处理逻辑。</p><p>我们来分析一下<code>do_tlb_mod</code>的具体实现:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_tlb_mod</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span> &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">tmp_tf</span> =</span> *tf;<span class="hljs-comment">//如果此时在用户的栈空间之外, 那么将sp设置为用户异常栈栈顶</span><span class="hljs-keyword">if</span> (tf-&gt;regs[<span class="hljs-number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="hljs-number">29</span>] &gt;= UXSTACKTOP) &#123;tf-&gt;regs[<span class="hljs-number">29</span>] = UXSTACKTOP;&#125;<span class="hljs-comment">//sp减去一个tf的大小,相当于取这个tf之下的一个tf</span>tf-&gt;regs[<span class="hljs-number">29</span>] -= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe);<span class="hljs-comment">//将这个tf的值保存为我们传入的异常现场tf, 相当于把这个异常现场保存在了用户空间中</span>*(<span class="hljs-keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="hljs-number">29</span>] = tmp_tf;<span class="hljs-keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;<span class="hljs-comment">//将保存的现场传入异常处理函数</span>tf-&gt;regs[<span class="hljs-number">4</span>] = tf-&gt;regs[<span class="hljs-number">29</span>];<span class="hljs-comment">//再取前一个tf</span>tf-&gt;regs[<span class="hljs-number">29</span>] -= <span class="hljs-keyword">sizeof</span>(tf-&gt;regs[<span class="hljs-number">4</span>]);<span class="hljs-comment">// Hint: Set &#x27;cp0_epc&#x27; in the context &#x27;tf&#x27; to &#x27;curenv-&gt;env_user_tlb_mod_entry&#x27;.</span><span class="hljs-comment">/* Exercise 4.11: Your code here. */</span>tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;&#125; <span class="hljs-keyword">else</span> &#123;panic(<span class="hljs-string">&quot;TLB Mod but no user handler registered&quot;</span>);&#125;&#125;</code></pre></div><p>看mips的内容真的有点头疼, 因为基础不好, 对于mips的栈的内容理解并不是很好.</p><h2 id="页写入异常全过程">页写入异常全过程</h2><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230507195606.png" alt="image.png"></p><h3 id="tlb-mod处理函数的注册">tlb_mod处理函数的注册</h3><p>首先, 只有fork产生的函数(及父函数)需要用到COW机制, 所以我们在fork时对<code>env_user_tlb_mod_entry</code>进行注册.</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//fork.c</span><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;u_int child;u_int i;<span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><span class="hljs-comment">//首先对父进程的env_user_tlb_mod_entry进行赋值</span><span class="hljs-keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;try(syscall_set_tlb_mod_entry(<span class="hljs-number">0</span>, cow_entry));&#125;child = syscall_exofork();<span class="hljs-keyword">if</span> (child == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//debugf(&quot;\ntest_2\n&quot;);</span>env = envs + ENVX(syscall_getenvid());<span class="hljs-comment">//debugf(&quot;%d\n&quot; ,env-&gt;env_id);</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;VPN(USTACKTOP); i++) <span class="hljs-keyword">if</span> (*(vpd+ (i&gt;&gt;<span class="hljs-number">10</span>)) &amp; PTE_V &amp;&amp; *(vpt + i) &amp; PTE_V)duppage(child, i);<span class="hljs-comment">//对子进程的env_user_tlb_mod_entry进行赋值</span>try(syscall_set_tlb_mod_entry(child, cow_entry));try(syscall_set_env_status(child, ENV_RUNNABLE));<span class="hljs-keyword">return</span> child;&#125;</code></pre></div><h3 id="env-user-tlb-mod-entry在何时被使用">env_user_tlb_mod_entry在何时被使用</h3><p>当查到某页的标志位COW为真而不可写的时候会触发tlb_mod异常.</p><ol><li>触发异常后我们将直接进入<code>exc_gen_entry</code></li><li><code>exc_gen_entry</code>将我们带去在<code>kern/genex.S</code>中注册的<code>handle_mod</code>中</li><li>在<code>handle_mod</code>中, 我们申请TF_SIZE+8大小的栈帧,将此时的sp赋给$a0寄存器传入<code>do_tlb_mod</code> , 并将sp-8回到TF_SIZE的位置, 接着进入函数<code>do_tlb_mod</code>处理异常</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//handle_mod</span>NESTED(handle_\exception, TF_SIZE + <span class="hljs-number">8</span>, zero)    move    a0, sp    addiu   sp, sp, <span class="hljs-number">-8</span>    jal     \handler    addiu   sp, sp, <span class="hljs-number">8</span>    j       ret_from_exception<span class="hljs-title function_">END</span><span class="hljs-params">(handle_\exception)</span>.endm</code></pre></div><ol start="4"><li>让我们仔细看看<code>do_tlb_mod</code>函数:</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_tlb_mod</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span> &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">tmp_tf</span> =</span> *tf;<span class="hljs-comment">//此时我们在内核态, 按理来说是不会在用户态的栈空间里的</span><span class="hljs-comment">//如果我们在的话, 说明发生了嵌套异常, 那么不用覆盖之前的异常栈</span><span class="hljs-comment">//如果此时在用户的栈空间之外(内核态), 那么将sp设置为用户异常栈栈顶</span><span class="hljs-comment">//这样的话, 我们可以将tf保存在用户的栈空间</span><span class="hljs-keyword">if</span> (tf-&gt;regs[<span class="hljs-number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="hljs-number">29</span>] &gt;= UXSTACKTOP) &#123;tf-&gt;regs[<span class="hljs-number">29</span>] = UXSTACKTOP;&#125;<span class="hljs-comment">//sp减去一个tf的大小,相当于新申请一个tf</span>tf-&gt;regs[<span class="hljs-number">29</span>] -= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe);<span class="hljs-comment">//将这个tf的值保存为我们传入的异常现场tf, 相当于把这个异常现场保存在了用户空间中</span>*(<span class="hljs-keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="hljs-number">29</span>] = tmp_tf;<span class="hljs-keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;<span class="hljs-comment">//将保存的现场作为参数传入异常处理函数</span>tf-&gt;regs[<span class="hljs-number">4</span>] = tf-&gt;regs[<span class="hljs-number">29</span>];<span class="hljs-comment">//减去tf-&gt;regs[4]的大小, 腾出一个新的tf的空间</span>tf-&gt;regs[<span class="hljs-number">29</span>] -= <span class="hljs-keyword">sizeof</span>(tf-&gt;regs[<span class="hljs-number">4</span>]);<span class="hljs-comment">//进入函数的env_user_tlb_mod_entry函数, 即cow_entry</span>tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;&#125; <span class="hljs-keyword">else</span> &#123;panic(<span class="hljs-string">&quot;TLB Mod but no user handler registered&quot;</span>);&#125;&#125;</code></pre></div><h3 id="研究cow-entry">研究cow_entry</h3><p>进入了cow_entry后又发生了什么呢?<br>这里比较简单, 就是复制出了新页赋给子进程, 并取消了标记.<br>最后保存了现场, 返回.</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __attribute__((<span class="hljs-keyword">noreturn</span>)) cow_entry(<span class="hljs-keyword">struct</span> Trapframe *tf) &#123;u_int va = tf-&gt;cp0_badvaddr;u_int perm;<span class="hljs-comment">/* Step 1: Find the &#x27;perm&#x27; in which the faulting address &#x27;va&#x27; is mapped. */</span>perm = *(vpt + VPN(va)) &amp; <span class="hljs-number">0xfff</span>;<span class="hljs-keyword">if</span>(!(perm&amp;PTE_COW))user_panic(<span class="hljs-string">&quot;Perm doesn&#x27;t have PTE_COW&quot;</span>);<span class="hljs-comment">/* Step 2: Remove &#x27;PTE_COW&#x27; from the &#x27;perm&#x27;, and add &#x27;PTE_D&#x27; to it. */</span>perm |= PTE_D;perm &amp;= (~PTE_COW);<span class="hljs-comment">/* Step 3: Allocate a new page at &#x27;UCOW&#x27;. */</span>syscall_mem_alloc(<span class="hljs-number">0</span>, UCOW, perm);<span class="hljs-comment">/* Step 4: Copy the content of the faulting page at &#x27;va&#x27; to &#x27;UCOW&#x27;. */</span><span class="hljs-built_in">memcpy</span>(UCOW, PTE_ADDR(va), BY2PG);<span class="hljs-comment">// Step 5: Map the page at &#x27;UCOW&#x27; to &#x27;va&#x27; with the new &#x27;perm&#x27;.</span>syscall_mem_map(<span class="hljs-number">0</span>, UCOW, <span class="hljs-number">0</span>, (va&amp;(~<span class="hljs-number">0xfff</span>)), perm);<span class="hljs-comment">// Step 6: Unmap the page at &#x27;UCOW&#x27;.</span>syscall_mem_unmap(<span class="hljs-number">0</span>, UCOW);<span class="hljs-comment">// Step 7: Return to the faulting routine.</span><span class="hljs-comment">//注意这里, 我们把tf传入了sys_set_trapframe, 如果tf不在用户空间就会报错</span><span class="hljs-type">int</span> r = syscall_set_trapframe(<span class="hljs-number">0</span>, tf);user_panic(<span class="hljs-string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);&#125;</code></pre></div><h1>补充</h1><h2 id="如何注册一个系统调用">如何注册一个系统调用</h2><p>我们首先跟踪一个系统调用函数运行的路径:</p><ol><li>用户进程的某个函数调用了用户空间的<code>syscall_*</code>函数</li><li><code>syscall_*</code>函数调用了msyscall函数, 系统陷入内核态</li><li>内核态中将异常分发到 <code>handle_sys</code> 函数，将系统调用所需要的信息传递入内核</li><li>内核取得信息，执行对应的内核空间的系统调用函数<code>sys_*</code></li><li>系统调用完成, 返回用户态, 同时将返回值传递回用户态</li><li>系统调用完成</li></ol><p>所以为了注册一个系统调用, 我们要修改以下文件:</p><ol><li>在<code>user/include/lib.h</code>中添加用户态的系统调用定义<code>syscall_*</code></li><li>在<code>user/lib/syscall_lib.c</code>中完成<code>syscall_*</code>函数体</li><li>在<code>include/syscall.h</code>中注册系统调用</li><li>在<code>kern/syscall_all.c</code>中的<code>syscall_table[MAX_SYSNO]</code>数组中注册系统调用, 并完成系统调用函数</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab3_进程与异常</title>
    <link href="/2023/05/01/OS-lab3-Summary/"/>
    <url>/2023/05/01/OS-lab3-Summary/</url>
    
    <content type="html"><![CDATA[<h1>实验目的</h1><ol><li>创建进程并运行</li><li>实现时钟中断</li><li>实现进程调度</li></ol><h1>进程</h1><h2 id="PCB进程控制块">PCB进程控制块</h2><blockquote><p>PCB 是系统感知进程存在的唯一标志。进程与 PCB 是一一对应的.</p></blockquote><p>在MOS中PCB使用一个<code>env</code>结构体实现, 主要包含以下信息:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span>  <span class="hljs-comment">// Saved registers</span>LIST_ENTRY(Env) env_link; <span class="hljs-comment">// Free list</span>u_int env_id;  <span class="hljs-comment">// Unique environment identifier</span>u_int env_asid;  <span class="hljs-comment">// ASID</span>u_int env_parent_id;  <span class="hljs-comment">// env_id of this env&#x27;s parent</span>u_int env_status;  <span class="hljs-comment">// 只能有三种取值: ENV_FREE/ENV_NOT_RUNNABLE/ENV_RUNNABLE</span>Pde *env_pgdir;  <span class="hljs-comment">// Kernel virtual address of page dir</span>TAILQ_ENTRY(Env) env_sched_link;u_int env_pri;<span class="hljs-comment">// Lab 4 IPC</span>u_int env_ipc_value;   <span class="hljs-comment">// data value sent to us</span>u_int env_ipc_from;    <span class="hljs-comment">// envid of the sender</span>u_int env_ipc_recving; <span class="hljs-comment">// env is blocked receiving</span>u_int env_ipc_dstva;   <span class="hljs-comment">// va at which to map received page</span>u_int env_ipc_perm;    <span class="hljs-comment">// perm of page mapping received</span><span class="hljs-comment">// Lab 4 fault handling</span>u_int env_user_tlb_mod_entry; <span class="hljs-comment">// user tlb mod handler</span><span class="hljs-comment">// Lab 6 scheduler counts</span>u_int env_runs; <span class="hljs-comment">// number of times been env_run&#x27;ed</span>&#125;;</code></pre></div><p>这里的<code>TrapFrame</code>结构体信息如下:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span><span class="hljs-comment">/* Saved main processor registers. */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> regs[<span class="hljs-number">32</span>];<span class="hljs-comment">/* Saved special registers. */</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_status;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hi;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> lo;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_badvaddr;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_cause;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cp0_epc;&#125;;</code></pre></div><p><code>struct Env</code> 中的链表项共涉及调度队列 <code>env_sched_list</code> (LIST结构)和空闲队列 <code>env_free_list</code> (TAILQ结构)两个队列, TAILQ的好处是可以在头部和尾部插入取出.</p><h2 id="实现进程控制的流程">实现进程控制的流程</h2><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Drawing%202023-04-16%2016.19.53.excalidraw.svg" alt="Drawing 2023-04-16 16.19.53.excalidraw"></p><h2 id="初始化">初始化</h2><h3 id="env-init">env_init</h3><p><code>env_init</code>实现了Env 控制块的空闲队列和调度队列的初始化功能, 同时还实现了一个模板页目录的映射.<br>映射部分如下:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//申请一个物理页面</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span>;</span>panic_on(page_alloc(&amp;p));p-&gt;pp_ref++;base_pgdir = (Pde *)page2kva(p);map_segment(base_pgdir, <span class="hljs-number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Page), BY2PG),PTE_G);map_segment(base_pgdir, <span class="hljs-number">0</span>, PADDR(envs), UENVS, ROUND(NENV * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), BY2PG),    PTE_G);</code></pre></div><h3 id="map-segment">map_segment</h3><p><code>void map_segment(Pde *pgdir, u_long pa, u_long va, u_long size, u_int perm)</code><br>功能是在一级页表基地址 <code>pgdir</code> 对应的两级页表结构中做段地址映射，将虚拟地址段 <code>[va,va+size) </code>映射到物理地址段<code>[pa,pa+size)</code>，因为是按页映射，要求 size 必须是页 面大小的整数倍。同时为相关页表项的权限为设置为 perm。它在这里的作用是<strong>将内核中的 <code>Page</code> 和<code>Env</code>数据结构映射到用户地址</strong>，以供用户程序读取。</p><blockquote><p>注意: 虽然每个进程都具有自己独立的虚拟地址空间,但是这些虚拟地址空间中的内核空间,其实关联的都是同一块物理内存, 因此在初始化进程的时候, 应该将这个映射完成, 以便于用户程序读取内核中的 <code>Page</code> 和<code>Env</code>数据.</p></blockquote><p>要搞懂这个函数, 首先要理解什么叫做 <code>Map [va, va+size) of virtual address space to physical [pa, pa+size) in the 'pgdir'.</code><br>即理解此处MAP的含义: 使用<strong>页表</strong>为虚拟地址和物理地址建立映射关系, 使得可以通过页表找到虚拟地址对应的物理地址.<br>那么, 我们使用什么函数来映射物理地址和虚拟地址呢?</p><blockquote><p><code> int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm)</code></p><ul><li>Map the physical page ‘pp’ at virtual address ‘va’. The permission (the low 12 bits) of the page table entry should be set to ‘perm|PTE_V’.</li></ul></blockquote><h2 id="申请新进程">申请新进程</h2><h3 id="env-alloc">env_alloc</h3><p>两个进程管理链表初始化结束之后, 就可以开始创建进程了</p><ol><li>申请空闲的PCB(从 env_free_list里, 因为进程的最大数量是有限制的, 如果没有空闲的PCB块的话, 说明不能再申请新的进程)</li><li>手动初始化进程</li><li>为进程初始化页目录(每个进程有独立的地址空间, 体现为有独立的页目录*)(<code>env_setup_vm</code>函数来做这件事)</li><li>将PCB块从空闲链表里面取出</li></ol><blockquote><p>此处比较迷惑的一点是独立的地址空间为什么只需要独立的页目录就能实现:<br>因为地址空间只是虚拟的, 实际体现出来的就是va到pa的转换, 而页目录和页表实际上就记录了这个映射关系, 所以并不需要一个数据结构之类的专门存储一个&quot;地址空间&quot;.</p></blockquote><p>其中这段代码的含义要懂:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Step 4: Initialize the sp and &#x27;cp0_status&#x27; in &#x27;e-&gt;env_tf&#x27;. */</span><span class="hljs-comment">// Timer interrupt (STATUS_IM4) will be enabled.</span>e-&gt;env_tf.cp0_status = STATUS_IM4 | STATUS_KUp | STATUS_IEp;<span class="hljs-comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span>e-&gt;env_tf.regs[<span class="hljs-number">29</span>] = USTACKTOP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> **);</code></pre></div><h3 id="env-setup-vm">env_setup_vm</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Overview:</span><span class="hljs-comment"> *   Initialize the user address space for &#x27;e&#x27;.</span><span class="hljs-comment"> */</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span> &#123;<span class="hljs-comment">/* Step 1:</span><span class="hljs-comment"> *   Allocate a page for the page directory with &#x27;page_alloc&#x27;.</span><span class="hljs-comment"> *   Increase its &#x27;pp_ref&#x27; and assign its kernel address to &#x27;e-&gt;env_pgdir&#x27;.</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span>;</span>try(page_alloc(&amp;p));<span class="hljs-comment">/* Exercise 3.3: Your code here. */</span>p-&gt;pp_ref++;e-&gt;env_pgdir = (Pde *)page2kva(p);<span class="hljs-comment">/* Step 2: Copy the template page directory &#x27;base_pgdir&#x27; to &#x27;e-&gt;env_pgdir&#x27;. */</span><span class="hljs-built_in">memcpy</span>(e-&gt;env_pgdir, base_pgdir, BY2PG);<span class="hljs-comment">/*memcpy(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><span class="hljs-comment">       sizeof(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><span class="hljs-comment">只复制赋值了的一段也是ok的, 但是没必要*/</span><span class="hljs-comment">/* Step 3: Map its own page table at &#x27;UVPT&#x27; with readonly permission.</span><span class="hljs-comment"> * As a result, user programs can read its page table through &#x27;UVPT&#x27; */</span>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>这里说三点:</p><ol><li>怎么申请一个新的pgdir: 其实就是申请一个新的页面, 因为一个页目录其实就存放在一个物理页里面.</li><li>使用<code>void *_memcpy_(void *destin, void *source, unsigned n)；</code>来进行内存的拷贝<ul><li>所有系统函数使用的都是虚拟地址</li><li>如果只复制其中一段的话要注意地址是怎么算的</li></ul></li><li>关于最后一行代码的理解</li></ol><blockquote><p><code>e-&gt;env_pgdir</code>本身是页目录的指针, 因为MOS 中，将页表和页目录映射到了用户空间中的 0x7fc00000-0x80000000区域(即UVPT所指的4M空间), 因而, 根据自映射的原理, 页目录中的第PDX(UVPT)项就应该映射的是页目录本身. 因此, <code>e-&gt;env_pgdir[PDX(UVPT)]</code>这一个PDE的值就应该是<code>PADDR(e-&gt;env_pgdir)+perm</code>.</p></blockquote><h2 id="将程序加载进进程">将程序加载进进程</h2><p>前面我们完成了一个进程的申请和初始化, 那么问题来了, 这进程是用来干嘛的?<br>每个进程一开始都是一样的, 只有加载了不同的程序代码段后, 才会发挥不一样的功能.<br>即我们需要将程序加载到新进程的地址空间中(程序是指elf文件中的的可执行文件).<br>要想正确加载一个 ELF 文件到内存，只需将 ELF 文件中所有需要加载的程序段（program segment）加载到对应的虚拟地址上即可。</p><blockquote><p>我们已经写好了用于解析 ELF 文件的代码中的大部 分内容，你可以直接调用相应函数获取 ELF 文件的各项信息，并完成加载过程。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// lib/elfloader.c</span><span class="hljs-type">const</span> Elf32_Ehdr *<span class="hljs-title function_">elf_from</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">elf_load_seg</span><span class="hljs-params">(Elf32_Phdr *ph, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *bin, <span class="hljs-type">elf_mapper_t</span> map_page, <span class="hljs-type">void</span> *data)</span>;<span class="hljs-comment">// kern/env.c</span><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size)</span>;<span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_icode_mapper</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u_long va, <span class="hljs-type">size_t</span> offset, u_int perm,</span><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span>;</code></pre></div></blockquote><p>这部分的问题其实不是很大</p><h2 id="创建进程">创建进程</h2><p>创建进程包括了申请新进程和加载程序, 且是指在操作系统内核初始化时直接创建进程.<br>使用的是<code>struct Env *env_create(const void *binary, size_t size, int priority)</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> Env *<span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> priority)</span> &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><span class="hljs-comment">/* Step 1: Use &#x27;env_alloc&#x27; to alloc a new env. */</span>env_alloc(&amp;e, <span class="hljs-number">0</span>);<span class="hljs-comment">/* Step 2: Assign the &#x27;priority&#x27; to &#x27;e&#x27; and mark its &#x27;env_status&#x27; as runnable. */</span>e-&gt;env_pri = priority;e-&gt;env_status = ENV_RUNNABLE;<span class="hljs-comment">/* Step 3: Use &#x27;load_icode&#x27; to load the image from &#x27;binary&#x27;, and insert &#x27;e&#x27; into</span><span class="hljs-comment"> * &#x27;env_sched_list&#x27; using &#x27;TAILQ_INSERT_HEAD&#x27;. */</span>load_icode(e, binary, size);TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);<span class="hljs-keyword">return</span> e;&#125;</code></pre></div><h2 id="进程运行和切换">进程运行和切换</h2><p><code>env_run</code> 是进程运行使用的基本函数，它包括两部分：</p><ul><li>保存当前进程上下文 (如果当前没有运行的进程就跳过这一步)</li><li>恢复要启动的进程的<strong>上下文</strong>(其实就是Trapframe, 即进程执行时所有寄存器的状态)，然后运行该进程。</li></ul><blockquote><p><strong>Overview:</strong><br>Switch CPU context to the specified env ‘e’<br><strong>Post-Condition:</strong><br>Set ‘e’ as the current running env ‘curenv’.</p></blockquote><blockquote><p>运行一个新进程往往意味着是进程切换，而不是单纯的进程运行.<br>要理解进程切换，我们 就要知道进程切换时系统需要做些什么。实际上进程切换的时候，为了保证下一次进入这个进程 的时候我们不会再“从头来过”，而是有记忆地从离开的地方继续往后走，我们要保存一些信息， 那么，需要保存什么信息呢？<br>事实上，我们只需要保存进程的上下文信息，包括通用寄存器、HI、 LO 和 CP0 中的 SR，EPC，Cause 和 BadVAddr 寄存器。进程控制块除了 env_tf 其他的字段在 进程切换后还保留在原本的进程控制块中，并不会改变，因此不需要保存。<br>在 Lab3 中，我们在本实验里的寄存器状态保存的地方是 <code>KSTACKTOP</code> 以下的一个 <code>sizeof(TrapFrame)</code> 大小的区域中。(<code>curenv-&gt;env_tf = *((struct Trapframe *)KSTACKTOP - 1)</code>)</p></blockquote><p>总结以上说明，我们不难看出 env_run 的执行流程：</p><ol><li>保存当前进程的上下文信息。</li><li>切换 curenv 为即将运行的进程。</li><li>设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。</li><li>调用 env_pop_tf 函数，恢复现场、异常返回。</li></ol><h1>中断与异常</h1><blockquote><p>我们实验里认为中断是异常的一种，并且是仅有的一种异步异常。</p></blockquote><p>CPU 不仅仅有我们常见的 32 个通用寄存器，还有 功能广泛的协处理器，而中断/异常部分就用到了其中的协处理器 CP0.<br>下面的表格介绍了编号 为 12，13，14 的三个 CP0 寄存器的具体功能。<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230416210751.png" alt="image.png"><br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230416210853.png" alt="image.png"><br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230416210904.png" alt="image.png"></p><blockquote><ul><li><strong>SR 寄存器</strong>：图3.1(在设置进程控制块部分给出) 是 MIPS R3000 中 Status Register 寄存器， 15-8 位为中断屏蔽位，每一位代表一个不同的中断活动，其中 15-10 位使能外部中断源，9-8 位 是 Cause 寄存器软件可写的中断位。</li><li><strong>Cause 寄存器</strong>：图3.3是 MIPS R3000 中 Cause 寄存器。其中保存着 CPU 中哪一些中断或 者异常已经发生。15-8 位保存着哪一些中断发生了，其中 15-10 位来自硬件，9-8 位可以由软件 写入，当 SR 寄存器中相同位允许中断（为 1）时，Cause 寄存器这一位活动就会导致中断。6-2 位（ExcCode），记录发生了什么异常。</li></ul></blockquote><p>MIPS CPU 处理一个异常时大致要完成四项工作：</p><ol><li>设置 EPC 指向从异常返回的地址。</li><li>设置 SR 位，强制 CPU 进入内核态（行使更高级的特权）并禁止中断。</li><li>设置 Cause 寄存器，用于记录异常发生的原因。</li><li>CPU 开始从异常入口位置取指，此后<strong>一切交给软件处理</strong>。<br>而这句“一切交给软件处理”，就是我们当前任务的开始。<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230416211423.png" alt="image.png"></li></ol><h2 id="异常的分发">异常的分发</h2><p>当发生异常时，处理器会进入一个用于<strong>分发异常</strong>的程序，这个程序的作用就是检测发生了哪 种异常，并调用相应的异常处理程序。</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">.section</span> <span class="hljs-meta">.text</span>.exc_gen_entry<span class="hljs-symbol">exc_gen_entry:</span>SAVE_ALLmfc0 t0, CP0_CAUSE #将 Cause 寄存器的内容拷贝到 t0 寄存器中andi t0, <span class="hljs-number">0x7c</span> #取得 Cause 寄存器中的 <span class="hljs-number">2</span>~<span class="hljs-number">6</span> 位，也就是对应的异常码，这是区别不同异常的重要标志lw t0, exception_handlers(t0) #以得到的异常码作为索引在 exception_handlers 数组中找到对应的中断处理函数jr t0 #跳转到对应的异常处理函数中，从而响应了异常</code></pre></div><p>在我们的系统中，CPU 发生异常（除了用户态地址的 TLB Miss 异常）后，就会自动跳转到地址 0x80000080 处；发生用户态地址的 TLB Miss 异常时，会自动跳转到地址 0x80000000 处。<br>因此, 在<code>kernel.lds</code>中添加代码, 以保证异常被响应:</p><div class="code-wrapper"><pre><code class="hljs ada">. = <span class="hljs-number">0</span>x80000000;.tlb_miss_entry : &#123;*(.text.tlb_miss_entry)&#125;. = <span class="hljs-number">0</span>x80000080;.exc_gen_entry : &#123;*(.text.exc_gen_entry)&#125;</code></pre></div><h2 id="中断的处理">中断的处理</h2><p>接上文, 跳转到对应的异常处理函数中, 那么异常处理函数有哪些呢?</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> (*exception_handlers[<span class="hljs-number">32</span>])(<span class="hljs-type">void</span>) = &#123;    [<span class="hljs-number">0</span> ... <span class="hljs-number">31</span>] = handle_reserved,    [<span class="hljs-number">0</span>] = handle_int,    [<span class="hljs-number">2</span> ... <span class="hljs-number">3</span>] = handle_tlb,    [<span class="hljs-number">1</span>] = handle_mod,    [<span class="hljs-number">8</span>] = handle_sys,&#125;;</code></pre></div><blockquote><ul><li><strong>0 号异常</strong> 的处理函数为 handle_int，表示<strong>中断</strong>，由时钟中断、控制台中断等中断造成</li><li><strong>1 号异常</strong> 的处理函数为 handle_mod，表示存储异常，进行存储操作时该页被标记为只读</li><li><strong>2 号异常</strong> 的处理函数为 handle_tlb，表示 TLB load 异常</li><li><strong>3 号异常</strong> 的处理函数为 handle_tlb，表示 TLB store 异常</li><li><strong>8 号异常</strong> 的处理函数为 handle_sys，表示系统调用，用户进程通过执行 syscall 指令陷 入内核</li></ul></blockquote><p>这里先谈<strong>中断</strong>.<br>Cause 寄存器中有 8 个独立的中断位。<br>其中 6 位是硬件中断，另外 2 位是软件中断，且不同中断处理起来也会有差异。<br>我们首先来介绍一下中断处理的流程:</p><ol><li>通过异常分发，判断出当前异常为<strong>中断异常</strong>，随后进入相应的中断处理程序。在 MOS 中即对应 handle_int 函数。</li><li>在中断处理程序中进一步判断 Cause 寄存器中是由<strong>几号中断</strong>位引发的中断，然后进入不同中断对应的中断服务函数。</li><li>中断处理完成，通过 ret_from_exception 函数恢复现场，继续执行。</li></ol><p>我们只需要完成1,2步, 并且只需要完成时钟中断(<strong>4 号中断</strong>)的部分就可以了.</p><blockquote><p>时钟中断和操作系统的时间片轮转算法是紧密相关的。<br>时间片轮转调度是一种进程调度算法，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则该进程将挂起，切换到另一个进程运行。<br>那么 CPU 是如何知晓一个进程的时间片结束的呢？<br>通过定时器产生的时钟中断。当时钟中断产生时，当前运行的进程被挂起，我们需要在调度队列中选取一个合适的进程运行。<br>如何“选取”，就要涉及到<strong>进程的调度</strong>了。</p></blockquote><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Drawing%202023-04-16%2021.47.50.excalidraw.svg" alt="Drawing 2023-04-16 21.47.50.excalidraw"><br>调度函数的实现比较简单, 就不细讲了.</p><h2 id="进程调度">进程调度</h2><h3 id="轮询调度">轮询调度</h3><p>今天课上提到晚上要考进程调度, 这样的话还是看看吧!<br>先来看看最初始版本的进程调度是怎么实现的:</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Overview:</span><span class="hljs-comment"> *   Implement a round-robin scheduling(轮询调度算法) to select a runnable env and schedule it using &#x27;env_run&#x27;.</span><span class="hljs-comment">*/</span>*<span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(<span class="hljs-type">int</span> yield)</span> &#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// remaining time slices of current env</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span> =</span> curenv;<span class="hljs-comment">//有两种情况: 需要切换进程和不需要切换进程</span><span class="hljs-keyword">if</span>(yield!=<span class="hljs-number">0</span> || count&lt;=<span class="hljs-number">0</span> || e==<span class="hljs-literal">NULL</span> || e-&gt;env_status != ENV_RUNNABLE)&#123;<span class="hljs-keyword">if</span>(e!=<span class="hljs-literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE)&#123;TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);&#125;panic_on(TAILQ_EMPTY(&amp;env_sched_list)!=<span class="hljs-number">0</span>);e = TAILQ_FIRST(&amp;env_sched_list);count = e-&gt;env_pri;&#125;count--;env_run(e);&#125;</code></pre></div><p>这个调度算法是最简单的<strong>轮询调度</strong>, 并使用时间片判断, 逻辑如下:</p><ul><li>此时有两种情况: 需要切换进程和不需要切换进程</li><li>如果当前没有进程/进程时间片用光/进程不再可运行/yield指定切换, 那么<strong>切换进程</strong><ul><li>(如果当前进程不是空进程且仍然处在<code>ENV_RUNNABLE</code>状态的话) 将当前进程移动到调度队列尾部</li><li><strong>从进程调度队列<code>env_sched_list</code>取出一个新进程(不要把他从调度队列里删掉)(没有可用时panic)</strong></li><li>设定count为进程优先级<code>e-&gt;env_pri</code></li><li>count–</li><li>运行该进程</li></ul></li><li>否则<strong>继续运行进程</strong><ul><li>count–</li><li>运行该进程</li></ul></li></ul><p>其中调度算法即实现中间这一步:</p><blockquote><p><strong>从进程调度队列<code>env_sched_list</code>取出一个新进程(没有可用时panic)</strong></p></blockquote><p>在课下实验我们并没有按照优先级来实现算法, 而是简单的插入尾部和取头部.</p><h3 id="其他可能的调度方法">其他可能的调度方法</h3><p>（待补充）</p><h1>总结</h1><p>至此，我们的 Lab3 就算是圆满完成了。<br>中断部分我们只学习了时钟中断, 其实TLB_miss的处理也是一个值得学习的地方.<br>指导书中简单介绍了系统如何响应TLB_miss.<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/20230416215810.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab2_内存管理</title>
    <link href="/2023/04/04/OS-lab2-Summary/"/>
    <url>/2023/04/04/OS-lab2-Summary/</url>
    
    <content type="html"><![CDATA[<h1>内存管理</h1><h2 id="映射">映射</h2><ul><li>kseg0 -&gt; 最高位置0(内核代码与数据结构)</li><li>kseg1 -&gt; 最高三位置0(外设)</li><li>kuseg -&gt; TLB访存(用户空间)</li></ul><h2 id="建立过程">建立过程</h2><blockquote><p>现在还没有建立内存管理机制，那么是如何操作内存呢？<br><strong>这是因为在 Lab2 中通过 kseg0 段地址直接操作物理内存。虽然实验一直在操作如 0x80xxxxxx 的虚拟地址，由于 kseg0 段的性质，操作系统可以通过这一段地址来直接操作物理内存，从而逐步建立内存管理机制.</strong> 例如当写虚拟地址 0x80012340 时，由于 kseg0 段的性质，事实上在写物理地址 0x12340。<br>可以回顾前面的“虚拟地址映射到物理地址”小节，其中有提到，在 kuseg 段的虚拟地址才需要通过 MMU 的转换获得物理地址后访存。在 Lab2 中所做的内存管理工作，正是使将来在 kuseg 段的用户程序能够正常工作。</p></blockquote><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172009689.png" alt="image-20230404172009689"></p><h3 id="初始化页控制块的控制系统-借用alloc和pages实现">初始化页控制块的控制系统(借用alloc和pages实现)</h3><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172053973.png" alt="image-20230404172053973"><br>补充: alloc函数用于在操作系统尚未建立分页系统时进行物理空间的分配<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172117022.png" alt="image-20230404172117022"></p><h3 id="在页控制块管理物理内存的基础上完善函数">在页控制块管理物理内存的基础上完善函数</h3><ul><li><code>page_alloc(struct Page** pp)</code>: 获取一页物理内存<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172156774.png" alt="image-20230404172156774"></li><li><code>page_decref(struct Page *pp)</code> : 令pp对应的页控制块引用次数减少1.</li><li><code>page_free(struct Page *pp)</code>: 释放空闲(assert)页面</li></ul><h3 id="在页控制块管理物理内存的基础上建立两级页表">在页控制块管理物理内存的基础上建立两级页表</h3><ul><li>两级页表解读:<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172404825.png" alt="image-20230404172404825"></li><li>两级页表下的检索机制:</li><li><code>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</code><br>给定一个页目录基址<code>pgdir</code>, 一个虚拟地址 <code>va</code>, 返回该虚拟地址对应的页表项.<br>利用这个函数,我们可以获得任何虚拟地址对应的页表项,从而获得虚拟地址和物理地址的映射.<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172425991.png" alt="image-20230404172425991"></li><li><code>int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm)</code><br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/image-20230404172444819.png" alt="image-20230404172444819"></li><li><code>struct Page * page_lookup(Pde *pgdir, u_long va, Pte **ppte)</code>  ：查找</li><li><code>void page_remove(Pde *pgdir, u_int asid, u_long va)</code>  ： 移除<br>自此，二级页表的内存管理机制建立。</li></ul><h3 id="两级页表例子">两级页表例子</h3><p>为了加深对于二级页表机制的理解, 附上两道例题:</p><blockquote><ol><li>如果当前进程的页目录物理基地址、页目录和相应页表内容如图下所示，请描述访问0x00803004时系统进行地址转换的过程，如可行给出最终访存获取到的数据。</li></ol></blockquote><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230402181110.png" alt="Pasted image 20230402181110"><br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230402174714.png" alt="Pasted image 20230402174714"></p><p>答:<br>0x00803004转换为二进制为:0000000010 0000000011 000000000100<br>页目录号为2,查询得0x5001, 有效位为1, 页表物理地址为0x5000<br>二级页表号为3, 查询0x5000处页表的第三项, 得0x20001, 有效位为1, 页面物理地址为0x20000.<br>页内偏移为4,故访问到的数据为0x326001.</p><blockquote><ol start="2"><li>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。 因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。 现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</li></ol><ul><li>三级页表页目录的基地址。</li><li>映射到页目录自身的页目录项（自映射）。</li></ul></blockquote><p>(1) 答:<br>三级页表的基地址为PTBase，因为128M个页表项和512GB空间是线性映射的，所以PTBase这一地址对应的应为第(PTBase&gt;&gt;12)个页表项(512个项x8B). 对应的是第一个二级页目录项. 因此,二级页目录基址为: PTBase + (PTBase&gt;&gt;12)*8 =  PTBase + PTBase&gt;&gt;9<br>一二级的映射可以参照二三级的映射用一样的方法计算.<br>(PTBase&gt;&gt;9)这一地址对应的应为第(PTBase&gt;&gt;9)&gt;&gt;12个页表项,对应的是第一个一级页目录项. 偏移为:((PTBase&gt;&gt;9)&gt;&gt;12)&lt;&lt;3. 因此, 一级页目录基址为: PTBase + (PTBase&gt;&gt;9) + (PTBase&gt;&gt;18)<br>(2)答:<br>那么, 自映射到自身的就是再重复一次, 为: PTBase + (PTBase&gt;&gt;9) + (PTBase&gt;&gt;18) + (PTBase&gt;&gt;27)</p><h2 id="虚拟地址-物理地址和内核虚拟地址">虚拟地址, 物理地址和内核虚拟地址</h2><p>程序运行时,在建立了虚拟地址空间后,并没有分配实际的物理内存,而是当进程需要实际访问内存资源的时候就会由内核的请求分页机制产生缺页中断,这时才会建立虚拟地址和物理地址的映射,调入物理内存页.通过这种方式,就能够保证我们的物理内存只有在实际使用时才进行分配,避免了内存浪费的问题.<br>虚拟地址空间的内部又被划分为<strong>用户空间</strong>与<strong>内核空间</strong>.<br>内核空间即进程陷入内核态后才能访问的空间.<strong>虽然每个进程都具有自己独立的虚拟地址空间,但是这些虚拟地址空间中的内核空间,其实关联的都是同一块物理内存</strong>.<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230402170006.png" alt="Pasted image 20230402170006"><br>体现在MOS中为:<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230319211651.png" alt="Pasted image 20230319211651"></p><ul><li>内核空间<ul><li>若虚拟地址处于 0x80000000~0x9fffffff (kseg0)，则将虚拟地址的最高位置 0 得到物理地址，通过 cache 访存。这一部分用于存放内核代码与数据结构。</li><li>若虚拟地址处于 0xa0000000~0xbfffffff (kseg1)，则将虚拟地址的最高 3 位置 0 得到物理地址，不通过 cache 访存。这一部分可以用于映射外设(使用 MMIO(Memory-Mapped I/O)技术)。</li></ul></li><li>用户空间<ul><li>若虚拟地址处于 0x00000000~0x7fffffff (kuseg)，则需要通过 TLB 来获取物理地址, 通过 cache 访存。</li></ul></li></ul><blockquote><p>关于kseg2: 0xC0000000-0xFFFFFFFF(1 GB)：这段地址只能在内核态下使用并且需要 MMU 中 TLB 将虚拟地址转换为物理地址。对这段地址的存取都会通过 cache。目前的实验中还没有涉及到这部分, 应该对应的是LINUX中的高端内存映射区, 暂时先不关注.</p></blockquote><p><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230402170735.png" alt="Pasted image 20230402170735"></p><p>在LAB2包括后续LAB3的实验过程中, 经常会困惑的一点是: 这个地址到底是虚拟地址, 物理地址还是内核虚拟地址? 这些地址之间有什么区别和联系? 能不能做一个归纳和分类? 没错, 现在就是在解答这个疑惑.</p><h3 id="虚拟地址-VA">虚拟地址(VA)</h3><blockquote><p>CPU 运行程序时通过访存指令发出访存请求，进行内存读写操作。在计算机组成原理等硬件实验中, CPU 通常直接发送物理地址，这是为了简化内存操作，让大家关注 CPU 内部的计算与控制逻辑。<br>而在实际程序中，访存、跳转等指令以及用于取指的 PC 寄存器中的访存目标地址都是虚拟地址。我们编写的 C 程序中也经常通过对指针解引用来进行访存，其中指针的值也会被视为虚拟地址，经过编译后生成相应的访存指令。</p></blockquote><p>也就是说, 不管是向MIPS传入的访存地址, 还是在C程序中使用的指针(只要是需要使用的指针, 比如说要取指针指向的值, 或者要传入memset函数等)都是虚拟地址.</p><h3 id="内核虚拟地址-KVA">内核虚拟地址(KVA)</h3><p>内核虚拟地址也是虚拟地址的一部分, 但是由于其特殊性, 可以单独拎出来.</p><ul><li>虽然每个进程都具有自己独立的虚拟地址空间,但是这些虚拟地址空间中的内核空间,其实关联的都是同一块物理内存</li><li>MOS 中采用 PADDR 与 KADDR 这两个宏就可以对位于 kseg0 的虚拟地址和对应的物理地址进行转换.<br>很多常用的宏都是在操作kva, 比如说<code>PADDR</code>, <code>page2kva</code>等, 其本质原因是因为这些控制块, 结构等都在内核态中操作.</li><li>值得注意的是, 页表都存在实际的物理内存中, 但是, 对页表进行操作时处于内核态，因此使用宏 KADDR 获得其位于 kseg0中的虚拟地址.</li></ul><h3 id="物理地址">物理地址</h3><p>MIPS R3000 发出的地址均为虚拟地址，因此如果程序想访问某个物理地址，需要通过映射到该物理地址的虚拟地址来访问。<br>通常来说, 在页表映射时会容易出现物理地址, 此时通常都要将物理地址转换为虚拟地址再进行操作.</p><h2 id="常用的宏和函数">常用的宏和函数</h2><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12 <span class="hljs-comment">//页面的大小: 4K</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADDR(kva) <span class="hljs-comment">//返回虚拟地址kva(必须位于kseg0)所对应的物理地址</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> KADDR(pa)  <span class="hljs-comment">//返回物理地址所对应的虚拟地址kva(必须位于kseg0)</span></span><span class="hljs-comment">//Page指针转为该Page对应的物理页面的虚拟地址</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u_long <span class="hljs-title function_">page2kva</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Page *pp)</span><span class="hljs-comment">//Page指针获得该Page对应的物理页面的物理地址</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u_long <span class="hljs-title function_">page2pa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Page *pp)</span><span class="hljs-comment">//物理地址转为Page指针</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> Page *<span class="hljs-title function_">pa2page</span><span class="hljs-params">(u_long pa)</span><span class="hljs-comment">//Page指针获得该Page是第几页</span><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> u_long <span class="hljs-title function_">page2ppn</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Page *pp)</span><span class="hljs-comment">//解析VA的宏</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03FF) <span class="hljs-comment">//获取页目录偏移</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03FF) <span class="hljs-comment">//获取二级页表偏移</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)    <span class="hljs-comment">//获取该pte对应的物理页面地址</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab1_内核启动</title>
    <link href="/2023/03/20/OS-lab1-Summary/"/>
    <url>/2023/03/20/OS-lab1-Summary/</url>
    
    <content type="html"><![CDATA[<h1>多个C文件的连接和编译</h1><h2 id="基本流程">基本流程</h2><p>![](<a href="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted">https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted</a> image 20230319200455.png)<br>多个C语言文件编译成为一个可执行文件,首先通过<code>gcc -c &lt;filename&gt;</code>将.c文件编译为.o二进制文件, 再通过链接的方式将多个.o文件链接在一起(此时最后每条指令的地址也因此确定), 生产最后的可执行文件.</p><h2 id="ELF文件-深入探究编译链接">ELF文件 - 深入探究编译链接</h2><p>链接器通过哪些信息来链接多个目标文件呢？---- 目标文件(比如说: elf文件)</p><p>在目标文件中，记录了代码各个段的具体信息。链接器通过这些信息来将目标文件链接到一起。而 ELF(Executable and Linkable Format) 正是 Unix 上常用的一种 目标文件格式。其实，不仅仅是目标文件，可执行文件也是使用 ELF 格式记录的。这一点通过 ELF 的全称也可以看出来。</p><p><strong>.o 文件就是 ELF 所包含的三种文件类型中的一种</strong>，称为可重 定位 (relocatable) 文件，其它两种文件类型分别是可执行 (executable) 文件和共享对象 (shared object) 文件，这两种文件都需要链接器对可重定位文件进行处理才能生成。</p><p>ELF文件结构:<br>![](<a href="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted">https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted</a> image 20230319201114.png)<br>段头表（或程序头表，program header table），主要包含程序中各个段（segment）的信息， <strong>段的信息需要在运行时刻使用</strong>。<br>节头表（section header table），主要包含程序中各个节（section）的信息，<strong>节的信息需要 在程序编译和链接的时候使用</strong>。(因此在这里我们主要关心节头表)<br>段头表和节头表指向了同样的地方，这意味着两者只是程序数据的两种视图:</p><ol><li>组成可重定位文件，参与可执行文件和可共享文件的链接。此时使用节头表。</li><li>组成可执行文件或者可共享文件，在运行时为加载器提供信息。此时使用段头表。</li></ol><p>现在来逐一分析ELF文件内容:</p><h3 id="ELF文件头">ELF文件头</h3><p>ELF 的文件头，就是一个存了关于 ELF 文件信息的结构体。 首先，结构体中存储了 ELF 的魔数，以验证这是一个有效的 ELF。当我们验证了这是个 ELF 文件之后，便可以通过 ELF 头中提供的信息，进一步地解析 ELF 文件了。<br>存放了<code>Elf32_Ehdr</code>, <code>Elf32_Shdr</code>和<code>Elf32_Phdr</code>三种数据结构.<br>Ehdr : elf文件结构 ; <strong>Shdr: 节头表结构</strong> ; Phdr: 段头表结构</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_ident[EI_NIDENT]; <span class="hljs-comment">/* Magic number and other info */</span>    Elf32_Half e_type;        <span class="hljs-comment">/* Object file type */</span>    Elf32_Half e_machine;         <span class="hljs-comment">/* Architecture */</span>    Elf32_Word e_version;         <span class="hljs-comment">/* Object file version */</span>    Elf32_Addr e_entry;       <span class="hljs-comment">/* Entry point virtual address */</span>    Elf32_Off e_phoff;        <span class="hljs-comment">/* Program header table file offset */</span>    Elf32_Off e_shoff;        <span class="hljs-comment">/* Section header table file offset */</span>    Elf32_Word e_flags;       <span class="hljs-comment">/* Processor-specific flags */</span>    Elf32_Half e_ehsize;          <span class="hljs-comment">/* ELF header size in bytes */</span>    Elf32_Half e_phentsize;       <span class="hljs-comment">/* Program header table entry size */</span>    Elf32_Half e_phnum;       <span class="hljs-comment">/* Program header table entry count */</span>    Elf32_Half e_shentsize;       <span class="hljs-comment">/* Section header table entry size */</span>    Elf32_Half e_shnum;       <span class="hljs-comment">/* Section header table entry count */</span>    Elf32_Half e_shstrndx;        <span class="hljs-comment">/* Section header string table index */</span>&#125; Elf32_Ehdr;</code></pre></div><p>可以看到, ehdr中包含了很多关键信息,如<code>e_phoff</code>, <code>e_shoff</code>.</p><div class="code-wrapper"><pre><code class="hljs c">Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;</code></pre></div><p>我们在读取elf文件一开始将ELF文件的入口作为一个<code>Elf32_Ehdr *</code>类型的指针, 这样做的好处是在地址空间自动的划出一个<code>sizeof(Elf32_Ehdr)</code>大小的区域, 这片区域自然就是ELF文件头.</p><h3 id="读取ELF文件">读取ELF文件</h3><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readelf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size)</span> &#123;    Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;    <span class="hljs-comment">// Check whether `binary` is a ELF file.</span>    <span class="hljs-keyword">if</span> (!is_elf_format(binary, size)) &#123;        <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;not an elf file\n&quot;</span>, <span class="hljs-built_in">stderr</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">// Get the address of the section table, the number of section headers and the size of a section header.</span>    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *sh_table;    Elf32_Half sh_entry_count;    Elf32_Half sh_entry_size;    <span class="hljs-comment">/* Exercise 1.1: Your code here. (1/2) */</span>    <span class="hljs-comment">//这里主要考察的就是有没有去读elf.h文件,如果读了就知道这些数据全部在文件头中给出</span>    sh_table = binary + ehdr-&gt;e_shoff;    sh_entry_count = ehdr-&gt;e_shnum;    sh_entry_size = ehdr-&gt;e_shentsize;    <span class="hljs-comment">// For each section header, output its index and the section address.</span>    <span class="hljs-comment">//注意,Elf32_Shdr这个结构体，是一个节头部表的一个条目（即一个表项），而不是一个一整个段头部表, 起到存储对应的节的信息. 这里我们将对应的节的地址取出</span>    <span class="hljs-comment">// The index should start from 0.</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sh_entry_count; i++) &#123;        <span class="hljs-type">const</span> Elf32_Shdr *shdr;        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;        <span class="hljs-comment">/* Exercise 1.1: Your code here. (2/2) */</span>        addr = ((Elf32_Shdr *)(sh_table + i*sh_entry_size))-&gt;sh_addr;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:0x%x\n&quot;</span>, i, addr);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="关于ELF32和ELF64文件">关于ELF32和ELF64文件</h2><p>我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230319210414.png" alt=""><br>可以发现, readelf文件是一个ELF64类型的文件, 而我们编写的<code>readelf.c</code>只能读取elf32类型的文件.<br>对比官方<code>elf.h</code>和MOS的<code>elf.h</code></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//linux elf.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_hdr</span> &#123;</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>e_ident[EI_NIDENT]; <span class="hljs-comment">//魔数 7F+’E’+’L’+’F’</span>  Elf64_Half e_type; <span class="hljs-comment">//文件类型 </span>  Elf64_Half e_machine; <span class="hljs-comment">//机器类型</span>  Elf64_Word e_version; <span class="hljs-comment">//文件版本</span>  Elf64_Addr e_entry;     <span class="hljs-comment">//进程开始的虚地址，即系统将控制转移的位置</span>  Elf64_Off e_phoff; <span class="hljs-comment">//program header table的文件偏移</span>  Elf64_Off e_shoff;         <span class="hljs-comment">//section header表的文件偏移</span>  Elf64_Word e_flags; <span class="hljs-comment">//处理器相关的标志</span>  Elf64_Half e_ehsize; <span class="hljs-comment">//ELF文件头的长度</span>  Elf64_Half e_phentsize; <span class="hljs-comment">//program header表中的入口的长度</span>  Elf64_Half e_phnum; <span class="hljs-comment">//program header表中的入口数目</span>  Elf64_Half e_shentsize; <span class="hljs-comment">//section header表中的入口的长度</span>  Elf64_Half e_shnum; <span class="hljs-comment">//section header表中的入口数目</span>  Elf64_Half e_shstrndx; <span class="hljs-comment">//section名表的位置，指出在section header表中的索引</span>&#125; Elf64_Ehdr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_phdr</span> &#123;</span>  Elf64_Word p_type;<span class="hljs-comment">//段的类型</span>  Elf64_Word p_flags;       <span class="hljs-comment">//段标志</span>  Elf64_Off p_offset;<span class="hljs-comment">//段偏移</span>  Elf64_Addr p_vaddr;<span class="hljs-comment">//段虚地址</span>  Elf64_Addr p_paddr;<span class="hljs-comment">//段物理地址</span>  Elf64_Xword p_filesz;<span class="hljs-comment">//段大小</span>  Elf64_Xword p_memsz;<span class="hljs-comment">//段在内存的占用</span>  Elf64_Xword p_align;<span class="hljs-comment">//段对齐</span>&#125; Elf64_Phdr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_shdr</span> &#123;</span>  Elf64_Word sh_name;<span class="hljs-comment">//段名，值为符号表索引</span>  Elf64_Word sh_type;<span class="hljs-comment">//类别</span>  Elf64_Xword sh_flags;<span class="hljs-comment">//程执行时的特性</span>  Elf64_Addr sh_addr;<span class="hljs-comment">//进程的内存映像中出现，则给出开始的虚地址</span>  Elf64_Off sh_offset;<span class="hljs-comment">//偏移</span>  Elf64_Xword sh_size;<span class="hljs-comment">//大小</span>  Elf64_Word sh_link;<span class="hljs-comment">//相对其他段的索引</span>  Elf64_Word sh_info;<span class="hljs-comment">//信息</span>  Elf64_Xword sh_addralign;<span class="hljs-comment">//对齐</span>  Elf64_Xword sh_entsize;<span class="hljs-comment">//</span>&#125; Elf64_Shdr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elf64_sym</span> &#123;</span>  Elf64_Word st_name;<span class="hljs-comment">//符号名</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_info;<span class="hljs-comment">//符号类型</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>st_other;<span class="hljs-comment">//其他</span>  Elf64_Half st_shndx;<span class="hljs-comment">//段索引</span>  Elf64_Addr st_value;<span class="hljs-comment">//符号地址值</span>  Elf64_Xword st_size;<span class="hljs-comment">//符号大小</span>&#125; Elf64_Sym;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//MOS elf.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_ident[EI_NIDENT]; <span class="hljs-comment">/* Magic number and other info */</span>    Elf32_Half e_type;        <span class="hljs-comment">/* Object file type */</span>    Elf32_Half e_machine;         <span class="hljs-comment">/* Architecture */</span>    Elf32_Word e_version;         <span class="hljs-comment">/* Object file version */</span>    Elf32_Addr e_entry;       <span class="hljs-comment">/* Entry point virtual address */</span>    Elf32_Off e_phoff;        <span class="hljs-comment">/* Program header table file offset */</span>    Elf32_Off e_shoff;        <span class="hljs-comment">/* Section header table file offset */</span>    Elf32_Word e_flags;       <span class="hljs-comment">/* Processor-specific flags */</span>    Elf32_Half e_ehsize;          <span class="hljs-comment">/* ELF header size in bytes */</span>    Elf32_Half e_phentsize;       <span class="hljs-comment">/* Program header table entry size */</span>    Elf32_Half e_phnum;       <span class="hljs-comment">/* Program header table entry count */</span>    Elf32_Half e_shentsize;       <span class="hljs-comment">/* Section header table entry size */</span>    Elf32_Half e_shnum;       <span class="hljs-comment">/* Section header table entry count */</span>    Elf32_Half e_shstrndx;        <span class="hljs-comment">/* Section header string table index */</span>&#125; Elf32_Ehdr;<span class="hljs-comment">//余下相似,不在复制</span></code></pre></div><p>但是因为readelf.c源代码几乎全部使用宏, 感觉如果想写一个解析elf64的readelf.c几乎不需要什么改动, 很疑惑(感觉会在这里出题呀)?</p><h2 id="可执行文件的运行">可执行文件的运行</h2><h3 id="内核在哪里-内存布局">内核在哪里:内存布局</h3><p>只要我们能够将内核加载到正确的位置上，我们的内核就应该 可以运行起来。<br>思考到这里，我们又发现了几个重要的问题。</p><ol><li>什么叫做正确的位置？到底放在哪里才叫正确。</li><li>哪个段被加载到哪里是记录在编译器编译出来的 ELF 文件里的，我们怎么才能修改它呢？</li></ol><p>关于内核应该被加载到哪里: kseg0<br><img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Pasted%20image%2020230319211651.png" alt=""></p><div class="code-wrapper"><pre><code class="hljs gherkin">/<span class="hljs-symbol">*</span> o     4G -----------&gt;  +----------------------------+------------0x100000000 o                      |<span class="hljs-string">       ...                  </span>|<span class="hljs-string">  kseg2</span><span class="hljs-string"> o      KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span><span class="hljs-string"> o                      </span>|<span class="hljs-string">          Devices           </span>|<span class="hljs-string">  kseg1</span><span class="hljs-string"> o      KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span><span class="hljs-string"> o                      </span>|<span class="hljs-string">      Invalid Memory        </span>|<span class="hljs-string">   /</span>|<span class="hljs-string">\</span><span class="hljs-string"> o                      +----------------------------+----</span>|<span class="hljs-string">-------Physical Memory Max</span><span class="hljs-string"> o                      </span>|<span class="hljs-string">       ...                  </span>|<span class="hljs-string">  kseg0</span><span class="hljs-string"> o      KSTACKTOP-----&gt; +----------------------------+----</span>|<span class="hljs-string">-------0x8040 0000-------end</span><span class="hljs-string"> o                      </span>|<span class="hljs-string">       Kernel Stack         </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> KSTKSIZE            /</span>|<span class="hljs-string">\</span><span class="hljs-string"> o                      +----------------------------+----</span>|<span class="hljs-string">------                </span>| o                      |<span class="hljs-string">       Kernel Text          </span>|<span class="hljs-string">    </span>|<span class="hljs-string">                    PDMAP</span><span class="hljs-string"> o      KERNBASE -----&gt; +----------------------------+----</span>|<span class="hljs-string">-------0x8001 0000    </span>| o                      |<span class="hljs-string">      Exception Entry       </span>|<span class="hljs-string">   \</span>|<span class="hljs-string">/                    \</span>|<span class="hljs-string">/</span><span class="hljs-string"> o      ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span><span class="hljs-string"> o                      </span>|<span class="hljs-string">         User VPT           </span>|<span class="hljs-string">     PDMAP                /</span>|<span class="hljs-string">\</span><span class="hljs-string"> o      UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    </span>| o                      |<span class="hljs-string">           pages            </span>|<span class="hljs-string">     PDMAP                 </span>| o      UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    |<span class="hljs-string"></span><span class="hljs-string"> o                      </span>|<span class="hljs-string">           envs             </span>|<span class="hljs-string">     PDMAP                 </span>| o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |<span class="hljs-string"></span><span class="hljs-string"> o  UXSTACKTOP -/       </span>|<span class="hljs-string">     user exception stack   </span>|<span class="hljs-string">     BY2PG                 </span>| o                      +----------------------------+------------0x7f3f f000    |<span class="hljs-string"></span><span class="hljs-string"> o                      </span>|<span class="hljs-string">                            </span>|<span class="hljs-string">     BY2PG                 </span>| o      USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    |<span class="hljs-string"></span><span class="hljs-string"> o                      </span>|<span class="hljs-string">     normal user stack      </span>|<span class="hljs-string">     BY2PG                 </span>| o                      +----------------------------+------------0x7f3f d000    |<span class="hljs-string"></span><span class="hljs-string"> a                      </span>|<span class="hljs-string">                            </span>|<span class="hljs-string">                           </span>| a                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |<span class="hljs-string"></span><span class="hljs-string"> a                      .                            .                           </span>| a                      .                            .                         kuseg a                      .                            .                           |<span class="hljs-string"></span><span class="hljs-string"> a                      </span>|<span class="hljs-string">~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>|<span class="hljs-string">                           </span>| a                      |<span class="hljs-string">                            </span>|<span class="hljs-string">                           </span>| o       UTEXT   -----&gt; +----------------------------+------------0x0040 0000    |<span class="hljs-string"></span><span class="hljs-string"> o                      </span>|<span class="hljs-string">      reserved for COW      </span>|<span class="hljs-string">     BY2PG                 </span>| o       UCOW    -----&gt; +----------------------------+------------0x003f f000    |<span class="hljs-string"></span><span class="hljs-string"> o                      </span>|<span class="hljs-string">   reversed for temporary   </span>|<span class="hljs-string">     BY2PG                 </span>| o       UTEMP   -----&gt; +----------------------------+------------0x003f e000    |<span class="hljs-string"></span><span class="hljs-string"> o                      </span>|<span class="hljs-string">       invalid memory       </span>|<span class="hljs-string">                          \</span>|<span class="hljs-string">/</span><span class="hljs-string"> a     0 ------------&gt;  +----------------------------+ ----------------------------</span><span class="hljs-string"> o</span><span class="hljs-string">*/</span></code></pre></div><p>在发现了内核的正确位置后，我们只需要想办法让内核被加载到那里就可以了。<br>编译器在生成 ELF 文件时就已经记录了各节所需要被加载到的位置。最终的可执行文件实际上是由链接器产生的（它将多个目标文件链接 产生最终可执行文件）。因此，我们所需要做的，就是控制链接器的链接过程。</p><h3 id="Linker-Script">Linker Script</h3><p>Linker Script 中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置.<br>在链接过程中，目标文件被 看成节的集合，并使用节头表来描述各个节的组织。<br>换句话说，节记录了在链接过程中所需要的必要信息。<br>其中最为重要的三个节为.text、.data、.bss。<br>这三个节的意义是必须要掌握的：<br>.text 保存可执行文件的操作指令。<br>.data 保存已初始化的全局变量和静态变量。<br>.bss 保存未初始化的全局变量和静态变量。</p><p>这里比较简单,略过~</p><p>自此, 内核就成功被装在内存中了.</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA2022-CacheLab</title>
    <link href="/2022/11/16/BUAA2022-CacheLab/"/>
    <url>/2022/11/16/BUAA2022-CacheLab/</url>
    
    <content type="html"><![CDATA[<h1>CacheLab（附Excellent优化思路）</h1><h2 id="前言">前言</h2><p>因为这部分我感觉我学起来确实困难想不清楚，遂决定做个笔记整理一下。写着写着想到“干脆就发个博客和同学们交流一下吧”，因此这篇博客就产生了！没有放出所有的源代码，仅仅是提供一些思路上的梳理和帮助😀！</p><p>作者才疏学浅，若内容有误，还请多多批评指正！</p><h2 id="基础概念">基础概念</h2><h3 id="主存">主存</h3><p>考虑主存地址为n位的计算机系统，主存大小即2<sup>n</sup>字节。</p><p>以B = 2<sup>b</sup>作为一个块的大小来和cache进行数据传输。</p><p>此时任一地址可以表示为：</p><table><thead><tr><th>Block Number（n-b位）</th><th>Offset（b位）</th></tr></thead></table><p>举个例子，若主存（64位）中存放了两个int类型（4字节）的变量a,b，那么：</p><p><code>a：0x0000000000000000 -&gt; 0x0000000000000003</code></p><p><code>b：0x0000000000000004 -&gt; 0x0000000000000007</code></p><p>这里为了方便，我们把a，b十六进制的最后一位展开为二进制，其余位均为0，暂时忽略。</p><p><code>a：0000 -&gt; 0011</code></p><p><code>b：0100 -&gt; 0111</code></p><p>不难想到，为了正确的储存和传输a，b，这里的块的大小应该为4个字节（b=2），下同。</p><blockquote><p>值得注意的是b的大小是可以自己定的，因为取数就是地址+偏移，怎么都能取到！也可以让b=3把a，b放在一个块里传输，但是这样就避开了我想讲的东西了！</p></blockquote><p>此时，剩下的62位自然成为a，b的Block Number，a的Block Number为0，b的为1。</p><h3 id="Cache">Cache</h3><p>这时，我们引入一个Cache结构，包含S=2<sup>s</sup>个高速缓存组（set），每个组包含E个高速缓存行（line）。</p><p>特别地，这里我们考虑一个s=1，e=1的cache结构，包含2个组，每组一行。</p><p>我们希望达到两个效果：</p><p><strong>1.主存中同组的那些块仅能映射到Cache中对应组的那些行中</strong></p><p><strong>2.相邻的块能被分到不同的组</strong></p><p>因此，我们这样划分地址：</p><table><thead><tr><th>Tag（n-s-b位）</th><th>Set（s位）</th><th>Offset（b位）</th></tr></thead></table><p>引入int变量<code>c：0x0000000000000008 -&gt; 0x000000000000000b</code></p><p>最后四位：<code>1000 -&gt; 1011</code></p><p>我们利用a，b，c来观察这种划分有什么好处：</p><table><thead><tr><th>name</th><th>Tag（61位）</th><th>Set（1位）</th><th>Offset（2位）</th></tr></thead><tbody><tr><td>a</td><td>000…00</td><td>0</td><td>00 -&gt; 11</td></tr><tr><td>b</td><td>000…00</td><td>1</td><td>00 -&gt; 11</td></tr><tr><td>c</td><td>000…01</td><td>0</td><td>00 -&gt; 11</td></tr></tbody></table><p>可以看到，相邻的a，b不在同一组，而a，c在同一组，利用Tag来区分同一组内的不同块。</p><p>实际上，对于任意的一对（s，b）的地址划分都具备这样的性质。这样划分非常巧妙，我们不用引入任何新的变量来储存信息，只需要单纯地根据地址就可以完成信息的分组和编号。</p><p>而E代表cache内每一组能存放多少个block。主存中每两个block就有一个block属于第0组，这显然很多！属于同一组的block最多在cache中同时存在e个，否则就需要替换。</p><h3 id="替换策略">替换策略</h3><p>策略有很多，这里实现一个简单但是有效的。</p><p>LRU策略的实现：</p><ul><li>缓存的每一块都设置一个计数器，初始时均为0。</li><li>访问命中时，所有块的计数值与命中块的计数值进行比较，如果某块计数值小于命中块的计数值， 则该块的计数值加 1；如果该块的计数值大于命中块的计数值，则数值不变；最后将命中块的计数器清为0。</li><li>访问未命中，需要替换/装入时，则选择计数值最大的块被替换/装入，其计数器清为0，而其它的计数器则加1（除了初始装入之外，计数值是不会出现相等情况的，可以思考一下为什么）。</li><li>（照抄的指导书）</li></ul><h2 id="Part1-Cache模拟器">Part1-Cache模拟器</h2><p>实现一个Cache模拟器</p><p>这应该是一个较简单的部分，只要理解Cache的原理和构成就不难模拟。</p><h3 id="结构">结构</h3><p>-S=2<sup>s</sup>个组</p><p>​-每个组包含e列</p><p>​-每一列能够储存valid,Tag和Block信息</p><h3 id="方法">方法</h3><p>1.初始化</p><p>2.根据传入地址解析出必要信息，存取block</p><p>3.实现LRU替换策略</p><h3 id="解析">解析</h3><p>此外，解析指令也非常重要，推荐使用<code>getopt</code>来解析命令行参数，使用<code>fscanf(reader, &quot;%llx,%d&quot;, &amp;address, &amp;size)</code>来解析文件内指令！</p><h2 id="Part2-Cache友好的矩阵转置">Part2-Cache友好的矩阵转置</h2><h3 id="例子">例子</h3><blockquote><p>给定Cache结构<code>s=5,E=1,b=5</code>，编写一个实现32x32矩阵转置的C语言程序，使得miss数尽可能小。</p></blockquote><h4 id="1-首先理解矩阵在内存中怎么储存">1.首先理解矩阵在内存中怎么储存</h4><p>在b等于5的情况下，矩阵A[32][32]：</p><table><thead><tr><th>Set1</th><th>Set2</th><th>Set3</th><th>Set4</th></tr></thead><tbody><tr><td>Block0</td><td>Block1</td><td>Block2</td><td>Block3</td></tr><tr><td>A[0][0]-A[0][7]</td><td>A[0][8]-A[0][15]</td><td>A[0][16]-A[0][23]</td><td>A[0][24]-A[0][31]</td></tr></tbody></table><table><thead><tr><th>Set4</th><th>Set5</th><th>Set6</th><th>Set7</th></tr></thead><tbody><tr><td>Block4</td><td>Block5</td><td>Block6</td><td>Block7</td></tr><tr><td>A[1][0]-A[1][7]</td><td>A[1][8]-A[1][15]</td><td>A[1][16]-A[1][23]</td><td>A[1][24]-A[1][31]</td></tr></tbody></table><table><thead><tr><th>Set8</th><th>Set9</th><th>Set10</th><th>Set11</th></tr></thead><tbody><tr><td>Block8</td><td>Block9</td><td>Block10</td><td>Block11</td></tr><tr><td>A[2][0]-A[2][7]</td><td>A[2][8]-A[2][15]</td><td>A[2][16]-A[2][23]</td><td>A[2][24]-A[2][31]</td></tr></tbody></table><table><thead><tr><th>Set12</th><th>Set13</th><th>Set14</th><th>Set15</th></tr></thead><tbody><tr><td>Block12</td><td>Block13</td><td>Block14</td><td>Block15</td></tr><tr><td>A[3][0]-A[3][7]</td><td>A[3][8]-A[3][15]</td><td>A[3][16]-A[3][23]</td><td>A[3][24]-A[3][31]</td></tr></tbody></table><table><thead><tr><th>Set16</th><th>Set17</th><th>Set18</th><th>Set19</th></tr></thead><tbody><tr><td>Block16</td><td>Block17</td><td>Block18</td><td>Block19</td></tr><tr><td>A[4][0]-A[4][7]</td><td>A[4][8]-A[4][15]</td><td>A[4][16]-A[4][23]</td><td>A[4][24]-A[4][31]</td></tr></tbody></table><table><thead><tr><th>Set20</th><th>Set21</th><th>Set22</th><th>Set23</th></tr></thead><tbody><tr><td>Block20</td><td>Block21</td><td>Block22</td><td>Block23</td></tr><tr><td>A[5][0]-A[5][7]</td><td>A[5][8]-A[5][15]</td><td>A[5][16]-A[5][23]</td><td>A[5][24]-A[5][31]</td></tr></tbody></table><table><thead><tr><th>Set24</th><th>Set25</th><th>Set26</th><th>Set27</th></tr></thead><tbody><tr><td>Block24</td><td>Block25</td><td>Block26</td><td>Block27</td></tr><tr><td>A[6][0]-A[6][7]</td><td>A[6][8]-A[6][15]</td><td>A[6][16]-A[6][23]</td><td>A[6][24]-A[6][31]</td></tr></tbody></table><table><thead><tr><th>Set28</th><th>Set29</th><th>Set30</th><th>Set31</th></tr></thead><tbody><tr><td>Block28</td><td>Block29</td><td>Block30</td><td>Block31</td></tr><tr><td>A[7][0]-A[7][7]</td><td>A[7][8]-A[7][15]</td><td>A[7][16]-A[7][23]</td><td>A[7][24]-A[7][31]</td></tr></tbody></table><p>这里我只列出来了A[0][0] - A[7][31]这8*32个矩阵元素，之后还有3组这样的元素没有列出。s=5，cache中一共只有32个set，因此以后的3组元素的Set编号将会与以上相同，即Set0-31，因此，例如说，A[0][0]和A[8][0]两个数在Cache中将会因为相同的组编号而发生冲突（e=1）. 此外，如果要访问B的元素B[i][j]，因为题目中强调A和B的起始地址间隔保证了是Cache容量的整倍数，B[i][j]和A[i][j]也会发生冲突，即属于同一个组（Set）。</p><h4 id="2-优化原理">2.优化原理</h4><p>下面给出一个简单分析：</p><p>实现一个32x32的矩阵转置至少要两步：</p><p>1.将所有数从矩阵A里读出来</p><p>2.将所有取出来的数写进矩阵B</p><p>读和写都记一次内存访问，一个块可以存8个数，要获取一个块至少要miss一次（miss或者miss+eviction）</p><p>因此，最少的miss次数也要有 32x32x2/8 = 256次</p><p>为了实现这个miss次数，我们必须保证对于每个块都只访问一次！换言之，我们优化的任务也就是尽量减少对同一个块的反复访问！</p><h4 id="3-分块优化">3.分块优化</h4><p>考虑一个普通的矩阵转置函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//M=32 N=32</span><span class="hljs-type">void</span> <span class="hljs-title function_">trans</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span>&#123;    <span class="hljs-type">int</span> i, j;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;            B[j][i] = A[i][j];        &#125;    &#125;&#125;</code></pre></div><p>这样的访问不具有良好的空间局部性。</p><p>为什么？就只看程序开始的一小部分：</p><div class="code-wrapper"><pre><code class="hljs c">   i = <span class="hljs-number">0</span>: &#123;      <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) <span class="hljs-comment">//loop1</span>          B[j][i] = A[i][j];      <span class="hljs-keyword">for</span> (j = <span class="hljs-number">8</span>; j &lt; <span class="hljs-number">16</span>; j++) <span class="hljs-comment">//loop2</span>          B[j][i] = A[i][j];&#125;</code></pre></div><p>loop1中B[0-7][0]分别存放在8个块里，因此取这8个块分别访问，产生8个miss，紧接着loop2中的B[8-15][0]和B[0-7][0]组号相同，会把B[0-7][0]全部替换掉！loop1将这八个块都访问了，但是却都只利用了1/8！</p><p>不难想到一种分块方法，将32x32的矩阵分成16个8x8的子矩阵，把loop1访问的8个块充分利用了再替换成下8个块，从而减少miss数。下面实战一下！</p><h3 id="16X16矩阵">16X16矩阵</h3><h4 id="1-题目分析">1.题目分析</h4><p>题目中给的Cache结构是<code>s=4,E=1,b=5</code>，这和上面例子是不一样的！请注意。</p><p>同理，分析一下矩阵在内存中的排布。</p><table><thead><tr><th>Set0</th><th>Set1</th></tr></thead><tbody><tr><td>Block0</td><td>Block1</td></tr><tr><td>A[0][0]-A[0][7]</td><td>A[0][8]-A[0][15]</td></tr></tbody></table><table><thead><tr><th>Set2</th><th>Set3</th></tr></thead><tbody><tr><td>Block2</td><td>Block3</td></tr><tr><td>A[1][0]-A[1][7]</td><td>A[1][8]-A[1][15]</td></tr></tbody></table><table><thead><tr><th>Set4</th><th>Set5</th></tr></thead><tbody><tr><td>Block4</td><td>Block5</td></tr><tr><td>A[2][0]-A[2][7]</td><td>A[2][8]-A[2][15]</td></tr></tbody></table><table><thead><tr><th>Set6</th><th>Set7</th></tr></thead><tbody><tr><td>Block6</td><td>Block7</td></tr><tr><td>A[3][0]-A[3][7]</td><td>A[3][8]-A[3][15]</td></tr></tbody></table><table><thead><tr><th>Set8</th><th>Set9</th></tr></thead><tbody><tr><td>Block8</td><td>Block9</td></tr><tr><td>A[4][0]-A[4][7]</td><td>A[4][8]-A[4][15]</td></tr></tbody></table><table><thead><tr><th>Set10</th><th>Set11</th></tr></thead><tbody><tr><td>Block10</td><td>Block11</td></tr><tr><td>A[5][0]-A[5][7]</td><td>A[5][8]-A[5][15]</td></tr></tbody></table><table><thead><tr><th>Set12</th><th>Set13</th></tr></thead><tbody><tr><td>Block12</td><td>Block13</td></tr><tr><td>A[6][0]-A[6][7]</td><td>A[6][8]-A[6][15]</td></tr></tbody></table><table><thead><tr><th>Set14</th><th>Set15</th></tr></thead><tbody><tr><td>Block14</td><td>Block15</td></tr><tr><td>A[7][0]-A[7][7]</td><td>A[7][8]-A[7][15]</td></tr></tbody></table><p>同样的，我只列出来了A[0-7][0-15]的这部分，剩下一半的组编号与这一半完全相同。</p><p><strong>对于16x16矩阵我们该怎么分块？32x32是8x8，那么16x16是不是该分成4x4？什么是我们选择分块策略的决定性因素？</strong></p><p>如果你不知道这个问题的答案，那么我也没办法，<s>因为我也不知道</s>，但是我们可以从下面的做法中得到启发。</p><p>（如果有人研究出了公式请务必教教我，我感觉是可以推导的，但是我不会。。。）</p><h4 id="2-解法">2.解法</h4><p>首先确定目标： 16x16x2/8 = 64次，外加额外的3次miss（教程有说明），我们优化的极限是67次。</p><p>我们选取8x8的分块策略。</p><p>下面展示其中的一块：位置代表元素的位置，值代表元素所在组</p><table><thead><tr><th>Set</th><th>A[i]</th><th>[j]</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0-7</td></tr><tr><td>2</td><td>1</td><td>0-7</td></tr><tr><td>4</td><td>2</td><td>0-7</td></tr><tr><td>6</td><td>3</td><td>0-7</td></tr><tr><td>8</td><td>4</td><td>0-7</td></tr><tr><td>10</td><td>5</td><td>0-7</td></tr><tr><td>12</td><td>6</td><td>0-7</td></tr><tr><td>14</td><td>7</td><td>0-7</td></tr></tbody></table><p>对这一块进行充分利用：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">8</span>; k++)<span class="hljs-comment">//8x8的分块,k代表一个块的开始位置</span>&#123;    <span class="hljs-comment">//取A[k][0-7]会占用Cache的第 2k-2 组</span>    tmp0 = A[k][<span class="hljs-number">0</span>];    tmp1 = A[k][<span class="hljs-number">1</span>];    tmp2 = A[k][<span class="hljs-number">2</span>];    tmp3 = A[k][<span class="hljs-number">3</span>];    tmp4 = A[k][<span class="hljs-number">4</span>];    tmp5 = A[k][<span class="hljs-number">5</span>];    tmp6 = A[k][<span class="hljs-number">6</span>];    tmp7 = A[k][<span class="hljs-number">7</span>];    <span class="hljs-comment">//取B[0-7][k]占用Set全部偶数组</span>    B[<span class="hljs-number">0</span>][k] = tmp0;    B[<span class="hljs-number">1</span>][k] = tmp1;    B[<span class="hljs-number">2</span>][k] = tmp2;    B[<span class="hljs-number">3</span>][k] = tmp3;    B[<span class="hljs-number">4</span>][k] = tmp4;    B[<span class="hljs-number">5</span>][k] = tmp5;    B[<span class="hljs-number">6</span>][k] = tmp6;    B[<span class="hljs-number">7</span>][k] = tmp7;&#125;</code></pre></div><p>分析：对于每一个k，读取A造成一次miss。k=0时，读取B造成8次miss，k&gt;0时，由于读取A会挤占掉一个B的block，因此每个k会导致B重读一次，造成1次miss。</p><p>如果不算A,B相互替换而造成的miss数，A,B的block利用率均为100%，而相互排挤导致了8次额外的miss。这个块一共产生了8+7+8=23次miss。</p><p>那我们这样优化的结果是不是 24*4+3 = 99次呢？</p><p>还真不是，考虑以下情景：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">8</span>; k &lt; <span class="hljs-number">15</span>; k++)<span class="hljs-comment">//8x8的分块,k代表一个块的开始位置</span>&#123;    <span class="hljs-comment">//取A[k][0-7]会占用Cache的第 2k-2 组</span>    tmp0 = A[k][<span class="hljs-number">0</span>];    tmp1 = A[k][<span class="hljs-number">1</span>];    tmp2 = A[k][<span class="hljs-number">2</span>];    tmp3 = A[k][<span class="hljs-number">3</span>];    tmp4 = A[k][<span class="hljs-number">4</span>];    tmp5 = A[k][<span class="hljs-number">5</span>];    tmp6 = A[k][<span class="hljs-number">6</span>];    tmp7 = A[k][<span class="hljs-number">7</span>];    <span class="hljs-comment">//取B[0-7][k]占用Set全部奇数组</span>    B[<span class="hljs-number">0</span>][k] = tmp0;    B[<span class="hljs-number">1</span>][k] = tmp1;    B[<span class="hljs-number">2</span>][k] = tmp2;    B[<span class="hljs-number">3</span>][k] = tmp3;    B[<span class="hljs-number">4</span>][k] = tmp4;    B[<span class="hljs-number">5</span>][k] = tmp5;    B[<span class="hljs-number">6</span>][k] = tmp6;    B[<span class="hljs-number">7</span>][k] = tmp7;&#125;</code></pre></div><p>我们发现，这一块居然没有冲突！这一块只产生16个miss。</p><p>事实上，只有对角线上的块才会产生冲突，而别的块都没有这样的冲突！</p><p>因此，最后的miss数是： 23*2 + 16*2 +3 = 81！</p><p>这不就过了吗！</p><h4 id="3-Excellent优化思路">3.Excellent优化思路</h4><p>聪明如你一定已经知道怎么优化了！</p><p>不知道的话还是要自己多思考一下哦~</p><p>没错，对角线上的块会产生14次额外的miss，这是我们不能忍受的。</p><p>怎么才能避免A和B的冲突？一个解决方案是开64个临时变量，将A的数据全部读取暂存，再全部放入B中。</p><p>很显然，上面只是我说着玩的，因为限制了只能有12个临时变量，那该怎么办呢？</p><p>没错，用B来暂存一下。寄存器有限，但是B我们可以随意更改呀~</p><p>核心思想是先暂存在B里，等A的下一行的元素访问完了再转置。</p><p>愿意写的自己写写吧,可以达到理论最优67个。</p><h3 id="32X32矩阵">32X32矩阵</h3><h4 id="1-解法">1.解法</h4><p>都写到这里了，我也懒得再画一遍内存图了，大家自己画一画就好了。基本的思想和之前还是一模一样的！</p><p>唯一不同于16x16的是，我们发现如果8x8分块的话，不仅A,B之间有冲突，甚至就连A,B内部上四行和下四行都有冲突！</p><p>难道要用4x4？不行，4x4引入新问题：一个block有8个数，你都只用4个，那miss率不得上天去了！</p><p>因此我们想要结合两者的优点：使用8x8的分块，但是在内部以4x4为单位操作，先完全操作上半4x8，再操作下半。</p><blockquote><p>提示：在考虑能不能AC而不是Excellent时，应先不要考虑A1A2 和B1B2的冲突，而是着眼于A1A2 和A3A4的冲突</p><p>因为只有对角线块会产生A,B之间的冲突，而每个块A1A2 和 A3A4都是冲突的！</p></blockquote><p>如果把一个8x8的块分为4份：</p><table><thead><tr><th><strong>A1</strong></th><th><strong>A2</strong></th></tr></thead><tbody><tr><td><strong>A3</strong></td><td><strong>A4</strong></td></tr></tbody></table><p>块内的操作可以分成以下步骤:</p><ul><li>步骤一<ul><li>将A1, A2数据复制给B1, B2</li></ul></li><li>步骤二<ul><li>将A3的数据传给B2，同时，B2的数据传给B3（这里注意如何利用8个临时变量来保证不会产生额外的miss，这个比较tricky）</li></ul></li><li>步骤三<ul><li>将A4复制给B4</li></ul></li></ul><p>代码就自己写啦~</p><h4 id="2-miss分析">2.miss分析</h4><p>非对角线块只有上下冲突，我们已经解决了，因此只有16个miss！还是很牛的！</p><p>但是还有4大个对角线块，我们没有做任何优化，因此每个对角线块都会额外产生19个miss！恁多！</p><p>幸运的是，即便如此，总miss仍然小于400！过了！！那要不然就不优化了吧。</p><h4 id="3-Excellent优化思路-2"><strong>3.Excellent优化思路</strong></h4><p>不行，就是要优化！</p><p>同样的，优化的思路就是去尝试解决对角线块的冲突问题。</p><p>我的想法很简单，块内有3个操作步骤，每一步都可以当做独立的一部分进行优化（就像16x16矩阵中的那样）</p><p>但是我没办法优化优化到理论最优解，作业太多，遂放弃。</p><p>具体就不细讲了，感兴趣的自己可以研究一下。</p><p>补：</p><p><strong>我找到一篇文章，里面的思路可以把这道题优化到理论最优解259次（只能膜了，非常巧妙）</strong></p><p><strong><a href="https://zhuanlan.zhihu.com/p/387662272">https://zhuanlan.zhihu.com/p/387662272</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
      <tag>Cache</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MediaPipe扫盲</title>
    <link href="/2022/11/09/MediaPipe%E6%89%AB%E7%9B%B2/"/>
    <url>/2022/11/09/MediaPipe%E6%89%AB%E7%9B%B2/</url>
    
    <content type="html"><![CDATA[<h1>MediaPipe</h1><h2 id="1-简介">1.简介</h2><h3 id="1-1-什么是MediaPipe">1.1 什么是MediaPipe</h3><div class="note note-primary">            <p>MediaPipe is a project by Google that offers “open-source, cross-platform, customizable ML solutions for live and streaming media”. In other words, MediaPipe provides access to a wide variety of powerful Machine Learning models <strong>built with the hardware limitations of mobile devices in mind</strong>.</p>          </div><p>简而言之，MediaPipe相当于帮我们把轮子造好了，如果你想在你的项目里新添加一个轻度但是高效的CV功能，那么就可以选用MediaPipe。</p><h3 id="1-2-链接指路：">1.2 链接指路：</h3><p>非常适合入门👉<a href="https://www.assemblyai.com/blog/mediapipe-for-dummies/">MediaPipe for Dummies</a></p><h2 id="2-MediaPipe的安装">2.MediaPipe的安装</h2><h3 id="2-1-前置知识">2.1 前置知识</h3><p>…等待填坑</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MediaPipe</tag>
      
      <tag>ML</tag>
      
      <tag>Python</tag>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA的数据库和Lucene扫盲</title>
    <link href="/2022/11/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CLucence%E6%89%AB%E7%9B%B2/"/>
    <url>/2022/11/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CLucence%E6%89%AB%E7%9B%B2/</url>
    
    <content type="html"><![CDATA[<h1>数据库基础知识</h1><blockquote><p>这是当年还没学数据库的时候做项目进行的一个资源整理, 内容比较基础.</p></blockquote><h2 id="一、数据库概述">一、数据库概述</h2><h3 id="1-什么是数据库"><strong>1.什么是数据库</strong></h3><p>数据库就是存储数据的仓库，其本质是一个文件系统，数据按照特定的格式将数据存储起来，用户可以对数据库中的数据进行增加，修改，删除及查询操作。</p><h3 id="2-什么是数据库管理系统"><strong>2.什么是数据库管理系统</strong></h3><p>数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，<strong>用于建立、使用和维护数据库</strong>，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。</p><h3 id="3-数据库的特点">3.数据库的特点</h3><p>数据库的特点是：实现数据共享，减少数据冗余；采用特定的数据类型；具有较高的数据独立性；具有统一的数据控制功能。</p><h3 id="4-常见的数据库管理系统">4.常见的数据库管理系统</h3><blockquote><p><strong>MYSQL</strong>：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。</p><p>Oracle：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。</p><p>SQLite：嵌入式的小型数据库，应用在手机端。</p></blockquote><p>Java相关的数据库：MYSQL，Oracle．本篇博客的主角是MySQL数据库。MySQL中可以有多个数据库，数据库中的<strong>表</strong>是真正存储数据的地方。</p><h2 id="二、数据库原理">二、数据库原理</h2><h3 id="1-数据库中的表是什么">1.数据库中的表是什么</h3><p>在关系数据库中，<strong>数据库表是一系列二维数组的集合</strong>，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成。</p><p><strong>行被称为记录</strong>，是组织数据的单位；</p><p><strong>列被称为字段</strong>，每一列表示记录的一个属性，有相应的描述信息，如数据类型、数据宽度等。</p><blockquote><p>主键<code>（Primary Key）</code>又称主码，用于唯一的标识表中的每一条记录。可以定义表中的一列或多列为主键，主键列上<strong>既不能有两行相同的值，也不能为空值</strong>。</p></blockquote><img src="https://s3.bmp.ovh/imgs/2022/11/07/5510bd24ae7b4b48.png" style="zoom:50%;" /><p>这就是一个表，其中ID是主键，用于确定唯一的索引。通过无数索引表和存放信息的表，构成了数据库。</p><h3 id="2-数据库中的数据类型是什么">2.数据库中的数据类型是什么</h3><p>数据类型决定了数据在计算机中的存储格式，代表不同的信息类型。常用的数据类型有整数数据类型、浮点数数据类型、精确小数类型、二进制数据类型、日期/时间数据类型、字符串数据类型。</p><h3 id="3-数据库的技术组成">3.数据库的技术组成</h3><p>数据库系统由硬件部分和软件部分共同构成。</p><p>硬件主要用于存储数据库中的数据，包括计算机、存储设备等。</p><p>软件部分主要包括DBMS、支持DBMS运行的操作系统，以及支持多种语言进行应用开发的访问技术等。</p><h3 id="4-sql语言">4.sql语言</h3><p>一种低代码语言</p><p>（1）数据定义语言<code>（DDL）</code>：<code>DROP</code>、<code>CREATE</code>、<code>ALTER</code>等语句。</p><p>（2）数据操作语言<code>（DML）</code>：<code>INSERT</code>（插入）、<code>UPDATE</code>（修改）、<code>DELETE</code>（删除）语句。</p><p>（3）数据查询语言<code>（DQL）</code>：<code>SELECT</code>语句。</p><p>（4）数据控制语言<code>（DCL）</code>：<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>等语句。</p><p>例如我们使用<code>CREATE</code>来创建一个表；</p><div class="code-wrapper"><pre><code class="hljs text">CREATE TABLE YUNWEIJIA ( ID INT UNSIGNED, NAME VARCHAR ( 30 ), PRIMARY KEY ( ID ) );</code></pre></div><p>以上命令的意思是说，创建一个名字叫<code>YUNWEIJIA</code>的表，里面有两个字段，分别是<code>ID </code>和<code>NAME</code>，其中<code>ID</code>是主键，<code>NAME</code>的长度不能超过30；</p><p>下面我们在这个新建的表中插入一条数据；</p><div class="code-wrapper"><pre><code class="hljs text">INSERT INTO YUNWEIJIA ( ID, NAME )VALUES( &#x27;1&#x27;, &#x27;weixin&#x27; );</code></pre></div><p>然后我们的数据库中就插入了一条数据；</p><p>再用<code>SELECT</code>来查看下这个数据库中的内容；</p><div class="code-wrapper"><pre><code class="hljs text">SELECT ID, NAME FROM YUNWEIJIA WHERE ID = &#x27;1&#x27;;</code></pre></div><h3 id="5、数据库访问接口">5、数据库访问接口</h3><p>不同的程序设计语言会有各自不同的数据库访问接口，程序语言通过这些接口执行<code>SQL</code>语句，进行数据库管理。主要的数据库访问接口有<code>ODBC</code>、<code>JDBC</code>、<code>ADO.NET</code>和<code>PDO</code>。</p><p><code>JDBC（Java Data Base Connectivity，Java数据库连接）</code>用于Java应用程序连接数据库的标准方法，是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，由一组用Java语言编写的类和接口组成。</p><blockquote><p>相当于Mysql是一个数据库，用于存放数据，JAVA使用JDBC提供的一系列方法和接口在数据库中存、取和检索数据。</p></blockquote><h3 id="6-数据库系统的组成部分是什么">6.数据库系统的组成部分是什么</h3><h4 id="数据库——文件">数据库——文件</h4><p>一个数据库可能包含许多<strong>文件</strong>，一个数据库系统中通常包含许多数据库。</p><h4 id="数据库管理系统（DBMS）——操作系统">数据库管理系统（DBMS）——操作系统</h4><p>是用户创建、管理和维护数据库时所使用的软件，位于用户与操作系统之间，对数据库进行统一管理。<code>DBMS</code>能定义数据存储结构，提供数据的操作机制，维护数据库的安全性、完整性和可靠性。</p><h4 id="数据库应用程序——提供使用的图形界面">数据库应用程序——提供使用的图形界面</h4><p>数据库应用程序的使用可以满足对数据管理的更高要求，还可以使数据管理过程更加直观和友好。数据库应用程序负责与<code>DBMS</code>进行通信，访问和管理<code>DBMS</code>中存储的数据，允许用户插入、修改、删除DB中的数据。</p><h3 id="7-了解mysql">7.了解mysql</h3><p><code>MySQL</code>是一个小型关系数据库管理系统。与其他大型数据库管理系统（例如<code>Oracle</code>、<code>DB2</code>、<code>SQL Server</code>等）相比，<code>MySQL</code>规模小、功能有限，但是它体积小、速度快、成本低，并且提供的功能对稍微复杂的应用来说已经够用，这些特性使得<code>MySQL</code>成为世界上最受欢迎的开放源代码数据库。</p><h2 id="附：阅读资料">附：阅读资料</h2><p><a href="https://zhuanlan.zhihu.com/p/534735100">mysql数据库扫盲，你真的知道什么是数据库嘛</a></p><p><a href="https://www.cnblogs.com/yinzhengjie/p/11732882.html">MySQL数据库扫盲篇</a></p><p><a href="https://blog.csdn.net/weixin_34019144/article/details/94659251">Java基础-MySQL数据库扫盲篇</a></p><h1>什么是Lucene</h1><h3 id="1-Lucene简介">1.Lucene简介</h3><p>Lucene是apache软件基金会发布的一个开放源代码的全文检索引擎工具包，由资深全文检索专家Doug Cutting所撰写,它是一个<strong>全文检索引擎的架构</strong>，提供了完整的创建索引和查询索引，以及部分文本分析的引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎，Lucene在全文检索领域是一个经典的祖先，现在很多检索引擎都是在其基础上创建的，思想是相通的。</p><h3 id="2-Lucene的生态位">2.Lucene的生态位</h3><p>下面的文字画表现了Lucene最基本的原理：</p><p>​      传输       处理       查找</p><p>文本源 --&gt; Lucene --&gt; 索引表 &lt;-- 上级</p><p>因此，既可以只用Lucene，也可以使用数据库，再将数据传送给Lucene进行处理，形成索引，最后提供查询的接口。</p><h3 id="3-Lucene的基本知识">3.Lucene的基本知识</h3><h4 id="3-1-Basic-Concepts">3.1 Basic Concepts</h4><p>The content you add to Lucene can be from various sources, like a SQL/NoSQL database, a filesystem, or even from websites.</p><h4 id="3-2-Searching-and-Indexing">3.2 Searching and Indexing</h4><p>Lucene is able to achieve fast search responses because, instead of searching the text directly, it searches an index instead.</p><p>This type of index is called an <strong>inverted index</strong>, because it inverts a page-centric data structure (page-&gt;words) to a keyword-centric data structure (word-&gt;pages).</p><h4 id="3-3-Documents">3.3 Documents</h4><p>In Lucene, a <strong>Document</strong> is the unit of search and index.</p><p>An index consists of one or more Documents.</p><p><strong>Indexing involves adding Documents to an IndexWriter, and searching involves retrieving Documents from an index via an IndexSearcher.</strong></p><p>A Lucene Document doesn’t necessarily have to be a document in the common English usage of the word.</p><h4 id="3-4-Fields">3.4 Fields</h4><p><strong>A Document consists of one or more Fields.</strong></p><p>A Field is simply a name-value pair.</p><p>Indexing in Lucene thus involves creating Documents comprising of one or more Fields, and adding these Documents to an IndexWriter.</p><h4 id="3-5-Searching">3.5 Searching</h4><p>Searching requires an index to have already been built. It involves creating a <strong>Query</strong> (usually via a QueryParser) and handing this Query to an <strong>IndexSearcher</strong>, which returns a list of Hits.</p><h4 id="3-5-Queries">3.5 Queries</h4><p>The Lucene query language allows the user to specify which field(s) to search on, which fields to give more weight to (boosting), the ability to perform boolean queries (AND, OR, NOT) and other functionality.</p><h2 id="附：阅读资料-2">附：阅读资料</h2><p>最基础👉<a href="https://www.lucenetutorial.com/">lucenetutorial</a></p><p>进一步（代码部分已过时）👉<a href="https://juejin.cn/post/6844903577467502606#heading-1">Lucene就是这么简单</a></p><p>进一步👉<a href="https://www.baeldung.com/lucene">Introduction to Apache Lucene</a></p><p>😮最完美👉<a href="https://github.com/jiepujiang/LuceneTutorial">LuceneTutorial</a></p><p>有深度👉<a href="https://juejin.cn/post/6986812836445945864">深度解析 Lucene 轻量级全文索引实现原理</a></p><p>lucene为什么比mysql更适合全文查找👉<a href="https://www.cnblogs.com/luxiaoxun/p/5452502.html">MySQL和Lucene索引对比分析</a></p><h1>JAVA和数据库的连接</h1><h3 id="1-基本流程">1.基本流程</h3><p>上文提到了JDBC，这是一个统一规范的接口，无论使用的是MYSQL、Oracle还是别的什么数据库，都使用JDBC与JAVA传输数据。</p><p>通过JDBC可以从数据库中提取出数据，再经过程序员封装，就可以得到可以直接使用的数据接口！</p><h2 id="附：阅读资料-3">附：阅读资料</h2><p>最基础👉<a href="https://www.runoob.com/java/java-mysql-connect.html">Java MySQL 连接</a></p><p>结合MVC架构👉<a href="https://www.cnblogs.com/Qian123/p/5339164.html">Java数据库连接——JDBC基础知识（操作数据库：增删改查）</a></p><p>DAO层的选择👉<a href="https://cloud.tencent.com/developer/article/1822267">盘点 Java 数据库访问框架——究竟哪个更适合你</a></p><h1>数据库和Lucene的连接</h1><h3 id="1-基本流程-2">1.基本流程</h3><p>上文提到了Lucene可以看作数据库的索引引擎，因此，可以用数据库来存文件，然后用Lucene进行索引；</p><p>同时，如果不需要用数据库进行文档管理，只用本地的文件系统也是可以的。</p><h3 id="2-问题">2.问题</h3><h4 id="存文件的形式">存文件的形式</h4><p>PDF，文本？怎么提取出内容？</p><h2 id="附：阅读资料-4">附：阅读资料</h2><p>有Lucene和数据库结合的部分👉<a href="https://blog.csdn.net/fun913510024/category_3732945.html">lucene教程</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>数据库</tag>
      
      <tag>MySql</tag>
      
      <tag>Lucence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过Idea和Github协同Java项目</title>
    <link href="/2022/11/06/%E9%80%9A%E8%BF%87Idea%E5%92%8CGithub%E5%8D%8F%E5%90%8CJava%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/11/06/%E9%80%9A%E8%BF%87Idea%E5%92%8CGithub%E5%8D%8F%E5%90%8CJava%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1>通过Idea和Github协同Java项目</h1><blockquote><p>注：本文链接教程是我觉得说得比较清楚的教程，可以做一个参考，也可以根据关键词自己搜一搜😀</p></blockquote><h2 id="0-基本概念">0.基本概念</h2><p>本文主要是介绍大体的框架，具体的细节可以在网上自己找教程，我自己也写不好！</p><p>下面是一些扫盲，如果了解跳过就可以了！</p><p>👉<a href="https://www.cnblogs.com/lukelook/p/11220807.html">git与github区别与简介</a></p><p>👉<a href="https://www.githubs.cn/post/what-is-github">Github是什么，有什么用？</a></p><p>👉<a href="https://juejin.cn/post/6978028827431665678">请收下这篇 Git 扫盲手册</a></p><blockquote><p>Idea为git的操作提供了图形化界面，因此其实（暂时）不用去学那些git命令，只要知道一些基础含义就好了：</p><p><code>clone</code>：将远程仓库下载到本地</p><p><code>add</code>：把工作区的文件提交到暂存区，是提交文件的第一步（似乎在idea上这步存在感不强，直接commit得了）</p><p><code>commit</code>：把工作区的文件提交到git仓库，提交文件的第二步</p><p><code>push</code>：把git仓库里的文件推送到远程仓库</p><p><code>pull</code>：把远程仓库的最新代码拉取到本地并合并</p><p><code>branch</code>：分支</p><p><code>checkout</code>：切换分支</p><p><code>merge</code>：合并代码</p></blockquote><h2 id="1-整体流程：">1.整体流程：</h2><h3 id="组织人">组织人</h3><ol><li>在GitHub上创建<em>组织</em>(github organization)</li><li>在IDEA上创建项目，并上传到Github仓库</li><li>将项目仓库关联组织</li><li>授权组员</li><li>管理项目的迭代和合并</li></ol><h3 id="所有人">所有人</h3><ol><li><p>注册Github账号</p></li><li><p><strong>下载Git，完成Idea，Git，Github之间的配置</strong></p><blockquote><p>可以跟着教程自己建一个仓库同步一下试试，后面协同新建仓库就是了</p></blockquote><p>👉<a href="https://www.jianshu.com/p/d5366a54a0fd">IntelliJ IDEA连接Github</a></p><p>👉<a href="https://cloud.tencent.com/developer/article/2023329">IDEA + Github，打造你的协同开发环境</a></p></li><li><p>加入组织，可以看到组织仓库了🎊</p></li><li><p>使用组织中的仓库协同开发</p></li></ol><h2 id="2-协同开发流程">2.协同开发流程</h2><h3 id="分支概念的理解">分支概念的理解</h3><ul><li><p>分支的创建相当于将本地仓库的代码完全复制一份，这时在分支上开发，然后合并到master分支。</p><p>这个时候就有问题了，<strong>分支上开发再合并到主分支和直接在主分支开发有什么区别？</strong></p></li><li><p>这个问题问的好！</p></li><li><p>以本人拙见：<br><strong>有冲突在自己本地就能解决，解决好了再上传到远程仓库。</strong></p></li><li><p>而在本地直接在master分支开发的话，没有合并分支的概念。冲突问题我觉的是一大难题，而且分支可以在任何时候都可以创建，可以随时退回到任何一个版本，很容易回到你想保存的代码版本。</p></li><li><p>所以在组员开发项目的同时，需要遵循一下操作。那么可以避免很多麻烦。</p></li></ul><h3 id="具体操作">具体操作</h3><ol><li><p>先从远程仓库pull得到<code>master</code>分支；</p></li><li><p>在本地新建本地分支——这里取名叫<code>branch1</code>分支；</p></li><li><p>在<code>branch1</code>分支做开发，commit到本地</p></li><li><p>开发完切换到<code>master</code>分支，再从远程仓库pull下来新的<code>master</code>分支</p><blockquote><p>此时的<code>master</code>因为其他人的提交已经和你之前下载的不一样了，因此需要重新下载（pull）</p></blockquote></li><li><p>在<code>master</code>分支内<em>合并</em>(merge)你本地写的<code>branch1</code></p><blockquote><p>此时，<code>master</code>分支有其他人新写的代码，<code>branch1</code>有你新写的代码，因此有可能出现冲突！</p><p>出现冲突时就不能一键merge了，需要你自己选择如何整合冲突的地方！</p><p>本地merge的优势：不管你怎么作死，都不会影响到你已经写好并且commit的<code>branch1</code>，也不会影响云端的<code>master</code>，因此不会有后果！</p><p>(切换分支前一定要commit已经写好的代码，否则即使Ctrl+S保存过代码也会丢失！！！我丢过一次SCS！！！！)</p></blockquote></li><li><p>确定无误提交到云端的<code>master</code>,进度+1.</p></li></ol><h3 id="原则">原则</h3><p>4个人的工作尽量解耦，互不打扰的开发是最好的！最好不要出现一个人的工作必须等另一个人，可以预留接口！</p><p>不过因为工作量小且人数少，我觉得我们倒是可以一定程度上牺牲管理换时间。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>协同</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法之接口</title>
    <link href="/2022/09/16/Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/09/16/Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1>接口是什么</h1><p>Java接口（interface）是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p><h1>接口的特点</h1><ol><li>接口中的每个方法都是隐式抽象的，接口中的方法会被隐式的指定为public abstract</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为public static <a href="https://blog.csdn.net/jiahao1186/article/details/121888509">final</a>变量</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法</li></ol><h1>接口和类的区别</h1><ol><li>接口不能实例化</li><li>接口没有构造方法</li><li>接口中所有的方法必须是抽象方法，Java8之后可以使用<a href="https://blog.csdn.net/lilian9215/article/details/119721637">default</a>关键字修饰非抽象方法</li><li>接口不能包含成员变量，除了static和final变量</li><li>接口支持多实现（相当于C++中的多重继承）</li></ol><h1>接口和抽象类的区别</h1><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不能有方法体</li><li>抽象类中的成员变量可以使各种类型的，而接口中的成员变量只能是public static final类型的。</li><li>接口中不能含有静态代码块以及静态方法，而抽象类中可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类可以实现多个接口。</li></ol><h1>接口的声明</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyComparable</span>&#123;         <span class="hljs-type">int</span> <span class="hljs-title function_">comparTo</span><span class="hljs-params">(Object other)</span>;</code></pre></div><p>使用intrface关键字。</p><h1>接口的实现：implement</h1><p>extends 继承类；implements 实现接口。</p><p>相当于对于某个接口的实现了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>JAVA</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java语法之注解</title>
    <link href="/2022/09/16/Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/09/16/Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1>什么是注解</h1><p>Java注解又称Java标注，是在 JDK5 时引入的新特性，注解（也被称为元数据）。</p><p>Java注解它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（meta-data）与程序元素（类、方法、成员变量等）进行关联。</p><p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。</p><h1>注解的分类</h1><h2 id="1-标准注解">1.标准注解</h2><p>包括<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>等，使用这些注解后编译器就会进行检查。</p><h3 id="1-1-Override">1.1 @Override</h3><p>如果试图使用 @Override 标记一个实际上并没有覆写父类对应方法的子类方法时，Java 编译器会Warning。</p><h3 id="1-2-Deprecated">1.2 @Deprecated</h3><p>@Deprecated 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</p><h3 id="1-3-SuppressWarnings">1.3 @SuppressWarnings</h3><p>@SuppressWarnings 用于关闭对类、方法、成员编译时产生的特定警告。</p><p>这个注解的使用方法还比较复杂，建议想使用的话可以特意上网搜搜，这里不再赘述！</p><h3 id="1-4-更多">1.4 更多</h3><p>Java自带了很多注解，但是一般来说在初级开发中使用的较少，如有需要，专门去查看即可。</p><h2 id="2-元注解">2.元注解</h2><p>元注解是Java API提供的，是用于修饰注解的注解，通常用在注解的定义上。</p><p>常见的元注解及其含义如图所示：</p><img src="https://s3.bmp.ovh/imgs/2022/09/16/3c6372b7482496a6.png"  /><h2 id="3-自定义注解">3.自定义注解</h2><p>了解不多，以后用到再回来补充吧！反正是很高级的东西！</p><h1>Lombok</h1><p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注解，用来消除Java类中的大量样板代码。比如使用@Data就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p><h2 id="Data">@Data</h2><p>@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集</p><p>添加@Data注解后可以不用再写</p><ul><li>getter,setter方法,</li><li>toString方法</li><li>hashCode方法</li><li>equals方法<br>等等</li></ul><p>最后链接一个Lombok@Data的官方文档：<a href="https://projectlombok.org/features/Data">点我</a></p><p>参考：<a href="https://blog.csdn.net/weixin_68320784/article/details/126365775">Java注解最全详解(超级详细)</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>JAVA</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java深拷贝的实现方式</title>
    <link href="/2022/09/16/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/09/16/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>​阅读本文前，首先要清楚地了解JAVA深浅拷贝的含义以及区别，如果没有这个基础的话，还是先了解一下比较好，本文不再赘述。</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/16/31c1977863592194.png" alt=""></p><p>（在CSDN上找到的网图）</p><h1>前置知识</h1><p>为什么我要写这篇博客呢？因为网上的博客实在是太参差不齐了，里面用到了很多我根本不知道的语法知识，所以在这里先科普一下！</p><h2 id="注解（Annotation）">注解（Annotation）</h2><p>举个例子吧：<code>@Data</code>就是一个注解。</p><p>想知道注解是干什么的吗？移步我另一个博客——&gt;<a href="https://pcpas.github.io/2022/09/16/Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%B3%A8%E8%A7%A3/">点这儿</a>。</p><h2 id="接口（interface）和实现（implement）">接口（interface）和实现（implement）</h2><p>移步我另一个博客——&gt;<a href="https://pcpas.github.io/2022/09/16/Java%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%8E%A5%E5%8F%A3/">点这儿</a>。</p><h2 id="接口：Cloneable">接口：Cloneable</h2><p>Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。</p><p>要让对象可以被克隆，应具备以下2个条件：</p><ul><li><p>让该类实现java.lang.Cloneable接口；</p></li><li><p>重写（Override）Object的clone()方法；（如果不重写的话就默认使用最基础的）</p><p>关于为什么一定要重写：在Java中，深拷贝和浅拷贝是一件很重要的事，即使你想要使用浅拷贝，你也必须重写，因为这让别人（和你自己）了解你的真实意图。</p></li></ul><h2 id="接口：Serializable">接口：Serializable</h2><p>Serializable接口位于java.io.Serializable包中，一般在创建实体类的时候会去实现这个接口，目的是为了序列化。</p><h2 id="指针：Super">指针：Super</h2><h1>具体实现</h1><p>先看一段代码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> String gender;    <span class="hljs-keyword">private</span> EducationInfo educationInfo;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, Integer age, String gender, String school, String time)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.age = age;        <span class="hljs-built_in">this</span>.gender = gender;        <span class="hljs-built_in">this</span>.educationInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EducationInfo</span>(school, time);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EducationInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>*/&#123;    <span class="hljs-keyword">private</span> String school;    <span class="hljs-keyword">private</span> String time;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();    &#125;&#125;</code></pre></div><p>此时，我们实现的是浅拷贝。</p><p>实现深拷贝的三种方式：</p><p>第一种方式：直接通过 new 对象创建新的对象，通过 new 出来的对象肯定是在内存中重新开辟一块空间存储所以可以实现深拷贝；</p><p>第二种方式：通过调用父类clone再进行重新复制，虽然调用父类 Native 修饰的 clone 方法比第一种方式速度快，此步骤如果继承类中有多个引用类型克隆相对麻烦；</p><p>//笔者完全不理解第二种方法的原理，但是时间不够了，以后再看。</p><p>第三种方式：通过序列化和反序列化使用流进行深拷贝（注意类都要实现 Serializable 接口），因为保存在流中的数据相当于新的，若要实现对象深拷贝，推荐使用此方式。</p><p>我们对前面的Worker进行一些改造:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> Cloneable&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> String gender;    <span class="hljs-keyword">private</span> EducationInfo educationInfo;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, Integer age, String gender, String school, String time)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.age = age;        <span class="hljs-built_in">this</span>.gender = gender;        <span class="hljs-built_in">this</span>.educationInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EducationInfo</span>(school, time);    &#125;    <span class="hljs-comment">//    @Override</span><span class="hljs-comment">//    public Object clone() &#123;</span><span class="hljs-comment">//</span><span class="hljs-comment">//        // 第一种方式：直接通过new对象创建新的对象</span>        <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(                name, age, gender, educationInfo.getSchool(), educationInfo.getTime()        );        <span class="hljs-keyword">return</span> worker;<span class="hljs-comment">//</span><span class="hljs-comment">//        // 第二种方式：通过父类clone再进行赋值</span><span class="hljs-comment">//        try &#123;</span><span class="hljs-comment">//            Worker worker = (Worker) super.clone();</span><span class="hljs-comment">//            worker.educationInfo = (EducationInfo) educationInfo.clone();</span><span class="hljs-comment">//            return worker;</span><span class="hljs-comment">//        &#125; catch (CloneNotSupportedException ex) &#123;</span><span class="hljs-comment">//            return null;</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//    &#125;</span><span class="hljs-comment">//         推荐第三种方式：通过序列化和反序列化使用流进行深拷贝，注意类都要实现Serializable接口</span>    <span class="hljs-keyword">public</span> Worker <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(baos);            oos.writeObject(<span class="hljs-built_in">this</span>);            <span class="hljs-comment">// 将流序列化成对象</span>            <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(baos.toByteArray());            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bais);            worker = (Worker) ois.readObject();        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> worker;    &#125;&#125;</code></pre></div><p>指路：<a href="https://blog.csdn.net/qq_19244927/article/details/115422770">理解Java对象浅拷贝和深拷贝以及实现深拷贝的三种方式</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>JAVA</tag>
      
      <tag>深拷贝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyRenderer 8&amp;9</title>
    <link href="/2022/09/06/TinyRenderer-8-9/"/>
    <url>/2022/09/06/TinyRenderer-8-9/</url>
    
    <content type="html"><![CDATA[<h1>Lesson 8: Ambient occlusion</h1><h2 id="前言">前言</h2><p>在之前的学习中，我们了解了计算光照的常用方法，如Phong的光照模型。</p><p>这种光照模型是局部(Local)的——换而言之，我们在计算一个地方的光照时，并没有考虑其旁边的物体对其的影响！</p><p>在Phong模型中， 光照 = （const）Ambient + diffuse + specular</p><p><em>为什么ambient要是const的呢？</em></p><h2 id="ambient-occlusion（环境光遮蔽）">ambient occlusion（环境光遮蔽）</h2><p>与局部光照（local illumination）相对应的是全局光照（global illumination）。</p><p>显然，设定一个不变量作为环境光大小的前提条件是光线均匀而完美的照亮了每一个面，这样强的前提条件在现实中是不可能存在的，不是吗？</p><p>在过去，计算机性能还不是很好的时候，我们这么做可以节省许多性能，但是，是时候增加一点开销来换取更好的效果了！</p><img src="https://s3.bmp.ovh/imgs/2022/09/06/f0487626549762c1.jpg" style="zoom:50%;" /><p>（这是一个<em>只考虑了环境光</em>的模型，显然，图中每个面的环境光都不一样，效果自然也不一样。）</p><h2 id="Brute-force-attempt">Brute force attempt</h2><p>首先，作者为我们介绍了一种比较粗暴的方法，接下来我来简要的说明一下这种方法的思路：</p><p>1.在一个半球（hemisphere）上随机生成若干光源</p><p>（不可以仅仅是随机的选取经度和纬度：这样生成的点会集中在极点附近）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">rand_point_on_unit_sphere</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">float</span> u = (<span class="hljs-type">float</span>)<span class="hljs-built_in">rand</span>()/(<span class="hljs-type">float</span>)RAND_MAX;    <span class="hljs-type">float</span> v = (<span class="hljs-type">float</span>)<span class="hljs-built_in">rand</span>()/(<span class="hljs-type">float</span>)RAND_MAX;    <span class="hljs-type">float</span> theta = <span class="hljs-number">2.f</span>*M_PI*u;    <span class="hljs-type">float</span> phi   = <span class="hljs-built_in">acos</span>(<span class="hljs-number">2.f</span>*v - <span class="hljs-number">1.f</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-built_in">sin</span>(phi)*<span class="hljs-built_in">cos</span>(theta), <span class="hljs-built_in">sin</span>(phi)*<span class="hljs-built_in">sin</span>(theta), <span class="hljs-built_in">cos</span>(phi));&#125;</code></pre></div><p>2.像之前使用过的方法一样，将eye放在光源的位置，从而得到每个光源的shadowBuffer。</p><p>我们可以使用一张TGA图来记录每次某个部分是可见还是不可见</p><p>3.重复上述过程1000次。此时我们就能得到一张完善的记录了模型每个面受到环境光照大小的纹理图！</p><p>补充：在光照图里只能看到一只手——因为模型在创作时两只手使用的是相同的纹理，因此将光照映射到纹理图时，会映射到相同的地方。</p><p>因此，对于双倍纹理坐标，我们必须进行一些修复。</p><p>这种方法较为消耗资源，适合于静态的场景进行光照的预计算。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图形学</category>
      
      <category>TinyRenderer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>C++</tag>
      
      <tag>TinyRenderer</tag>
      
      <tag>软件光栅化渲染器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyRenderer 6&amp;7</title>
    <link href="/2022/08/31/TinyRenderer-6-7/"/>
    <url>/2022/08/31/TinyRenderer-6-7/</url>
    
    <content type="html"><![CDATA[<h1>Lesson 6: Shaders for the software renderer</h1><h2 id="前言">前言</h2><p>L6很重要。不仅是因为我们结束了数学部分进入了渲染，也是因为在此处我们对代码进行了分析和重构。</p><h2 id="Refactoring-the-source-code">Refactoring the source code</h2><h3 id="碎碎念">碎碎念</h3><p>作者在这里对代码进行了一个分析和总结，并表示：代码写的<strong>太多太乱</strong>了！</p><p>很巧，笔者也是这么觉得的，甚至，笔者的代码量接近原作者的两倍！！！！！好伤心！！！！</p><p>既然如此，就跟着作者的指引来重构一下自己小小渲染器的内容吧~我们应该只把有关渲染的一些<strong>可调整</strong>的参数和某些特定、需要修改的任务放在主函数中，而那些只是提供一个接口的渲染、计算函数不需要进一步修改，就将其放在别的特定的文件内就可以了。</p><p>想要做到这一点，就必须深刻理解整个渲染的过程。所以，跟着笔者的脚步对整个渲染进行一个梳理吧！</p><h3 id="前置文件">前置文件</h3><p>首先，想要完成渲染需要三个头文件的支持：</p><div class="code-wrapper"><pre><code class="hljs stylus">Geometry<span class="hljs-selector-class">.h</span><span class="hljs-comment">//这个头文件提供了一系列的数学计算函数，为向量和矩阵的计算提供了巨大的便利</span>tgaimage<span class="hljs-selector-class">.h</span><span class="hljs-comment">//这个头文件允许我们读写tga图像</span>model<span class="hljs-selector-class">.h</span><span class="hljs-comment">//这个头文件给了我们一个读取模型的途径</span></code></pre></div><p>这三个头文件不需要我们倾注太多心思，因为是基础性的，但是也可以花时间研究一下。特别是<code>model.h</code> ，因为只有深刻理解我们如何储存模型的数据，才能做到合理的取用这些数据，这也是前几节课的一个难点。</p><p>首先我们要理解一个需要被渲染的模型是怎么构成的：</p><ol><li><p>模型 -----&gt; 无数的三角形面 -----&gt; 每个面由三个顶点组成 ：顶点坐标</p></li><li><p>模型每个面（或点）的法线</p></li><li><p>模型需要贴图（纹理），无数个纹理坐标（与顶点坐标一一对应）</p></li><li><p>模型是三维的，贴图是二维的，因此才需要一一对应关系进行转换：对应表</p></li></ol><p>在一个模型文件中（.obj），包含以下信息：</p><p>（初始模型的坐标均在一个[-1,1]^3的立方体内）</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>所有顶点的坐标（在物体自身的坐标系中）v -<span class="hljs-number">0.171097</span> <span class="hljs-number">0.299996</span> <span class="hljs-number">0.415616</span>……<span class="hljs-comment"># 1258 vertices</span><span class="hljs-regexp">//</span>所有顶点对应的点在纹理贴图上的坐标（数量不相等，why？）vt  <span class="hljs-number">0.532</span> <span class="hljs-number">0.923</span> <span class="hljs-number">0.000</span>……<span class="hljs-comment"># 1339 texture vertices</span><span class="hljs-regexp">//</span>所有法线向量（看来是每个顶点的法线）vn  <span class="hljs-number">0.001</span> <span class="hljs-number">0.482</span> -<span class="hljs-number">0.876</span><span class="hljs-comment"># 1258 vertex normals</span><span class="hljs-regexp">//</span>每个面的信息f <span class="hljs-number">1201</span><span class="hljs-regexp">/1249/</span><span class="hljs-number">1201</span> <span class="hljs-number">1202</span><span class="hljs-regexp">/1248/</span><span class="hljs-number">1202</span> <span class="hljs-number">1200</span><span class="hljs-regexp">/1246/</span><span class="hljs-number">1200</span><span class="hljs-regexp">//</span>格式： f （顶点索引<span class="hljs-regexp">/uv点索引/</span>法线索引）* <span class="hljs-number">3</span> （表示组成这个face的<span class="hljs-number">3</span>个顶点）<span class="hljs-comment"># 2492 faces</span></code></pre></div><p>通过读取这个文件，我们自然能得到模型的一切信息。</p><p>欧克，这三个头文件相当于为我们清除了一切阻碍，我们需要做的就是聚精会神的剖析渲染的过程！</p><h3 id="渲染过程">渲染过程</h3><p>这个过程我们用文字夹杂着代码的形式来说，同时因为是重新整理，所以顺序上没有那么循循善诱。</p><p>首先，我们要设定整个场景的参数：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//设定一些宏</span><span class="hljs-type">const</span> TGAColor white = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-type">const</span> TGAColor red = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>);<span class="hljs-type">const</span> TGAColor green = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//初始化模型</span>Model *model = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//设定画布大小</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> width = <span class="hljs-number">800</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> height = <span class="hljs-number">800</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> depth = <span class="hljs-number">255</span>;<span class="hljs-comment">//设定光源、照相机、坐标系</span>Vec3f light_dir = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>).<span class="hljs-built_in">normalize</span>();<span class="hljs-function">Vec3f <span class="hljs-title">camera</span><span class="hljs-params">(<span class="hljs-number">1.f</span>, <span class="hljs-number">1.f</span>, <span class="hljs-number">3.f</span>)</span></span>;<span class="hljs-function">Vec3f <span class="hljs-title">center</span><span class="hljs-params">(<span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>)</span></span>;<span class="hljs-function">Vec3f <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-number">0.f</span>, <span class="hljs-number">1.f</span>, <span class="hljs-number">0.f</span>)</span></span>;</code></pre></div><div class="note note-primary">            <p>我想先强调一个渲染的最基本的概念：你所做的一切，都是为了得到屏幕上每个像素点的颜色。</p><p>我们做了一大堆一大堆的变化和计算，为了什么呢？没错，就是为了确定物体的每个点的屏幕坐标，这样屏幕上的像素点就可以根据周围这些点的纹理颜色设定自己的颜色了。</p><p>前面提过这个变换顺序：</p><div class="code-wrapper"><pre><code class="hljs cos">Viewport * Projection * <span class="hljs-keyword">View</span> * Model * vertex</code></pre></div><p>Model变换是为了将每个点的坐标从物体坐标转换到世界坐标；</p><p>View变换是为了将每个点的坐标从世界坐标转换到摄像机（眼睛）坐标系中；</p><p>Projection变换是为了将每个点透视投影到屏幕上。这里可能比较抽象：</p><p>我们认为眼睛是一个点，那么我们看到物体是满足近大远小的透视规律的，因为屏幕只是一个平面，因此物体在屏幕上的x,y坐标必然会受到深度的影响。投影就是为了算出每个点的屏幕坐标。</p><p>ViewPort变换是为了拉伸画面。我们知道，这些变换一直是在[-1,1]^3的立方体的前提下进行的，要把画面放大到指定的高度和宽度。至于深度，因为我们只需要知道相对关系，其实绝对数值意义不大，一般为255.</p><p>这样，就可以确定模型每个点的屏幕坐标了。屏幕的每个像素点依据附近的模型面（或点）的颜色计算出显示什么颜色，就ok了。</p>          </div><p>下面咱们来一起看渲染的过程：</p><p>（蓝色的是我们无法改变的，而橘色的是我们可以随意改造的）</p><p><img src="https://s3.bmp.ovh/imgs/2022/08/31/88113a7c13ebb342.png" alt=""></p><p>我们现在已经获取到了顶点的数据，通过预处理后，使用Vertex Shader对其进行变换，使模型中每个点的坐标转换为屏幕坐标，并算出相应的光照。</p><p>接着fragment Shader将会读取其光照和原纹理，计算出像素点的实际颜色，并进行上色。</p><p>不对一些细枝末节的过程进行详细说明，我们就得到了勉强可看的渲染结果啦！</p><p>所以可以看出，过程其实是：</p><p>模型 ——&gt; 特定的shader进行渲染 ——&gt; 结果图</p><p>所以将shader抽离出来是很有必要的！</p><p>因此，建立shader模板类：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//创建一个shader模板类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IShader</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IShader</span>();    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>= <span class="hljs-number">0</span>;&#125;;</code></pre></div><p>同时，因为投影变换矩阵和画三角形的函数相对固定，我们也将其抽离出来：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">viewport</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span></span><span class="hljs-function"></span>&#123;    Viewport = Matrix::<span class="hljs-built_in">identity</span>();    <span class="hljs-comment">//将中心点移动到1/2width 和 1/2height的屏幕中央</span>    Viewport[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = x + w / <span class="hljs-number">2.f</span>;    Viewport[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = y + h / <span class="hljs-number">2.f</span>;    <span class="hljs-comment">//深度</span>    Viewport[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">255.f</span> / <span class="hljs-number">2.f</span>;    <span class="hljs-comment">//将画幅拉伸到3/4屏幕那么大，留白一些</span>    <span class="hljs-comment">//这里是可以自己调的， 老师就是3/4， 我认为这个大小是合适的</span>    Viewport[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = w / <span class="hljs-number">2.f</span>;    Viewport[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = h / <span class="hljs-number">2.f</span>;    Viewport[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">255.f</span> / <span class="hljs-number">2.f</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">projection</span><span class="hljs-params">(<span class="hljs-type">float</span> coeff)</span></span><span class="hljs-function"></span>&#123;    Projection = Matrix::<span class="hljs-built_in">identity</span>();    Projection[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = coeff;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lookat</span><span class="hljs-params">(Vec3f eye, Vec3f center, Vec3f up)</span></span><span class="hljs-function"></span>&#123;    Vec3f z = (eye - center).<span class="hljs-built_in">normalize</span>();    Vec3f x = <span class="hljs-built_in">cross</span>(up, z).<span class="hljs-built_in">normalize</span>();    Vec3f y = <span class="hljs-built_in">cross</span>(z, x).<span class="hljs-built_in">normalize</span>();    ModelView = Matrix::<span class="hljs-built_in">identity</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        ModelView[<span class="hljs-number">0</span>][i] = x[i];        ModelView[<span class="hljs-number">1</span>][i] = y[i];        ModelView[<span class="hljs-number">2</span>][i] = z[i];        ModelView[i][<span class="hljs-number">3</span>] = -center[i];    &#125;&#125;<span class="hljs-function">Vec3f <span class="hljs-title">barycentric</span><span class="hljs-params">(Vec2f A, Vec2f B, Vec2f C, Vec2f P)</span></span><span class="hljs-function"></span>&#123;    Vec3f s[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i--;)    &#123;        s[i][<span class="hljs-number">0</span>] = C[i] - A[i];        s[i][<span class="hljs-number">1</span>] = B[i] - A[i];        s[i][<span class="hljs-number">2</span>] = A[i] - P[i];    &#125;    Vec3f u = <span class="hljs-built_in">cross</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(u[<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">1e-2</span>) <span class="hljs-comment">// dont forget that u[2] is integer. If it is zero then triangle ABC is degenerate</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">1.f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// in this case generate negative coordinates, it will be thrown away by the rasterizator</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">triangle</span><span class="hljs-params">(Vec4f *pts, IShader &amp;shader, TGAImage &amp;image, TGAImage &amp;zbuffer)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Vec2f <span class="hljs-title">bboxmin</span><span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max(), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max())</span></span>;    <span class="hljs-function">Vec2f <span class="hljs-title">bboxmax</span><span class="hljs-params">(-std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max())</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)        &#123;            bboxmin[j] = std::<span class="hljs-built_in">min</span>(bboxmin[j], pts[i][j] / pts[i][<span class="hljs-number">3</span>]);            bboxmax[j] = std::<span class="hljs-built_in">max</span>(bboxmax[j], pts[i][j] / pts[i][<span class="hljs-number">3</span>]);        &#125;    &#125;    Vec2i P;    TGAColor color;    <span class="hljs-keyword">for</span> (P.x = bboxmin.x; P.x &lt;= bboxmax.x; P.x++)    &#123;        <span class="hljs-keyword">for</span> (P.y = bboxmin.y; P.y &lt;= bboxmax.y; P.y++)        &#123;            Vec3f c = <span class="hljs-built_in">barycentric</span>(<span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(pts[<span class="hljs-number">0</span>] / pts[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]), <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(pts[<span class="hljs-number">1</span>] / pts[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]), <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(pts[<span class="hljs-number">2</span>] / pts[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]), <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(P));            <span class="hljs-type">float</span> z = pts[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] * c.x + pts[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] * c.y + pts[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] * c.z;            <span class="hljs-type">float</span> w = pts[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] * c.x + pts[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] * c.y + pts[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] * c.z;            <span class="hljs-type">int</span> frag_depth = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">min</span>(<span class="hljs-number">255</span>, <span class="hljs-built_in">int</span>(z / w + <span class="hljs-number">.5</span>)));            <span class="hljs-keyword">if</span> (c.x &lt; <span class="hljs-number">0</span> || c.y &lt; <span class="hljs-number">0</span> || c.z &lt; <span class="hljs-number">0</span> || zbuffer.<span class="hljs-built_in">get</span>(P.x, P.y)[<span class="hljs-number">0</span>] &gt; frag_depth)                <span class="hljs-keyword">continue</span>;            <span class="hljs-type">bool</span> discard = shader.<span class="hljs-built_in">fragment</span>(c, color);            <span class="hljs-keyword">if</span> (!discard)<span class="hljs-comment">//为什么要弄一个bool？——方便丢弃像素（在之后的课程中会出现的）</span>            &#123;                zbuffer.<span class="hljs-built_in">set</span>(P.x, P.y, <span class="hljs-built_in">TGAColor</span>(frag_depth));                image.<span class="hljs-built_in">set</span>(P.x, P.y, color);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>好了，此时我们的主函数是这样的：</p><p>（笔者这里非常偷懒的全部使用的老师的模板：因为笔者的几个头文件一开始是自己写的，在扩充的过程中成为屎山，且与主函数的协调都存在巨大问题。。。完全重构耗时太长，因此只能从这里先借鉴一下范本，有能力还是自己写，有助于深入了解。笔者已经上过GAMES101，很轻易能看懂，因此偷个小懒啦~）</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//高氏shader——最初级的shader</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GouraudShader</span> : <span class="hljs-keyword">public</span> IShader &#123;    Vec3f varying_intensity; <span class="hljs-comment">// written by vertex shader, read by fragment shader</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>&#123;        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert)); <span class="hljs-comment">// read the vertex from .obj file</span>        gl_Vertex = Viewport*Projection*ModelView*gl_Vertex;     <span class="hljs-comment">// transform it to screen coordinates</span>        varying_intensity[nthvert] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, model-&gt;<span class="hljs-built_in">normal</span>(iface, nthvert)*light_dir); <span class="hljs-comment">// get diffuse lighting intensity</span>        <span class="hljs-keyword">return</span> gl_Vertex;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;        <span class="hljs-type">float</span> intensity = varying_intensity*bar;   <span class="hljs-comment">// interpolate intensity for the current pixel</span>        color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)*intensity; <span class="hljs-comment">// well duh</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                              <span class="hljs-comment">// no, we do not discard this pixel</span>    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;    <span class="hljs-comment">//获取模型</span>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>==argc) &#123;        model = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Model</span>(argv[<span class="hljs-number">1</span>]);    &#125; <span class="hljs-keyword">else</span> &#123;        model = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Model</span>(<span class="hljs-string">&quot;obj/african_head.obj&quot;</span>);    &#125;    <span class="hljs-comment">//初始化变换矩阵</span>    <span class="hljs-built_in">lookat</span>(eye, center, up);    <span class="hljs-built_in">viewport</span>(width/<span class="hljs-number">8</span>, height/<span class="hljs-number">8</span>, width*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>, height*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>);    <span class="hljs-built_in">projection</span>(<span class="hljs-number">-1.f</span>/(eye-center).<span class="hljs-built_in">norm</span>());    <span class="hljs-comment">//初始化光线</span>    light_dir.<span class="hljs-built_in">normalize</span>();    <span class="hljs-comment">//初始纹理和深度图</span>    <span class="hljs-function">TGAImage <span class="hljs-title">image</span>  <span class="hljs-params">(width, height, TGAImage::RGB)</span></span>;    <span class="hljs-function">TGAImage <span class="hljs-title">zbuffer</span><span class="hljs-params">(width, height, TGAImage::GRAYSCALE)</span></span>;    <span class="hljs-comment">//获取高氏Shader</span>    GouraudShader shader;    <span class="hljs-comment">//借助shader渲染模型</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;model-&gt;<span class="hljs-built_in">nfaces</span>(); i++) &#123;        Vec4f screen_coords[<span class="hljs-number">3</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">3</span>; j++) &#123;            screen_coords[j] = shader.<span class="hljs-built_in">vertex</span>(i, j);        &#125;        <span class="hljs-built_in">triangle</span>(screen_coords, shader, image, zbuffer);    &#125;    <span class="hljs-comment">//输出</span>    image.  <span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// to place the origin in the bottom left corner of the image</span>    zbuffer.<span class="hljs-built_in">flip_vertically</span>();    image.  <span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;output.tga&quot;</span>);    zbuffer.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;zbuffer.tga&quot;</span>);    <span class="hljs-keyword">delete</span> model;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>可以看到，我们这里使用的是高氏Shader，此后，我们会学习更多的Shader，同时我们自己也应该学会自己写Shader，比如我们马上就要迎来的下一课。</p><h2 id="修改Shader的第一次尝试">修改Shader的第一次尝试</h2><p>尝试一下通过修改Shader来产生各种不同的渲染效果吧！</p><p>这是作者的示例：可以看到，作者只允许亮度有6个不同的值，而且初始颜色被设定为了橘黄色，可以想象这样会是一种厚涂的风格。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span><span class="hljs-function"></span>&#123;      <span class="hljs-type">float</span> intensity = varying_intensity*bar;      <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.85</span>) intensity = <span class="hljs-number">1</span>;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.60</span>) intensity = <span class="hljs-number">.80</span>;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.45</span>) intensity = <span class="hljs-number">.60</span>;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.30</span>) intensity = <span class="hljs-number">.45</span>;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.15</span>) intensity = <span class="hljs-number">.30</span>;      <span class="hljs-keyword">else</span> intensity = <span class="hljs-number">0</span>;      color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">155</span>, <span class="hljs-number">0</span>)*intensity;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;</code></pre></div><p><img src="https://s3.bmp.ovh/imgs/2022/09/03/a51d60c7d28aa665.png" alt=""></p><h2 id="Normalmapping">Normalmapping</h2><p>textrue不仅可以储存RGB颜色，也可以存储别的，非常丰富的信息，比如法线。</p><img src="https://s3.bmp.ovh/imgs/2022/09/03/24d8531246467622.png" style="zoom:50%;" /><p>这就是一张典型的法线贴图，存放了每个点的法线信息。</p><p>既然说到法线，那我们就来扯一扯法线的问题。还记得之前我们说到的如果模型进行了坐标变换，那么法线也需要进行坐标变换吗?那为什么我们一直没有提到关于发现的坐标变换呢？一起来看看吧。</p><p>首先是一开始的高氏Shader：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GouraudShader</span> : <span class="hljs-keyword">public</span> IShader&#123;    Vec3f varying_intensity; <span class="hljs-comment">// written by vertex shader, read by fragment shader</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span><span class="hljs-function">    </span>&#123;        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));                               <span class="hljs-comment">// read the vertex from .obj file</span>        gl_Vertex = Viewport * Projection * ModelView * gl_Vertex;                             <span class="hljs-comment">// transform it to screen coordinates</span>        varying_intensity[nthvert] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, model-&gt;<span class="hljs-built_in">normal</span>(iface, nthvert) * light_dir); <span class="hljs-comment">// get diffuse lighting intensity</span>        <span class="hljs-keyword">return</span> gl_Vertex;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-type">float</span> intensity = varying_intensity * bar;   <span class="hljs-comment">// interpolate intensity for the current pixel</span>        color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>) * intensity; <span class="hljs-comment">// well duh</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                                <span class="hljs-comment">// no, we do not discard this pixel</span>    &#125;&#125;;<span class="hljs-comment">//我们需要使用到法线的地方在哪里？—— 计算光照</span><span class="hljs-comment">//varying_intensity[nthvert] = std::max(0.f, model-&gt;normal(iface, nthvert) * light_dir); </span><span class="hljs-comment">//可以看到，我们根本没管这里点经过投影之后的法线变换，也没管光线在拉伸后的空间后的变化，因此效果确实会差一些！</span><span class="hljs-comment">//此处light_dir是否需要拉伸还是看你给的是什么坐标系下的light_dir.</span></code></pre></div><p>我们修改一下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shader</span> : <span class="hljs-keyword">public</span> IShader&#123;    mat&lt;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_uv;  <span class="hljs-comment">// same as above</span>    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_M;   <span class="hljs-comment">//  Projection*ModelView</span>    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_MIT; <span class="hljs-comment">// (Projection*ModelView).invert_transpose()</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span><span class="hljs-function">    </span>&#123;        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert)); <span class="hljs-comment">// read the vertex from .obj file</span>        <span class="hljs-keyword">return</span> Viewport * Projection * ModelView * gl_Vertex;    <span class="hljs-comment">// transform it to screen coordinates</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span><span class="hljs-function">    </span>&#123;        Vec2f uv = varying_uv * bar; <span class="hljs-comment">// interpolate uv for the current pixel</span>        Vec3f n = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_MIT * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(uv))).<span class="hljs-built_in">normalize</span>();        Vec3f l = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_M * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(light_dir)).<span class="hljs-built_in">normalize</span>();        <span class="hljs-type">float</span> intensity = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n * l);        color = model-&gt;<span class="hljs-built_in">diffuse</span>(uv) * intensity; <span class="hljs-comment">// well duh</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                           <span class="hljs-comment">// no, we do not discard this pixel</span>    &#125;&#125;;<span class="hljs-comment">//这里我们是怎么计算光照的呢？</span><span class="hljs-comment">//因为提供了法线贴图，所以不需要点对点的单独提取法线了，只要直接插值算出每个三角形对应的uv，颜色和法线都可以通过uv确定。取得三角形的法线后再直接和光线点乘得到系数。</span></code></pre></div><p>最后我们对比一下这两种方法的效果差距：</p><img src="https://s3.bmp.ovh/imgs/2022/09/03/879521a02efd38ca.png" style="zoom: 33%;" /><img src="https://s3.bmp.ovh/imgs/2022/09/03/77e0fde064a19dc0.png" style="zoom:33%;" /><h2 id="Specular-mapping">Specular mapping</h2><p>我们看着这个人像，仍然不满意于渲染的结果。为什么呢？</p><p>光照还是不够真实！众所周知，光在打到物体时会发生反射，分为镜面反射和漫反射。而且我们是如何处理光照的？——非常直觉性的”法线和光线方向一致则亮，否则则暗”，这是一种模拟漫反射强度的有效方法，但是Phong提出了一个更好的光照模型，我们一起来学习一下：</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/03/34a77862e0fac16d.png" alt=""></p><img src="https://s3.bmp.ovh/imgs/2022/09/03/5d0696b25eb6b6d6.png" style="zoom:50%;" /><p>下面给出代码：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shader</span> : <span class="hljs-keyword">public</span> IShader &#123;    mat&lt;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_uv;  <span class="hljs-comment">// same as above</span>    mat&lt;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-type">float</span>&gt; uniform_M;   <span class="hljs-comment">//  Projection*ModelView</span>    mat&lt;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-type">float</span>&gt; uniform_MIT; <span class="hljs-comment">// (Projection*ModelView).invert_transpose()</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>&#123;        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert)); <span class="hljs-comment">// read the vertex from .obj file</span>        <span class="hljs-keyword">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class="hljs-comment">// transform it to screen coordinates</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;        Vec2f uv = varying_uv*bar;        Vec3f n = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_MIT*<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(uv))).<span class="hljs-built_in">normalize</span>();        Vec3f l = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_M  *<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(light_dir        )).<span class="hljs-built_in">normalize</span>();        Vec3f r = (n*(n*l*<span class="hljs-number">2.f</span>) - l).<span class="hljs-built_in">normalize</span>();   <span class="hljs-comment">// reflected light</span>        <span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(r.z, <span class="hljs-number">0.0f</span>), model-&gt;<span class="hljs-built_in">specular</span>(uv));<span class="hljs-comment">//可以看到，又出现了一个高光贴图，用于给出每处的粗糙度，有助于让光滑的地方获得更强的反光。</span>        <span class="hljs-type">float</span> diff = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n*l);        TGAColor c = model-&gt;<span class="hljs-built_in">diffuse</span>(uv);        color = c;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) color[i] = std::<span class="hljs-built_in">min</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">5</span> + c[i]*(diff + <span class="hljs-number">.6</span>*spec), <span class="hljs-number">255</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>这里作者写的</p><div class="code-wrapper"><pre><code class="hljs c++">Vec3f r = (n*(n*l*<span class="hljs-number">2.f</span>) - l).<span class="hljs-built_in">normalize</span>();<span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(r.z, <span class="hljs-number">0.0f</span>), model-&gt;<span class="hljs-built_in">specular</span>(uv));</code></pre></div><p>感觉有点无厘头（</p><p>按理来说应该把r和v先求点乘，然后再power多次，得到高光才对。合理猜测是因为此时eye的位置比较取巧，所以才不需要考虑v，但是v还是很重要的。</p><p>最后出个结果吧。</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/03/2416957d30229da8.png" alt=""></p><h2 id="总结">总结</h2><p>这节课收获还是很多的！</p><p>我们已经可以渲染的像模像样了，但是还远远达不到“好”和“真实”。</p><p>我们虽然简单模拟了光，但是没有考虑阴影呢！</p><h1>Lesson 6bis: tangent space normal mapping</h1><h2 id="前言-2">前言</h2><p>很神奇，中间插了一截来讲normalMapping，那我们在讲阴影之前就先看一看NormalMapping吧！</p><p>先链接一篇文章，因为这里涉及到了很多线性代数，数学不好的话肯定会很迷惑。</p><p><a href="https://zhuanlan.zhihu.com/p/143321426">法线贴图那些事儿</a></p><p>我们思考一个问题：</p><p>如果我们想用这个模型做一段动画，那么该怎么获取每一帧物体的位置、纹理和法线呢？</p><p>首先是位置：每个三角面的位置由动画本身决定，不需要我们去获取。</p><p>纹理：每个三角形对应的uv贴图的坐标是一定的，在运动过程中纹理不会发生改变，因此不需要处理</p><p>法线：每个三角形的法线由三角形三个顶点的法线计算而来，而这由模型文件本身给出，因此，在三角形顶点跟随动画运动的过程中，法线无法确定了！</p><p>因此（不构成直接的因果关系，只是基于切线空间的法线贴图有这个好处），我们注意到了tangent space normal mapping！</p><p>切线空间的法线贴图存储着每个顶点的相对法向量，因此，无论顶点怎么动，只要用合适的数学将其提取出来，就一定会是正确的法向！</p><p>好了，接下来我们来学习一下吧！</p><h2 id="代码展示">代码展示</h2><p>和往常一样，我不会展示具体的数学推导。（因为解释起来太麻烦+我也不一定正确)，所以指路<a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-6bis:-tangent-space-normal-mapping">原帖</a>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//只有Shader发生了变化，其他部分和以前一样。</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shader</span> : <span class="hljs-keyword">public</span> IShader &#123;    mat&lt;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_uv;  <span class="hljs-comment">// triangle uv coordinates, written by the vertex shader, read by the fragment shader</span>    mat&lt;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_tri; <span class="hljs-comment">// triangle coordinates (clip coordinates), written by VS, read by FS</span>    mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_nrm; <span class="hljs-comment">// normal per vertex to be interpolated by FS</span>    mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; ndc_tri;     <span class="hljs-comment">// triangle in normalized device coordinates</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>&#123;        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));        varying_nrm.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;((Projection*ModelView).<span class="hljs-built_in">invert_transpose</span>()*<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(iface, nthvert), <span class="hljs-number">0.f</span>)));        Vec4f gl_Vertex = Projection*ModelView*<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));        varying_tri.<span class="hljs-built_in">set_col</span>(nthvert, gl_Vertex);        ndc_tri.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(gl_Vertex/gl_Vertex[<span class="hljs-number">3</span>]));        <span class="hljs-keyword">return</span> gl_Vertex;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;        Vec3f bn = (varying_nrm*bar).<span class="hljs-built_in">normalize</span>();        Vec2f uv = varying_uv*bar;        mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; A;        A[<span class="hljs-number">0</span>] = ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">1</span>) - ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">0</span>);        A[<span class="hljs-number">1</span>] = ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">2</span>) - ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">0</span>);        A[<span class="hljs-number">2</span>] = bn;        mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; AI = A.<span class="hljs-built_in">invert</span>();        Vec3f i = AI * <span class="hljs-built_in">Vec3f</span>(varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] - varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);        Vec3f j = AI * <span class="hljs-built_in">Vec3f</span>(varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);        mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; B;<span class="hljs-comment">//这就是切线空间的基了</span>        B.<span class="hljs-built_in">set_col</span>(<span class="hljs-number">0</span>, i.<span class="hljs-built_in">normalize</span>());        B.<span class="hljs-built_in">set_col</span>(<span class="hljs-number">1</span>, j.<span class="hljs-built_in">normalize</span>());        B.<span class="hljs-built_in">set_col</span>(<span class="hljs-number">2</span>, bn);        Vec3f n = (B*model-&gt;<span class="hljs-built_in">normal</span>(uv)).<span class="hljs-built_in">normalize</span>();        <span class="hljs-type">float</span> diff = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n*light_dir);        color = model-&gt;<span class="hljs-built_in">diffuse</span>(uv)*diff;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><h1>Lesson 7: Shadow mapping</h1><h2 id="前言-3">前言</h2><p>这节课我们来学习添加阴影。（阴影分为硬阴影和软阴影，此处我们添加硬阴影）</p><h2 id="阴影形成原理">阴影形成原理</h2><p>我们都知道，阴影的形成是因为光源发出的光线被中间的物体遮挡，因此形成了阴影。</p><p>借助这种想法，轻易的就可以理解阴影的求法：做一个类似于zBuffer的shadowBuffer，只渲染最上层的物体。</p><p>如何形成呢？我们可以将眼睛（eye）的位置放在光源，这样我们看过去储存的zBuffer其实就是要求的shadowBuffer。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DepthShader</span> : <span class="hljs-keyword">public</span> IShader&#123;    mat&lt;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_tri;    <span class="hljs-built_in">DepthShader</span>():<span class="hljs-built_in">varying_tri</span>()&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span><span class="hljs-function">    </span>&#123;        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));        gl_Vertex = shadowM * gl_Vertex;        varying_tri.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(gl_Vertex / gl_Vertex[<span class="hljs-number">3</span>]));        <span class="hljs-keyword">return</span> gl_Vertex;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span><span class="hljs-function">    </span>&#123;        Vec3f p = varying_tri * bar;        color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>) * (p.z / <span class="hljs-number">255</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;<span class="hljs-comment">//此处shadowM矩阵为： </span><span class="hljs-built_in">lookat</span>(light_dir, center, up);<span class="hljs-comment">//将眼睛放在光源处</span><span class="hljs-built_in">viewport</span>(width / <span class="hljs-number">8</span>, height / <span class="hljs-number">8</span>, width * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>, height * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>);<span class="hljs-built_in">projection</span>(<span class="hljs-number">-1.f</span> / (eye - center).<span class="hljs-built_in">norm</span>());shadowM = Viewport * Projection * ModelView;</code></pre></div><h2 id="修改Shader">修改Shader</h2><p>那么如何修改我们的Shader也就很清晰了：在我们PhongShader的基础上添加一个前置步骤：计算ShadowBuffer，这样在PhongShader渲染时对于有阴影的部分就可以加以处理了。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//此处展示我们编写的新的PhongShader</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhongShader</span> : <span class="hljs-keyword">public</span> IShader&#123;    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_M;       <span class="hljs-comment">//  Projection*ModelView</span>    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_MIT;     <span class="hljs-comment">// (Projection*ModelView).invert_transpose()</span>    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_Mshadow; <span class="hljs-comment">// transform framebuffer screen coordinates to shadowbuffer screen coordinates</span>    mat&lt;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_uv;      <span class="hljs-comment">// triangle uv coordinates, written by the vertex shader, read by the fragment shader</span>    mat&lt;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_tri;     <span class="hljs-comment">// triangle coordinates before Viewport transform, written by VS, read by FS</span>    <span class="hljs-built_in">PhongShader</span>(Matrix M, Matrix MIT, Matrix MS) : <span class="hljs-built_in">uniform_M</span>(M), <span class="hljs-built_in">uniform_MIT</span>(MIT), <span class="hljs-built_in">uniform_Mshadow</span>(MS), <span class="hljs-built_in">varying_uv</span>(), <span class="hljs-built_in">varying_tri</span>() &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span><span class="hljs-function">    </span>&#123;        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));        Vec4f gl_Vertex = Viewport * Projection * ModelView * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));        varying_tri.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(gl_Vertex / gl_Vertex[<span class="hljs-number">3</span>]));        <span class="hljs-keyword">return</span> gl_Vertex;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span><span class="hljs-function">    </span>&#123;        Vec4f sb_p = uniform_Mshadow * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(varying_tri * bar); <span class="hljs-comment">// corresponding point in the shadow buffer</span>        sb_p = sb_p / sb_p[<span class="hljs-number">3</span>];                                   <span class="hljs-type">float</span> shadow = <span class="hljs-number">.3</span> + <span class="hljs-number">.7</span> * (shadowDepth.<span class="hljs-built_in">get</span>((<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">0</span>], (<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>] &lt; (sb_p[<span class="hljs-number">2</span>]+<span class="hljs-number">10</span>)); <span class="hljs-comment">// magic coeff to avoid z-fighting</span>        <span class="hljs-comment">//这里这个+10需要注意一下，之后会解释，是为防止z—fighting</span>        <span class="hljs-comment">//可以看到，为了模仿软阴影，即使被遮挡住了也不会全黑，而是保留0.3的系数</span>        Vec2f uv = varying_uv * bar;                                              <span class="hljs-comment">// interpolate uv for the current pixel</span>        Vec3f n = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_MIT * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(uv))).<span class="hljs-built_in">normalize</span>(); <span class="hljs-comment">// normal</span>        Vec3f l = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_M * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(light_dir)).<span class="hljs-built_in">normalize</span>();           <span class="hljs-comment">// light vector</span>        Vec3f r = (n * (n * l * <span class="hljs-number">2.f</span>) - l).<span class="hljs-built_in">normalize</span>();                            <span class="hljs-comment">// reflected light</span>        <span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(r.z, <span class="hljs-number">0.0f</span>), model-&gt;<span class="hljs-built_in">specular</span>(uv)); <span class="hljs-comment">//为什么只考虑z? 这里也是一个trick,因为眼睛一定在z轴上,只需要取z分量就可以了</span>        <span class="hljs-type">float</span> diff = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n * l);        TGAColor c = model-&gt;<span class="hljs-built_in">diffuse</span>(uv);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)           color[i] = std::<span class="hljs-built_in">min</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">20</span> + c[i]*shadow*(<span class="hljs-number">1.2</span>*diff + <span class="hljs-number">.6</span>*spec), <span class="hljs-number">255</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>然后在主函数中进行渲染：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// GetDepth</span><span class="hljs-built_in">lookat</span>(light_dir, center, up);<span class="hljs-built_in">viewport</span>(width / <span class="hljs-number">8</span>, height / <span class="hljs-number">8</span>, width * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>, height * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>);<span class="hljs-built_in">projection</span>(<span class="hljs-number">-1.f</span> / (eye - center).<span class="hljs-built_in">norm</span>());shadowM = Viewport * Projection * ModelView;DepthShader Dshader;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)&#123;    Vec4f screen_coords[<span class="hljs-number">3</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)    &#123;        screen_coords[j] = Dshader.<span class="hljs-built_in">vertex</span>(i, j);    &#125;    <span class="hljs-built_in">triangle</span>(screen_coords, Dshader, shadowImage, shadowDepth);&#125;shadowImage.<span class="hljs-built_in">flip_vertically</span>();shadowImage.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;shadow.tga&quot;</span>);<span class="hljs-comment">// PhongShading</span><span class="hljs-built_in">lookat</span>(eye, center, up);<span class="hljs-function">PhongShader <span class="hljs-title">shader</span><span class="hljs-params">(ModelView, (Projection * ModelView).invert_transpose(), shadowM * (Viewport * Projection * ModelView).invert())</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)&#123;    Vec4f screen_coords[<span class="hljs-number">3</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)    &#123;        screen_coords[j] = shader.<span class="hljs-built_in">vertex</span>(i, j);    &#125;    <span class="hljs-built_in">triangle</span>(screen_coords, shader, image, depth);&#125;<span class="hljs-comment">//输出</span>image.<span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// to place the origin in the bottom left corner of the image</span>image.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;output.tga&quot;</span>);</code></pre></div><p>总的来说原理还是很好理解的，但是这里面的数学确实让人有点伤脑筋，外加这个wiki的作者的代码经常反反复复的重构和更新，导致在复现的过程中还是遇到不少麻烦，特别是会出现一些不太理解的magic的变量和数字。但是如果能清晰的理解里面的数学，把数学的部分封装好，我觉得应该能简单很多！</p><p>最后看两张成品图吧！</p><img src="https://s3.bmp.ovh/imgs/2022/09/05/c075281389264e5c.png" style="zoom:50%;" /><img src="https://s3.bmp.ovh/imgs/2022/09/05/74ca9782bd5a04b9.png" style="zoom: 67%;" /><h2 id="一个小问题">一个小问题</h2><p>通过成品图（特别是第二张图）我们可以看到，模型身上有一些非常丑陋的闪烁的阴影，这是为什么呢？</p><p>这是一种特别的现象：Z-fighting。</p><p>链接一篇知乎专栏：<a href="https://zhuanlan.zhihu.com/p/78769570">&lt;渲染基础&gt;-3D渲染中的Z-fighting现象</a></p><p>CSDN : <a href="https://blog.csdn.net/chenweiyu11962/article/details/113542402">Z-Fighting问题解决方案实例</a></p><p>在作者的教程中，他直接添加了一个magic number：43.34来解决这个问题</p><p>这实际上是制造了一个偏移，这样可能可以整体性的去除一些闪烁？？不太懂</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> shadow = <span class="hljs-number">.3</span> + <span class="hljs-number">.7</span> * (shadowDepth.<span class="hljs-built_in">get</span>((<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">0</span>], (<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>] &lt; (sb_p[<span class="hljs-number">2</span>]+<span class="hljs-number">10</span>)); <span class="hljs-comment">// magic coeff to avoid z-fighting</span></code></pre></div><p>我使用的+10，没有什么特别大的区别，但是可以看出这种方法只能一定程度上解决这个问题，该闪烁还是会闪烁。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图形学</category>
      
      <category>TinyRenderer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>C++</tag>
      
      <tag>TinyRenderer</tag>
      
      <tag>软件光栅化渲染器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyRenderer 4&amp;5</title>
    <link href="/2022/05/16/TinyRenderer-4-5/"/>
    <url>/2022/05/16/TinyRenderer-4-5/</url>
    
    <content type="html"><![CDATA[<h1>Lesson 4: Perspective projection</h1><h2 id="前言">前言</h2><p>此前我们讨论如何将三维模型内的点投影到屏幕上时,只是仅仅进行了等比例的缩放,而并没有考虑到Z轴对于缩放比例的影响!这显然是不够合理的!(因为没有考虑到透视关系的影响)(因为我们的眼睛(或者是camera)只是一个点.)</p><p>投影变换我们将借助矩阵来完成.(因为矩阵具有很好而且很方便的计算性质).</p><p>基本的线性变换有scaling shearing rotation, 矩阵的乘法不具有交换律, 不能随意改变顺序.</p><p>除了线性变换,我们还有<strong>仿射</strong>(affine)变换. 在线性变换中,原点的位置始终不会发生改变,而仿射变换则不然.</p><p>仿射变换的矩阵计算需要借助齐次坐标(homogeneous coordinates)</p><p>这些数学知识在此一笔带过,不想多提,具体可以看<a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-4:-Perspective-projection">原文</a>.</p><h2 id="代码部分">代码部分</h2><p>我认为这部分才是重点哇,但是居然没怎么提及!</p><p>想要实现这个功能, 我们还是要做一些工作的!</p><p>工欲善其事必先利其器, 首先, 我们要先在 <code>geometry.h</code>写一个矩阵模板!</p><p>该矩阵应当是可拓展的(至少也支持4维)</p><p>应该封装好求逆和转置的函数</p><p>应该支持矩阵乘法</p><p>贴一下代码吧:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//geometry.h内新增的Matrix类, 用于储存矩阵</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>&#123;std::vector&lt;std::vector&lt;<span class="hljs-type">float</span>&gt;&gt; m;    <span class="hljs-type">int</span> rows, cols;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">nrows</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ncols</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">static</span> Matrix <span class="hljs-title">identity</span><span class="hljs-params">(<span class="hljs-type">int</span> deminsion)</span></span>;std::vector&lt;<span class="hljs-type">float</span>&gt;&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i);    Matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp; a);    <span class="hljs-function">Matrix <span class="hljs-title">transpose</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Matrix <span class="hljs-title">inverse</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m);&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//添加geometry.cpp文件,实现内部方法</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;geometry.h&quot;</span></span>Matrix::<span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) : <span class="hljs-built_in">m</span>(r, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">float</span>&gt;(c, <span class="hljs-number">0.f</span>)), <span class="hljs-built_in">rows</span>(r), <span class="hljs-built_in">cols</span>(c)&#123;&#125;;<span class="hljs-comment">//c++语法 构造初始化列表</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Matrix::nrows</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> rows;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Matrix::ncols</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> cols;&#125;<span class="hljs-function">Matrix <span class="hljs-title">Matrix::identity</span><span class="hljs-params">(<span class="hljs-type">int</span> dimension)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Matrix <span class="hljs-title">M</span><span class="hljs-params">(dimension, dimension)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dimension;i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dimension;j++)        &#123;            M[i][j] = (i == j) ? <span class="hljs-number">1.f</span> : <span class="hljs-number">0.f</span>;        &#125;    &#125;&#125;std::vector&lt;<span class="hljs-type">float</span>&gt;&amp; Matrix::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i) &#123;    <span class="hljs-built_in">assert</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;rows);    <span class="hljs-keyword">return</span> m[i];&#125;Matrix Matrix::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&amp; a)&#123;    <span class="hljs-built_in">assert</span>(cols == a.rows);    <span class="hljs-function">Matrix <span class="hljs-title">res</span><span class="hljs-params">(rows, a.cols)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;rows; i++)     &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;a.cols; j++)         &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;cols; k++)             &#123;                res.m[i][j] += m[i][k]*a.m[k][j];            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">Matrix <span class="hljs-title">Matrix::transpose</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Matrix <span class="hljs-title">res</span><span class="hljs-params">(rows, cols)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)        &#123;            res[i][j] = m[j][i];        &#125;    &#125;&#125;<span class="hljs-comment">//计算逆矩阵需要一些数学功底,这里我是复制黏贴的,等我有时间再改成我自己的!</span><span class="hljs-function">Matrix <span class="hljs-title">Matrix::inverse</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">assert</span>(rows==cols);    <span class="hljs-comment">// augmenting the square matrix with the identity matrix of the same dimensions a =&gt; [ai]</span>    <span class="hljs-function">Matrix <span class="hljs-title">result</span><span class="hljs-params">(rows, cols*<span class="hljs-number">2</span>)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;rows; i++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;cols; j++)            result[i][j] = m[i][j];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;rows; i++)        result[i][i+cols] = <span class="hljs-number">1</span>;    <span class="hljs-comment">// first pass</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;rows<span class="hljs-number">-1</span>; i++) &#123;        <span class="hljs-comment">// normalize the first row</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=result.cols<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span>; j--)            result[i][j] /= result[i][i];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=i+<span class="hljs-number">1</span>; k&lt;rows; k++) &#123;            <span class="hljs-type">float</span> coeff = result[k][i];            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;result.cols; j++) &#123;                result[k][j] -= result[i][j]*coeff;            &#125;        &#125;    &#125;    <span class="hljs-comment">// normalize the last row</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=result.cols<span class="hljs-number">-1</span>; j&gt;=rows<span class="hljs-number">-1</span>; j--)        result[rows<span class="hljs-number">-1</span>][j] /= result[rows<span class="hljs-number">-1</span>][rows<span class="hljs-number">-1</span>];    <span class="hljs-comment">// second pass</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=rows<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=i<span class="hljs-number">-1</span>; k&gt;=<span class="hljs-number">0</span>; k--) &#123;            <span class="hljs-type">float</span> coeff = result[k][i];            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;result.cols; j++) &#123;                result[k][j] -= result[i][j]*coeff;            &#125;        &#125;    &#125;    <span class="hljs-comment">// cut the identity matrix back</span>    <span class="hljs-function">Matrix <span class="hljs-title">truncate</span><span class="hljs-params">(rows, cols)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;rows; i++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;cols; j++)            truncate[i][j] = result[i][j+cols];    <span class="hljs-keyword">return</span> truncate;&#125;<span class="hljs-comment">//这是一种给矩阵赋值的方式! 老师爱用, 我就不是很喜欢...</span>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m.<span class="hljs-built_in">nrows</span>(); i++)      &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;m.<span class="hljs-built_in">ncols</span>(); j++)         &#123;            s &lt;&lt; m[i][j];            <span class="hljs-keyword">if</span> (j&lt;m.<span class="hljs-built_in">ncols</span>()<span class="hljs-number">-1</span>) s &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;        &#125;        s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> s;&#125;</code></pre></div><p>OK, 现在我们已经拥有矩阵了! 那么, 就简单实现一下透视效果吧!</p><p>首先我们要深刻理解不同坐标系之间的转换。</p><p>首先，在obj模型中， 物体的坐标为本地坐标， x，y范围为[1,-1]， z为[-1,0]。</p><p>接着， 物体一定是位于场景中的某个位置的， 这个位置我们称为世界坐标。（在本课中是同一个东西，还没考虑）</p><p>场景中除了物体，一定还有我们的摄像机， 如果我们认为摄像机是原点，视线是z轴， 那么物体在此坐标系下的坐标即为摄像机坐标。（下次课可能要讨论的东西）</p><p>此时， 因为我们认为摄像机是一个点， 那么就会产生透视以及透视带来的畸变效果，我们将物体依据光的直线传播进行一个透视投影， 此时我们已经成功化3D为2D。</p><p>最后， 透视完的物体并没有根据屏幕大小进行拉伸， 此时仍是一个很小的范围， 因此我们应该根据屏幕大小进行缩放。</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/18/d8a4450b2f3e62d9.png" alt=""></p><p>lesson4中, 我们不考虑移动摄像机的位置, 就简单的摆在(0,0,3)，因此省去了很多麻烦。</p><p>具体需要修改的的就是main函数中将模型的世界坐标转换为屏幕像素坐标那一步, 我们应该添加一个透视效果!</p><p>（纹理和光照会因为坐标变换受到影响吗？）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//main函数</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)        &#123;            texture_coords[j] = model-&gt;<span class="hljs-built_in">face_uvs</span>(i, j);<span class="hljs-comment">//老师是确认了intensity&gt;0才去获取纹理，这样确实提高了效率！</span>            world_coords[j] = model-&gt;<span class="hljs-built_in">face_vet</span>(i, j);            <span class="hljs-comment">//模型坐标不能简单地转换为屏幕坐标,应该经过投影!</span>            screen_coords[j] = <span class="hljs-built_in">trans</span>(world_coords[j], camera, width, height);            screen_texture_coords[j] = <span class="hljs-built_in">Vec2f</span>((texture_coords[j].x * image.<span class="hljs-built_in">get_width</span>()), (texture_coords[j].y * image.<span class="hljs-built_in">get_height</span>()));        &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//trans函数以及另外两个变换函数</span><span class="hljs-function">Vec3f <span class="hljs-title">trans</span><span class="hljs-params">(Vec3f world_coor, Vec3f camera, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span><span class="hljs-function"></span>&#123;    Matrix worldCoor = <span class="hljs-built_in">Matrix</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);    worldCoor[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = world_coor.x;    worldCoor[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = world_coor.y;    worldCoor[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = world_coor.z;    worldCoor[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1.f</span>;    <span class="hljs-comment">//puts(&quot;v2m&quot;);</span>    Matrix temp = <span class="hljs-built_in">project</span>(worldCoor, camera);    <span class="hljs-comment">//puts(&quot;transing&quot;);</span>    Matrix res = <span class="hljs-built_in">viewport</span>(temp, width/<span class="hljs-number">8</span>, height/<span class="hljs-number">8</span>, width*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>, height*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>);    <span class="hljs-comment">//puts(&quot;trans done&quot;);</span>    <span class="hljs-comment">//将res归一并转换为Vec3f</span>    Vec3f screenCoor = <span class="hljs-built_in">Vec3f</span>(res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] / res[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] / res[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], res[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] / res[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]);    <span class="hljs-keyword">return</span> screenCoor;&#125;<span class="hljs-function">Matrix <span class="hljs-title">project</span><span class="hljs-params">(Matrix m, Vec3f camera)</span></span><span class="hljs-function"></span>&#123;    Matrix projection = Matrix::<span class="hljs-built_in">identity</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">//puts(&quot;identity done&quot;);</span>    <span class="hljs-comment">//printf(&quot;%f\n&quot;, tmp);</span>    projection[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">-1.f</span> / camera.z;    <span class="hljs-comment">//puts(&quot;project done&quot;);</span>    <span class="hljs-keyword">return</span> projection * m;&#125;<span class="hljs-function">Matrix <span class="hljs-title">viewport</span><span class="hljs-params">(Matrix M, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span> </span>&#123;    Matrix m = Matrix::<span class="hljs-built_in">identity</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">//将中心点移动到1/2width 和 1/2height的屏幕中央</span>    m[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = x+w/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = y+h/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = depth/<span class="hljs-number">2.f</span>;    <span class="hljs-comment">//将画幅拉伸到3/4屏幕那么大，留白一些</span>    <span class="hljs-comment">//这里是可以自己调的， 老师就是3/4， 我认为这个大小是合适的</span>    m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = w/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = h/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = depth/<span class="hljs-number">2.f</span>;    <span class="hljs-keyword">return</span> m*M;&#125;</code></pre></div><p>OK， 工作到这里就做完啦， 欣赏自己的美图吧！</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/18/8b4f4440a6159741.png" alt=""></p><h1>Lesson 5: Moving the camera</h1><h2 id="前言-2">前言</h2><p>终于要结束无聊的几何部分了！</p><p>这节课更像是对上节课啥都没讲的补偿，介绍了许多基本概念！</p><p>感谢！</p><p>作者在这里要求我们使用模型中自带的法线来实现光照模型！所以我就先做了！记录一下</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//main</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)    &#123;        Vec3f screen_coords[<span class="hljs-number">3</span>];        Vec3f world_coords[<span class="hljs-number">3</span>];        <span class="hljs-type">float</span> intensity[<span class="hljs-number">3</span>];        Vec2f texture_coords[<span class="hljs-number">3</span>];        Vec2f screen_texture_coords[<span class="hljs-number">3</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)        &#123;            texture_coords[j] = model-&gt;<span class="hljs-built_in">face_uvs</span>(i, j);            world_coords[j] = model-&gt;<span class="hljs-built_in">face_vet</span>(i, j);            intensity[j] = model-&gt;<span class="hljs-built_in">face_nrm</span>(i, j) * light_dir;            <span class="hljs-comment">//模型坐标不能简单地转换为屏幕坐标,应该经过投影!</span>            screen_coords[j] = <span class="hljs-built_in">trans</span>(world_coords[j], camera, width, height);            screen_texture_coords[j] = <span class="hljs-built_in">Vec2f</span>((texture_coords[j].x * image.<span class="hljs-built_in">get_width</span>()), (texture_coords[j].y * image.<span class="hljs-built_in">get_height</span>()));        &#125;        <span class="hljs-comment">//完成插值算法</span>        <span class="hljs-comment">//完成纹理映射</span>        Vec3f pts[<span class="hljs-number">3</span>] = &#123;screen_coords[<span class="hljs-number">0</span>], screen_coords[<span class="hljs-number">1</span>], screen_coords[<span class="hljs-number">2</span>]&#125;;        Vec2f texture_pts[<span class="hljs-number">3</span>] = &#123;screen_texture_coords[<span class="hljs-number">0</span>], screen_texture_coords[<span class="hljs-number">1</span>], screen_texture_coords[<span class="hljs-number">2</span>]&#125;;        <span class="hljs-type">float</span> intensity_pts[<span class="hljs-number">3</span>] = &#123;intensity[<span class="hljs-number">0</span>], intensity[<span class="hljs-number">1</span>], intensity[<span class="hljs-number">2</span>]&#125;;            <span class="hljs-built_in">new_triangle</span>(pts, texture_pts, intensity_pts, frame, image);    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//triangle</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = bboxmin.x; x &lt;= bboxmax.x; x++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = bboxmin.y; y &lt;= bboxmax.y; y++)        &#123;            Vec3f coor = <span class="hljs-built_in">barycentric</span>(pts, <span class="hljs-built_in">Vec2i</span>(x, y));            <span class="hljs-keyword">if</span> (coor.x &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.y &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.z &gt;= <span class="hljs-number">0</span>)            &#123;                <span class="hljs-type">float</span> tx = coor.x * texture_pts[<span class="hljs-number">0</span>].x + coor.y * texture_pts[<span class="hljs-number">1</span>].x + coor.z * texture_pts[<span class="hljs-number">2</span>].x;                <span class="hljs-type">float</span> ty = coor.x * texture_pts[<span class="hljs-number">0</span>].y + coor.y * texture_pts[<span class="hljs-number">1</span>].y + coor.z * texture_pts[<span class="hljs-number">2</span>].y;                <span class="hljs-type">float</span> intensity = intensity_pts[<span class="hljs-number">0</span>] * coor.x + intensity_pts[<span class="hljs-number">1</span>] * coor.y + intensity_pts[<span class="hljs-number">2</span>] * coor.z;<span class="hljs-comment">//光照插值！</span>                <span class="hljs-type">float</span> z = (coor.x * pts[<span class="hljs-number">0</span>].z + coor.y * pts[<span class="hljs-number">1</span>].z + coor.z * pts[<span class="hljs-number">2</span>].z);                TGAColor color = texture.<span class="hljs-built_in">get</span>(tx, ty);                <span class="hljs-keyword">if</span> (zBuffer[x + y * width] &lt; (<span class="hljs-type">int</span>)z)                &#123;                    <span class="hljs-comment">//printf(&quot;z:%d zbuffer: %d \n&quot;, (int)z, zBuffer[x + y * width]);</span>                        zBuffer[x + y * width] = (<span class="hljs-type">int</span>)z;                        <span class="hljs-keyword">if</span>(intensity&lt;<span class="hljs-number">0</span>)                            intensity = <span class="hljs-number">0</span>;<span class="hljs-comment">//这里是个大坑！！如果intensity&lt;0,因为没有环境光，因此应该是全黑，就是0，我调了好久才发现！</span>                        image.<span class="hljs-built_in">set</span>(x, y, <span class="hljs-built_in">TGAColor</span>(intensity * color.r, intensity * color.g, intensity * color.b, color.a));                        <span class="hljs-comment">//image.set(x, y, color);</span>                &#125;            &#125;        &#125;    &#125;</code></pre></div><p><img src="https://s3.bmp.ovh/imgs/2022/05/18/a576ddf33dc3ecb1.png" alt=""></p><p>此时（光源为 <code>Vec3f light_dir = Vec3f(1,-1,1).normalize();</code>）的效果图！（不知道为啥有点磨损，在我屏幕上效果还要更好点。。）</p><h2 id="变换基坐标">变换基坐标</h2><p>正如我前面提到的一样，我不是很想讲数学， 感兴趣可以看原文，大致交待了几点：</p><ol><li>如何确定摄像机的方位： e（eye）和u（up）两个向量</li><li>物体处于世界坐标，而我们需要得到物体以摄像机为原点的坐标</li><li>如何确定摄像机的坐标系：c（物体）e向量直接为z’轴，x’轴为u x z’ ，y’轴为z’ x  x’</li><li>如何变换矩阵是什么？</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lookat</span><span class="hljs-params">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;    Vec3f z = (eye-center).<span class="hljs-built_in">normalize</span>();    Vec3f x = <span class="hljs-built_in">cross</span>(up,z).<span class="hljs-built_in">normalize</span>();    Vec3f y = <span class="hljs-built_in">cross</span>(z,x).<span class="hljs-built_in">normalize</span>();    Matrix Minv = Matrix::<span class="hljs-built_in">identity</span>();    Matrix Tr   = Matrix::<span class="hljs-built_in">identity</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) &#123;        Minv[<span class="hljs-number">0</span>][i] = x[i];        Minv[<span class="hljs-number">1</span>][i] = y[i];        Minv[<span class="hljs-number">2</span>][i] = z[i];        Tr[i][<span class="hljs-number">3</span>] = -eye[i];    &#125;    ModelView = Minv*Tr;&#125;</code></pre></div><p>变换矩阵为 <code>ModelView</code>， 名字来源于OPENGL</p><h2 id="视口变换">视口变换</h2><p>视口变换将模型从[-1,1] * [-1,1] * [-1,1]的小正方体转换为 [x,x+w] * [y,y+h] * [0,d]的适于屏幕的立方体。depth取255是为了方便调试。</p><p>上节课我们都写过了。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Matrix <span class="hljs-title">viewport</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span> </span>&#123;    Matrix m = Matrix::<span class="hljs-built_in">identity</span>(<span class="hljs-number">4</span>);    m[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = x+w/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = y+h/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = depth/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = w/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = h/<span class="hljs-number">2.f</span>;    m[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = depth/<span class="hljs-number">2.f</span>;    <span class="hljs-keyword">return</span> m;&#125;</code></pre></div><hr><div class="note note-primary">            <p>这是部分原文，我认为很好，值得抄录下来</p>          </div><p>So, let us sum up. Our models (characters, for example) are created in their own local frame ( <strong>object coordinates</strong> ). They are inserted into a scene expressed in  <strong>world coordinates</strong> . The transformation from one to another is made with matrix  <strong>Model</strong> . Then, we want to express it in the camera frame ( <strong>eye coordinates</strong> ), the transformation is called  <strong>View</strong> . Then, we deform the scene to create a perspective deformation with <strong>Projection</strong> matrix (<a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-4:-perspective-projection">lesson 4</a>), this matrix transforms the scene to so-called  <strong>clip coordinates</strong> . Finally, we draw the scene, and the matrix transforming clip coordinates to the <strong>screen coordinates</strong> is called  <strong>Viewport</strong> .</p><p>Again, if we read a point <strong>v</strong> from the .obj file, then to draw it on the screen it undergoes the following chain of transformations:</p><div class="code-wrapper"><pre><code class="hljs c++">Viewport * Projection * View * Model * v.</code></pre></div><p>If you look to <a href="https://github.com/ssloy/tinyrenderer/blob/10723326bb631d081948e5346d2a64a0dd738557/main.cpp">this</a> commit, then you will see the following lines:</p><div class="code-wrapper"><pre><code class="hljs c++">Vec3f v = model-&gt;<span class="hljs-built_in">vert</span>(face[j]);screen_coords[j] =  <span class="hljs-built_in">Vec3f</span>(ViewPort*Projection*ModelView*<span class="hljs-built_in">Matrix</span>(v));</code></pre></div><p>As i draw a single object only, the matrix Model is equal to identity, and i merged it with the matrix View.</p><p>解释一下最后一句话， 因为我们只渲染这一个人头，因此不需要将模型从本地坐标转换到世界坐标，因此略去。</p><hr><h2 id="关于法线">关于法线</h2><p>当模型被scaling的时候， 如果不是uniform的，那么法线的坐标不应该和坐标点一起变换！</p><p>不信你自己试试！</p><p>事实上，当物体进行坐标变换的时候，法线应当进行该坐标变换的逆变换——这是由一个简单的数学原理支持的：</p><p><img src="https://s3.bmp.ovh/imgs/2022/08/31/e822383a088a2862.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2022/08/31/f7843086a4aa9768.png" alt=""></p><p>可以看到，当坐标变换M应用于坐标上时，法线相应的应该右乘上M的逆矩阵。</p><p>经过修饰，最终写成这样的形式：</p><p><img src="https://s3.bmp.ovh/imgs/2022/08/31/a86ad4081971d68a.png" alt=""></p><h2 id="最终效果">最终效果</h2><p><img src="https://s3.bmp.ovh/imgs/2022/05/27/4e41cf9dea3242cf.png" alt=""></p><p>这是我们移动摄像机后的样子，可以看到跟随着我们移动摄像机，视角也发生了变化！</p><p>移动摄像机主要是发生在Modelview矩阵，贴代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Matrix <span class="hljs-title">modelview</span><span class="hljs-params">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;    Vec3f z = (eye-center).<span class="hljs-built_in">normalize</span>();    Vec3f x = (up^z).<span class="hljs-built_in">normalize</span>();    Vec3f y = (z^x).<span class="hljs-built_in">normalize</span>();    Matrix res = Matrix::<span class="hljs-built_in">identity</span>(<span class="hljs-number">4</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) &#123;        res[<span class="hljs-number">0</span>][i] = x[i];        res[<span class="hljs-number">1</span>][i] = y[i];        res[<span class="hljs-number">2</span>][i] = z[i];        res[i][<span class="hljs-number">3</span>] = -center[i];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图形学</category>
      
      <category>TinyRenderer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>C++</tag>
      
      <tag>TinyRenderer</tag>
      
      <tag>软件光栅化渲染器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习资源</title>
    <link href="/2022/05/14/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <url>/2022/05/14/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>收集记录一些资源, 分享给大家</p><h1>数学</h1><h2 id="工科高等代数（大一上）">工科高等代数（大一上）</h2><p>代数是非常重要的，甚至在我的理解里比高数更重要。代数的重点在于理解。</p><p><a href="https://www.bilibili.com/video/BV1ys411472E?p=1">【官方双语/合集】线性代数的本质 - 系列合集</a></p><p>讲述了线性代数比较基础，但是非常本质的知识！很好很好，有中文。</p><p><a href="https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/">MIT 18.06</a> by Prof. <a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/Gilbert%2520Strang/1393216%3Ffr%3Daladdin">Gilbert Strang</a> from MIT</p><p>一般都知道的，很有名，很经典，也很好！</p><h2 id="离散数学">离散数学</h2><p>水课随便学学得了，平时好好做作业，期末好好复习，别浪费时间。</p><h1>计算机基础</h1><div class="note note-primary">            <p><strong>基本认识计算机系统</strong> 大一上学期可以尝试自学 <a href="https://www.nand2tetris.org">nand2tetris</a>。这门课程难度不大，硬件部分不需要太多的前序知识，软件部分用基本的 C++ 也足够了。在这门课程中，学生需要从电路开始搭建各种硬件模块，组成 CPU；接着手写汇编器、VM 和编译器，在 CPU 上运行自己写的程序。在这一过程中，学生可以了解如何从晶体管一步步造出计算机，对计算机系统有基本的认识。</p><p><strong>深入理解计算机系统</strong> 大一下学期可以开始自学<a href="http://csapp.cs.cmu.edu">《深入理解计算机系统》</a> (CS:APP)。我推荐英文的第三版（写这篇文章时候的最新版）。书上的内容通俗易懂，辅以课后练习和 lab 可以达到更好的学习效果。CS:APP 涵盖了 CS 某三门专业课的基本内容。2, 3, 6 章的汇编语言、内存层级涵盖了计算机组成的一部分内容。第 4 章 Y86-64 处理器对应计算机系统结构的课程的前半部分。6, 9, 12 章关于虚拟内存和并发编程涵盖了操作系统课程的一部分内容。全书通过对 Intel x86(_64) 架构的案例分析，从底层硬件到上层软件，整体介绍了一个计算机系统。从这个角度来说，大一下开始学习这些内容，不仅可以了解 Intel x86 这一常用的计算机系统，也能弥补专业课和基础课之间的断层。</p><p>from <a href="https://www.skyzh.dev/pages/about/">csx</a></p>          </div><p>上面两门课并没有完全对应buaa课程安排的某门课，因此我将其单独列出来。</p><p>值得一提的是，软院的话感觉学一学nand2tetris就够了，只求了解，帮助你梳理，但是难度是不够的。</p><p>CSAPP虽然是神课，但是会给人造成过大的压力，因此量力而行，适合有追求的人。</p><h2 id="数据结构（大一下）">数据结构（大一下）</h2><p>数据结构（仅限课程要求）在我看来是一个<strong>简单</strong>的东西，因为思维量非常小，同时需要掌握的内容非常少，难度主要体现在工程量、算法和读题上。</p><p>学好数据结构我认为老师不重要，自己肯动手干、肯亲手实现所有的数据结构最重要，因此：</p><p><a href="https://leetcode.cn/">LeetCode</a> 你最好的老师，请在学习专区刷掉所有数据结构相关的leet书，这样就入门了，谢谢！</p><p><a href="https://www.xuetangx.com/course/THU08091002048/10322575">数据结构</a> by 邓俊辉 from 清华 如果一定想看网课，那就看这个吧，享有盛名。</p><h2 id="算法（大二上）">算法（大二上）</h2><p><a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DOQ5jsbhAv_M">算法导论</a> by Prof. Erik Demaine from MIT</p><p><a href="https://leetcode.cn/">LeetCode</a> 你最好的老师！学什么就课后多刷几道，掌握系统性的编写方法。</p><h2 id="计算机组成原理（大二上）">计算机组成原理（大二上）</h2><p><a href="https://www.nand2tetris.org">nand2tetris</a> 对于软院学生的弱化版计组，我认为学这个应该就可以了。（时间不多就算了，毕竟其实不是特别的对应）</p><h2 id="计算机操作系统">计算机操作系统</h2><p>操作系统 from MIT 6.828: <a href="https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2017">MIT</a>, <a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DkDRHsNauoxk%26list%3DPLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP">youtube</a></p><h2 id="数据库系统">数据库系统</h2><p>数据库 from MIT 6.830: <a href="https://link.zhihu.com/?target=http%3A//db.csail.mit.edu/6.830/">MIT</a>, <a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DF3XGUPll6Qs%26list%3DPLfciLKR3SgqOxCy1TIXXyfTqKzX2enDjK">youbube</a></p><h2 id="计算机网络">计算机网络</h2><h1>图形学</h1>]]></content>
    
    
    <categories>
      
      <category>生活随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>想法</tag>
      
      <tag>学习路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyRenderer 2&amp;3</title>
    <link href="/2022/05/14/TinyRenderer-2-3/"/>
    <url>/2022/05/14/TinyRenderer-2-3/</url>
    
    <content type="html"><![CDATA[<h1>Lesson 2: Triangle rasterization and back face culling</h1><h2 id="1-尝试画一个三角形-old-school">1.尝试画一个三角形(old-school)</h2><p>画一个三角形看似简单,但是又很难!</p><p>先想想如何画一个三角形(不要忘了光栅化的前提:像素的概念)</p><p>首先, 画一个三角形框吧!</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">triangle</span><span class="hljs-params">(Vec2i v0, Vec2i v1, Vec2i v2, TGAImage &amp;image, TGAColor color)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">line</span>(v0.x, v0.y, v1.x, v1.y, image, color);<span class="hljs-built_in">line</span>(v1.x, v1.y, v2.x, v2.y, image, color);<span class="hljs-built_in">line</span>(v0.x, v0.y, v2.x, v2.y, image, color);&#125;</code></pre></div><p>很简单!</p><p>在主函数里调用此方法:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;TGAImage image = <span class="hljs-built_in">TGAImage</span>(width, height, TGAImage::RGB);Vec2i t0[<span class="hljs-number">3</span>] = &#123;<span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">10</span>, <span class="hljs-number">70</span>),   <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">50</span>, <span class="hljs-number">160</span>),  <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">70</span>, <span class="hljs-number">80</span>)&#125;; Vec2i t1[<span class="hljs-number">3</span>] = &#123;<span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">180</span>, <span class="hljs-number">50</span>),  <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">150</span>, <span class="hljs-number">1</span>),   <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">70</span>, <span class="hljs-number">180</span>)&#125;; Vec2i t2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">180</span>, <span class="hljs-number">150</span>), <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">120</span>, <span class="hljs-number">160</span>), <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">130</span>, <span class="hljs-number">180</span>)&#125;; <span class="hljs-built_in">triangle</span>(t0[<span class="hljs-number">0</span>], t0[<span class="hljs-number">1</span>], t0[<span class="hljs-number">2</span>], image, red); <span class="hljs-built_in">triangle</span>(t1[<span class="hljs-number">0</span>], t1[<span class="hljs-number">1</span>], t1[<span class="hljs-number">2</span>], image, white); <span class="hljs-built_in">triangle</span>(t2[<span class="hljs-number">0</span>], t2[<span class="hljs-number">1</span>], t2[<span class="hljs-number">2</span>], image, green);image.<span class="hljs-built_in">flip_vertically</span>();     image.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;output.tga&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>我们得到想要的图形:</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/d4f5acfb711300b2.png" alt=""></p><p>接着,想办法填充吧!</p><p>提醒:将三角形水平分割.</p><div class="note note-primary">            <p>无论是原作者还是笔者, 都强烈建议您在接着往下看之前先自己尝试实现此功能! 自己实在写不出来或者写出来了再往下看!</p>          </div><p>贴一份我自己的代码吧(比较稚嫩)</p><div class="code-wrapper"><pre><code class="hljs cpp">//<span class="hljs-function">draw a triangle use line the function</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">triangle</span><span class="hljs-params">(Vec2i v0, Vec2i v1, Vec2i v2, TGAImage &amp;image, TGAColor color)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//排序</span>    <span class="hljs-keyword">if</span>(v0.y&gt;v1.y)     &#123;        Vec2i temp = v0;        v0 = v1;        v1 = temp;    &#125;    <span class="hljs-keyword">if</span>(v1.y&gt;v2.y)    &#123;        Vec2i temp = v1;        v1 = v2;        v2= temp;    &#125;    <span class="hljs-keyword">if</span>(v0.y&gt;v1.y)    &#123;        Vec2i temp = v0;        v0 = v1;        v1 = temp;    &#125;    <span class="hljs-type">float</span> x3 = (<span class="hljs-type">float</span>)v0.y + (<span class="hljs-type">float</span>)(v1.y - v0.y) * (v2.x - v0.x) / (v2.y - v0.y);    <span class="hljs-type">float</span> dx1 = (<span class="hljs-type">float</span>)(v2.x - v0.x) / (v2.y - v0.y);    <span class="hljs-type">float</span> dx2 = (<span class="hljs-type">float</span>)(v1.x - v0.x) / (v1.y - v0.y);    <span class="hljs-comment">//printf(&quot;dx1:%f dx2:%f\n&quot;, dx1, dx2);</span>    <span class="hljs-keyword">if</span> (dx1 &gt; dx2)        std::<span class="hljs-built_in">swap</span>(dx1, dx2);    <span class="hljs-type">float</span> xleft = (<span class="hljs-type">float</span>)v0.x, xright = (<span class="hljs-type">float</span>)v0.x;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = v0.y; y &lt; v1.y; y++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = std::<span class="hljs-built_in">ceil</span>(xleft); x &lt;= std::<span class="hljs-built_in">floor</span>(xright); x++)        &#123;            image.<span class="hljs-built_in">set</span>(x, y, color);        &#125;        xleft += dx1;        xright += dx2;    &#125;    dx1 = (<span class="hljs-type">float</span>)(v2.x - v0.x) / (v2.y - v0.y);    dx2 = (<span class="hljs-type">float</span>)(v2.x - v1.x) / (v2.y - v1.y);    <span class="hljs-keyword">if</span> (dx1 &gt; dx2)        std::<span class="hljs-built_in">swap</span>(dx1, dx2);    xleft = (<span class="hljs-type">float</span>)v2.x, xright = (<span class="hljs-type">float</span>)v2.x;    <span class="hljs-comment">//printf(&quot;dx1:%f dx2:%f\n&quot;, dx1, dx2);</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = v2.y; y &gt;= v1.y; y--)    &#123;         <span class="hljs-comment">//printf(&quot;%f %f\n&quot;, xleft, xright);</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = std::<span class="hljs-built_in">ceil</span>(xleft); x &lt;= std::<span class="hljs-built_in">floor</span>(xright); x++)        &#123;            image.<span class="hljs-built_in">set</span>(x, y, color);        &#125;        xleft -= dx2;        xright -= dx1;    &#125;&#125;</code></pre></div><p>再贴一份大神的研读一下,我自己写了一些注释</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">triangle</span><span class="hljs-params">(Vec2i t0, Vec2i t1, Vec2i t2, TGAImage &amp;image, TGAColor color)</span> </span>&#123;     <span class="hljs-keyword">if</span> (t0.y==t1.y &amp;&amp; t0.y==t2.y) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// I dont care about degenerate triangles </span>    <span class="hljs-comment">// sort the vertices, t0, t1, t2 lower−to−upper (bubblesort yay!) </span>    <span class="hljs-comment">// 排序! 写的比我简洁很多! 我都不知道原来vec2i也可以swap</span>    <span class="hljs-keyword">if</span> (t0.y&gt;t1.y) std::<span class="hljs-built_in">swap</span>(t0, t1);     <span class="hljs-keyword">if</span> (t0.y&gt;t2.y) std::<span class="hljs-built_in">swap</span>(t0, t2);     <span class="hljs-keyword">if</span> (t1.y&gt;t2.y) std::<span class="hljs-built_in">swap</span>(t1, t2);     <span class="hljs-type">int</span> total_height = t2.y-t0.y;     <span class="hljs-comment">//降低可读性换取代码的整洁和易修改, 可以的</span>    <span class="hljs-comment">//大神的填充三角形的方法和我想的差不多,对于每个y找到x的左右边界  </span>    <span class="hljs-comment">//大神没有考虑边界的问题是否取的问题, 效果也不错</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;total_height; i++) &#123;         <span class="hljs-type">bool</span> second_half = i&gt;t1.y-t0.y || t1.y==t0.y;         <span class="hljs-type">int</span> segment_height = second_half ? t2.y-t1.y : t1.y-t0.y;         <span class="hljs-type">float</span> alpha = (<span class="hljs-type">float</span>)i/total_height;         <span class="hljs-type">float</span> beta  = (<span class="hljs-type">float</span>)(i-(second_half ? t1.y-t0.y : <span class="hljs-number">0</span>))/segment_height; <span class="hljs-comment">// be careful: with above conditions no division by zero here </span>        Vec2i A =               t0 + (t2-t0)*alpha;         Vec2i B = second_half ? t1 + (t2-t1)*beta : t0 + (t1-t0)*beta;         <span class="hljs-keyword">if</span> (A.x&gt;B.x) std::<span class="hljs-built_in">swap</span>(A, B);         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=A.x; j&lt;=B.x; j++) &#123;             image.<span class="hljs-built_in">set</span>(j, t0.y+i, color); <span class="hljs-comment">// attention, due to int casts t0.y+i != A.y </span>        &#125;     &#125; &#125;</code></pre></div><h2 id="2-新潮一些的方法">2.新潮一些的方法</h2><p>上面介绍的方法是一种非常传统和老旧的方法(当时是在单线程电脑上运行),其实随着电脑硬件的发展,目前即使是民用PC也支持超多线程的运算了.这样写代码,效率是低下的.不如我们来想想怎么写效率才高?</p><p>至少对于笔者而言,我也不知道怎么才能针对多线程进行优化, 代码运行的底层原理知识笔者严重缺失,因此直接贴出来:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">triangle</span>(vec2 points[<span class="hljs-number">3</span>]) &#123;     vec2 bbox[<span class="hljs-number">2</span>] = <span class="hljs-built_in">find_bounding_box</span>(points);     <span class="hljs-keyword">for</span> (each pixel in the bounding box) &#123;         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">inside</span>(points, pixel)) &#123;             <span class="hljs-built_in">put_pixel</span>(pixel);         &#125;     &#125; &#125;</code></pre></div><p>在笔者熟悉的算法竞赛和课程中,这样写的效率是非常低的.</p><p>但是大神说这是一种针对多线程更优的写法,那笔者就先记住吧,等以后再来想为什么.</p><p>其实这个伪代码对于上过games101的人来说应该在熟悉不过了.</p><p>一起来看看这段伪代码:</p><p>首先,我们找到三角形的包围盒(这是很简单的)</p><p>然后,我们对于盒内每个点判断其是否在三角形内</p><p>这是很复杂的.有很多方法,但是最主流的需要用到重心坐标的概念</p><p>$P = \alpha A + \beta B + \gamma C $</p><p>若P在三角形外,则必有坐标为负</p><p>贴一下我自己的实现</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">barycentric</span><span class="hljs-params">(Vec2i *pts, Vec2i P)</span> </span>&#123;    Vec3f u1 = <span class="hljs-built_in">Vec3f</span>(pts[<span class="hljs-number">2</span>].x - pts[<span class="hljs-number">0</span>].x, pts[<span class="hljs-number">1</span>].x - pts[<span class="hljs-number">0</span>].x, pts[<span class="hljs-number">0</span>].x - P.x);    Vec3f u2 = <span class="hljs-built_in">Vec3f</span>(pts[<span class="hljs-number">2</span>].y - pts[<span class="hljs-number">0</span>].y, pts[<span class="hljs-number">1</span>].y - pts[<span class="hljs-number">0</span>].y, pts[<span class="hljs-number">0</span>].y - P.y);    Vec3f u = <span class="hljs-built_in">Vec3f</span>(u1.y * u2.z - u1.z * u2.y, u1.z * u2.x - u1.x * u2.z, u1.x * u2.y - u1.y * u2.x);    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(u.z) &lt; <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z); &#125; <span class="hljs-comment">//draw a triangle use a new way</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_triangle</span><span class="hljs-params">(Vec2i *pts, TGAImage &amp;image, TGAColor color)</span></span><span class="hljs-function"></span>&#123;    Vec2i bboxmin = <span class="hljs-built_in">Vec2i</span>(image.<span class="hljs-built_in">get_width</span>() - <span class="hljs-number">1</span>, image.<span class="hljs-built_in">get_height</span>() - <span class="hljs-number">1</span>);    Vec2i bboxmax = <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-keyword">if</span>(pts[i].x&gt;bboxmax.x)            bboxmax.x = pts[i].x;        <span class="hljs-keyword">if</span>(pts[i].y&gt;bboxmax.y)            bboxmax.y = pts[i].y;        <span class="hljs-keyword">if</span>(pts[i].x&lt;bboxmin.x)            bboxmin.x = pts[i].x;        <span class="hljs-keyword">if</span>(pts[i].y&lt;bboxmin.y)            bboxmin.y = pts[i].y;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = bboxmin.x; x &lt;= bboxmax.x; x++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = bboxmin.y; y &lt;= bboxmax.y; y++)        &#123;            Vec3f coor = <span class="hljs-built_in">barycentric</span>(pts, <span class="hljs-built_in">Vec2i</span>(x, y));            <span class="hljs-comment">//printf(&quot;%f %f %f\n&quot;, coor.x, coor.y, coor.z);</span>            <span class="hljs-keyword">if</span> (coor.x &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.y &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.z &gt;= <span class="hljs-number">0</span>)            &#123;                <span class="hljs-comment">//puts(&quot;set&quot;);</span>                image.<span class="hljs-built_in">set</span>(x, y, color);            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="3-试着用这种方法填充之前的模型">3.试着用这种方法填充之前的模型</h2><p>还记得在bresenham的画线的章节里我们使用的模型吗?</p><p>现在我们有能力为他上色啦!</p><p>先用随机颜色上色,这样我们可以观察渲染是如何进行的,然后,再根据光照上色,这样我们就完成了一个简单的渲染器!</p><p>先使用随机的颜色吧!</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//main函数</span><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>==argc) &#123;        model = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Model</span>(argv[<span class="hljs-number">1</span>]);    &#125; <span class="hljs-keyword">else</span> &#123;        model = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Model</span>(<span class="hljs-string">&quot;obj/african_head.obj&quot;</span>);    &#125;    <span class="hljs-function">TGAImage <span class="hljs-title">frame</span><span class="hljs-params">(width, height, TGAImage::RGB)</span></span>;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)     &#123;         std::vector&lt;<span class="hljs-type">int</span>&gt; face = model-&gt;<span class="hljs-built_in">face</span>(i);         Vec2i screen_coords[<span class="hljs-number">3</span>];         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">3</span>; j++) &#123;             Vec3f world_coords = model-&gt;<span class="hljs-built_in">vert</span>(face[j]);             screen_coords[j] = <span class="hljs-built_in">Vec2i</span>((world_coords.x+<span class="hljs-number">1.</span>)*width/<span class="hljs-number">2.</span>, (world_coords.y+<span class="hljs-number">1.</span>)*height/<span class="hljs-number">2.</span>);         &#125;        Vec2i pts[<span class="hljs-number">3</span>] = &#123;screen_coords[<span class="hljs-number">0</span>], screen_coords[<span class="hljs-number">1</span>], screen_coords[<span class="hljs-number">2</span>]&#125;;        <span class="hljs-built_in">new_triangle</span>(pts, frame, <span class="hljs-built_in">TGAColor</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">255</span>, <span class="hljs-built_in">rand</span>() % <span class="hljs-number">255</span>, <span class="hljs-built_in">rand</span>() % <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));    &#125;    frame.<span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// to place the origin in the bottom left corner of the image </span>    frame.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;framebuffer.tga&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><p>我们可以看到, model里面储存的是世界坐标, 是一群被压缩在[-1,1]^2的点. 为了使其铺满屏幕,我们需要进行一定的转化.</p><p>那么, 如何结合光照呢? 在讨论布林冯等模型之前,我们不如先进行简单的线性建模</p><p>先确立光线的方向 <code>Vec3f light_dir(0,0,-1)</code>,此处明显是平行光.</p><p>那不妨直接将每个面的亮暗设置为 <code>n*light_dir</code>, n为一个面的单位法向量.</p><p>下面为我的代码:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Vec3f <span class="hljs-title">light_dir</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)    &#123;         std::vector&lt;<span class="hljs-type">int</span>&gt; face = model-&gt;<span class="hljs-built_in">face</span>(i);         Vec2i screen_coords[<span class="hljs-number">3</span>];        Vec3f world_coords[<span class="hljs-number">3</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)        &#123;            world_coords[j] = model-&gt;<span class="hljs-built_in">vert</span>(face[j]);             screen_coords[j] = <span class="hljs-built_in">Vec2i</span>((world_coords[j].x+<span class="hljs-number">1.</span>)*width/<span class="hljs-number">2.</span>, (world_coords[j].y+<span class="hljs-number">1.</span>)*height/<span class="hljs-number">2.</span>);        &#125;        Vec3f n = (world_coords[<span class="hljs-number">2</span>]-world_coords[<span class="hljs-number">0</span>])^(world_coords[<span class="hljs-number">1</span>]-world_coords[<span class="hljs-number">0</span>]);        n.<span class="hljs-built_in">normalize</span>();        <span class="hljs-type">float</span> intensity = n * light_dir;Vec2i pts[<span class="hljs-number">3</span>] = &#123;screen_coords[<span class="hljs-number">0</span>], screen_coords[<span class="hljs-number">1</span>], screen_coords[<span class="hljs-number">2</span>]&#125;;        <span class="hljs-built_in">new_triangle</span>(pts, frame, <span class="hljs-built_in">TGAColor</span>(intensity * <span class="hljs-number">255</span>, intensity * <span class="hljs-number">255</span>, intensity * <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));    &#125;    frame.<span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// to place the origin in the bottom left corner of the image </span>    frame.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;framebuffer.tga&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><h1>Lesson 3: Hidden faces removal (z buffer)</h1><h2 id="1-zBuffer储存深度">1.zBuffer储存深度</h2><p>现在我们已经可以渲染一个面啦!很好!</p><p>但是还有一个问题没解决----不同面的遮挡关系该如何处理?</p><p>在原来代码中, 越晚渲染的面在越前面, 这固然有一定的道理, 但是这不是现实生活</p><p>我们要理解光栅化其实是把三维空间里的模型二维化, 然后以一定的比例投影到屏幕上的过程, 那么, 任何一个点一定有他的深度----也就是z轴的大小.</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/6a05ca12f47aff17.png" alt=""></p><p>看看这个图, 如果能成功渲染这个画面, 是不是有点三维的感觉了?</p><p>使用Z-buffer数组来储存, 通过重心坐标来计算每点P的z值, 并更新z-buffer</p><p>下面贴一下我的改良后的triangle代码:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_triangle</span><span class="hljs-params">(Vec3f *pts, <span class="hljs-type">float</span> *zBuffer, TGAImage &amp;image, TGAColor color)</span></span><span class="hljs-function"></span>&#123;    Vec2i bboxmin = <span class="hljs-built_in">Vec2i</span>(image.<span class="hljs-built_in">get_width</span>() - <span class="hljs-number">1</span>, image.<span class="hljs-built_in">get_height</span>() - <span class="hljs-number">1</span>);    Vec2i bboxmax = <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-keyword">if</span>(pts[i].x&gt;bboxmax.x)            bboxmax.x = pts[i].x;        <span class="hljs-keyword">if</span>(pts[i].y&gt;bboxmax.y)            bboxmax.y = pts[i].y;        <span class="hljs-keyword">if</span>(pts[i].x&lt;bboxmin.x)            bboxmin.x = pts[i].x;        <span class="hljs-keyword">if</span>(pts[i].y&lt;bboxmin.y)            bboxmin.y = pts[i].y;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = bboxmin.x; x &lt;= bboxmax.x; x++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = bboxmin.y; y &lt;= bboxmax.y; y++)        &#123;            Vec3f coor = <span class="hljs-built_in">barycentric</span>(pts, <span class="hljs-built_in">Vec2i</span>(x, y));            <span class="hljs-keyword">if</span> (coor.x &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.y &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.z &gt;= <span class="hljs-number">0</span>)            &#123;                <span class="hljs-type">float</span> z = coor.x * pts[<span class="hljs-number">0</span>].z + coor.y * pts[<span class="hljs-number">1</span>].z + coor.z * pts[<span class="hljs-number">2</span>].z;                <span class="hljs-keyword">if</span> (zBuffer[x + y * width] &lt; z)                &#123;                    zBuffer[x + y * width] = z;                    image.<span class="hljs-built_in">set</span>(x, y, color);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>干脆把主函数也贴一下, 以免有人不知道该怎么获取深度</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">float</span> zBuffer[width * height];<span class="hljs-comment">//创建zbuffer数组</span><span class="hljs-built_in">memset</span>(zBuffer, <span class="hljs-number">-10</span>, <span class="hljs-built_in">sizeof</span>(zBuffer));<span class="hljs-comment">//初始化zbuffer数组</span>  <span class="hljs-comment">//此处需要注意,在obj文件中,点的深度均处于[-1,0],如果不进行初始化或者把z转换为负数,会显示错误</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)&#123;     std::vector&lt;<span class="hljs-type">int</span>&gt; face = model-&gt;<span class="hljs-built_in">face</span>(i);     Vec3f screen_coords[<span class="hljs-number">3</span>];    Vec3f world_coords[<span class="hljs-number">3</span>];    TGAColor color;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)    &#123;        world_coords[j] = model-&gt;<span class="hljs-built_in">vert</span>(face[j]);           screen_coords[j] = <span class="hljs-built_in">Vec3f</span>((world_coords[j].x+<span class="hljs-number">1.</span>)*width/<span class="hljs-number">2.</span>, (world_coords[j].y+<span class="hljs-number">1.</span>)*height/<span class="hljs-number">2.</span>, world_coords[j].z);    &#125;    Vec3f n = (world_coords[<span class="hljs-number">2</span>]-world_coords[<span class="hljs-number">0</span>])^(world_coords[<span class="hljs-number">1</span>]-world_coords[<span class="hljs-number">0</span>]);    n.<span class="hljs-built_in">normalize</span>();    <span class="hljs-type">float</span> intensity = n * light_dir; Vec3f pts[<span class="hljs-number">3</span>] = &#123;screen_coords[<span class="hljs-number">0</span>], screen_coords[<span class="hljs-number">1</span>], screen_coords[<span class="hljs-number">2</span>]&#125;;    <span class="hljs-keyword">if</span>(intensity&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//别忘了,很重要</span>        <span class="hljs-built_in">new_triangle</span>(pts, zBuffer, frame, <span class="hljs-built_in">TGAColor</span>(intensity * <span class="hljs-number">255</span>, intensity * <span class="hljs-number">255</span>, intensity * <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));&#125;</code></pre></div><h2 id="2-填充纹理吧">2.填充纹理吧</h2><p>此时, 一个模型大体的轮廓已经初步创建, 那么 ,我们还能做什么呢???</p><p>没错! 填充纹理!!</p><p>在obj文件中, 除了存放了模型本身的面和点, 也存放了每个点对应的纹理坐标. 通过这些映射关系, 我们对于每个特定的像素(x,y)都可以在纹理图上映射为(u,v)并获取该点的颜色为该像素上色.</p><div class="code-wrapper"><pre><code class="hljs cpp">vt  <span class="hljs-number">0.532</span> <span class="hljs-number">0.923</span> <span class="hljs-number">0.000</span> <span class="hljs-comment">//存放了第i个纹理图上的点</span>f <span class="hljs-number">24</span>/<span class="hljs-number">1</span>/<span class="hljs-number">24</span> <span class="hljs-number">25</span>/<span class="hljs-number">2</span>/<span class="hljs-number">25</span> <span class="hljs-number">26</span>/<span class="hljs-number">3</span>/<span class="hljs-number">26</span> <span class="hljs-comment">//存放了某个面的对应信息</span><span class="hljs-comment">//格式：&quot;f 顶点索引/uv点索引/法线索引&quot;</span></code></pre></div><p>想要完成这个作业有两个难点,一是读取纹理信息, 二是对纹理插值</p><p>其实我觉得老师对于这个地方的处理不算是很好, 因为没有告诉你应该怎么去做, 而是想让你凭空去创造obj的读取方法.(不排除这就是老师的本意!</p><p>既然如此,那就硬着头皮上呗!</p><p>理解obj文件的解析原理是关键, 如果能理解, 这个代码其实并不难, 就是普通的模拟题.</p><p>obj文件里面还每个点的法线信息, 干脆也一起敲了</p><p>下面分享一下我的model.h和model.cpp</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//model.h</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MODEL_H__</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MODEL_H__</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;geometry.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tgaimage.h&quot;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> &#123;<span class="hljs-keyword">private</span>:std::vector&lt;Vec3f&gt; verts_;<span class="hljs-comment">//添加储存纹理坐标和法线的方法</span>std::vector&lt;Vec2f&gt; uvs_; std::vector&lt;Vec3f&gt; nrms_;std::vector&lt;<span class="hljs-type">int</span>&gt; faces_vet;std::vector&lt;<span class="hljs-type">int</span>&gt; faces_uvs;std::vector&lt;<span class="hljs-type">int</span>&gt; faces_nrm;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_texture</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string *filename, TGAImage &amp;texture)</span></span>;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Model</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename);~<span class="hljs-built_in">Model</span>();<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nverts</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nfaces</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nuvs</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nnrms</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Vec3f <span class="hljs-title">vert</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-function">Vec2f <span class="hljs-title">uvs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-function">Vec3f <span class="hljs-title">nrms</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<span class="hljs-function">Vec2f <span class="hljs-title">face_uvs</span><span class="hljs-params">(<span class="hljs-type">int</span> facei, <span class="hljs-type">int</span> idx)</span></span>;<span class="hljs-function">Vec3f <span class="hljs-title">face_vet</span><span class="hljs-params">(<span class="hljs-type">int</span> facei, <span class="hljs-type">int</span> idx)</span></span>;<span class="hljs-function">Vec3f <span class="hljs-title">face_nrm</span><span class="hljs-params">(<span class="hljs-type">int</span> facei, <span class="hljs-type">int</span> idx)</span></span>;&#125;;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//__MODEL_H__</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;model.h&quot;</span></span>Model::<span class="hljs-built_in">Model</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)&#123;    std::ifstream in;    in.<span class="hljs-built_in">open</span> (filename, std::ifstream::in);    <span class="hljs-keyword">if</span> (in.<span class="hljs-built_in">fail</span>()) <span class="hljs-keyword">return</span>;    std::string line;    <span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">eof</span>()) &#123;        std::<span class="hljs-built_in">getline</span>(in, line);        <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(line.c_str())</span></span>;        <span class="hljs-type">char</span> trash;        <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;v &quot;</span>)) &#123;            iss &gt;&gt; trash;            Vec3f v;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++) iss &gt;&gt; v.raw[i];            verts_.<span class="hljs-built_in">push_back</span>(v);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!line.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;vt &quot;</span>))        &#123;            iss &gt;&gt; trash &gt;&gt; trash;            Vec2f uv;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++) iss &gt;&gt; uv.raw[i];            uvs_.<span class="hljs-built_in">push_back</span>(&#123;uv.x, <span class="hljs-number">1</span> - uv.y&#125;);<span class="hljs-comment">//非常需要注意! 纹理图是以左上为原点的,而模型文件里的储存是以左下为原点, 需要颠倒一下!</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;vn &quot;</span>))        &#123;            iss &gt;&gt; trash &gt;&gt; trash;            Vec3f n;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++) iss &gt;&gt; n.raw[i];            nrms_.<span class="hljs-built_in">push_back</span>(n);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!line.<span class="hljs-built_in">compare</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;f &quot;</span>)) &#123;            <span class="hljs-type">int</span> idx,tidx,nidx;            iss &gt;&gt; trash;            <span class="hljs-keyword">while</span> (iss &gt;&gt; idx &gt;&gt; trash &gt;&gt; tidx &gt;&gt; trash &gt;&gt; nidx) &#123;                faces_nrm.<span class="hljs-built_in">push_back</span>(--nidx);                faces_uvs.<span class="hljs-built_in">push_back</span>(--tidx);                faces_vet.<span class="hljs-built_in">push_back</span>(--idx);            &#125;        &#125;    &#125;    <span class="hljs-comment">//std::cerr &lt;&lt; &quot;# v# &quot; &lt;&lt; verts_.size() &lt;&lt; &quot; f# &quot;  &lt;&lt; faces_.size() &lt;&lt; std::endl;//报错信息,我不会先不管</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_texture</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string filename, TGAImage &amp;texture)</span></span><span class="hljs-function"></span>&#123;    texture.<span class="hljs-built_in">read_tga_file</span>(filename.<span class="hljs-built_in">c_str</span>());&#125;Model::~<span class="hljs-built_in">Model</span>() &#123;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Model::nverts</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)verts_.<span class="hljs-built_in">size</span>();&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Model::nfaces</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(faces_vet.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Model::nuvs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)uvs_.<span class="hljs-built_in">size</span>();&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Model::nnrms</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)nrms_.<span class="hljs-built_in">size</span>();&#125;<span class="hljs-function">Vec3f <span class="hljs-title">Model::vert</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> verts_[i];&#125;<span class="hljs-function">Vec2f <span class="hljs-title">Model::uvs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> uvs_[i];&#125;<span class="hljs-function">Vec3f <span class="hljs-title">Model::nrms</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> nrms_[i];&#125;<span class="hljs-function">Vec3f <span class="hljs-title">Model::face_vet</span><span class="hljs-params">(<span class="hljs-type">int</span> facei, <span class="hljs-type">int</span> idx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> verts_[faces_vet[facei * <span class="hljs-number">3</span> + idx]];&#125;<span class="hljs-function">Vec2f <span class="hljs-title">Model::face_uvs</span><span class="hljs-params">(<span class="hljs-type">int</span> facei, <span class="hljs-type">int</span> idx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> uvs_[faces_uvs[facei * <span class="hljs-number">3</span> + idx]];&#125;<span class="hljs-function">Vec3f <span class="hljs-title">Model::face_nrm</span><span class="hljs-params">(<span class="hljs-type">int</span> facei, <span class="hljs-type">int</span> idx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> nrms_[faces_nrm[facei * <span class="hljs-number">3</span> + idx]];&#125;</code></pre></div><p>顺便也贴一下我结合texture之后的triangle函数吧! 主要是实现了对纹理坐标的插值.</p><p>此处的插值方法是直接使用屏幕坐标中的重心坐标对颜色插值, 可能效果会比在纹理坐标中直接插值差一些, 但是因为没给映射函数, 我也不知道怎么在纹理中插值,.</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_triangle</span><span class="hljs-params">(Vec3f *pts, Vec2f *texture_pts, <span class="hljs-type">float</span> *zBuffer, TGAImage &amp;image,TGAImage&amp; texture, <span class="hljs-type">float</span> intensity)</span></span><span class="hljs-function"></span>&#123;    Vec2i bboxmin = <span class="hljs-built_in">Vec2i</span>(image.<span class="hljs-built_in">get_width</span>() - <span class="hljs-number">1</span>, image.<span class="hljs-built_in">get_height</span>() - <span class="hljs-number">1</span>);    Vec2i bboxmax = <span class="hljs-built_in">Vec2i</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-keyword">if</span>(pts[i].x&gt;bboxmax.x)            bboxmax.x = pts[i].x;        <span class="hljs-keyword">if</span>(pts[i].y&gt;bboxmax.y)            bboxmax.y = pts[i].y;        <span class="hljs-keyword">if</span>(pts[i].x&lt;bboxmin.x)            bboxmin.x = pts[i].x;        <span class="hljs-keyword">if</span>(pts[i].y&lt;bboxmin.y)            bboxmin.y = pts[i].y;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = bboxmin.x; x &lt;= bboxmax.x; x++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = bboxmin.y; y &lt;= bboxmax.y; y++)        &#123;            Vec3f coor = <span class="hljs-built_in">barycentric</span>(pts, <span class="hljs-built_in">Vec2i</span>(x, y));            <span class="hljs-keyword">if</span> (coor.x &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.y &gt;= <span class="hljs-number">0</span> &amp;&amp; coor.z &gt;= <span class="hljs-number">0</span>)            &#123;                <span class="hljs-type">float</span> tx = coor.x * texture_pts[<span class="hljs-number">0</span>].x + coor.y * texture_pts[<span class="hljs-number">1</span>].x + coor.z * texture_pts[<span class="hljs-number">2</span>].x;                <span class="hljs-type">float</span> ty = coor.x * texture_pts[<span class="hljs-number">0</span>].y + coor.y * texture_pts[<span class="hljs-number">1</span>].y + coor.z * texture_pts[<span class="hljs-number">2</span>].y;                <span class="hljs-type">float</span> z = (coor.x * pts[<span class="hljs-number">0</span>].z + coor.y * pts[<span class="hljs-number">1</span>].z + coor.z * pts[<span class="hljs-number">2</span>].z);                <span class="hljs-comment">//printf(&quot;tex_coor x %d y %d\n&quot;, (int)tx, (int)ty);</span>                <span class="hljs-comment">//printf(&quot;color r %d g %d b %d\n&quot;, texture.get(tx, ty).r, texture.get(tx, ty).g, texture.get(tx, ty).b);</span>                TGAColor color = texture.<span class="hljs-built_in">get</span>(tx, ty);                <span class="hljs-keyword">if</span> (zBuffer[x + y * width] &lt; z)                &#123;                    zBuffer[x + y * width] = z;                    image.<span class="hljs-built_in">set</span>(x, y, <span class="hljs-built_in">TGAColor</span>(intensity * color.r, intensity * color.g, intensity * color.b, color.a));                    <span class="hljs-comment">// image.set(x, y, color);</span>                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>最后附上我的图! 和老师的图效果稍微差一点,但不是很明显哈哈</p><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/400638c6ba10245b.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图形学</category>
      
      <category>TinyRenderer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>C++</tag>
      
      <tag>TinyRenderer</tag>
      
      <tag>软件光栅化渲染器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谓词逻辑命题</title>
    <link href="/2022/05/08/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91%E5%91%BD%E9%A2%98/"/>
    <url>/2022/05/08/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91%E5%91%BD%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>谓词逻辑</h1><h2 id="前言">前言</h2><p>本文仅从一种实用角度来介绍和归纳谓词逻辑命题，没有扣概念和细节。</p><p>不建议把本文当作严谨的文章来学习，而应该是帮助有基础的人整理逻辑。</p><h2 id="为什么要引入谓词逻辑？">为什么要引入谓词逻辑？</h2><p><strong>命题逻辑：</strong> P ^Q -&gt; R ，其中:<br>P表示“每个人都是会死的”，<br>Q表示“苏格拉底是一个人”，<br>R表示“苏格拉底是会死的”。</p><p>**存在问题：**自然语言表达的永真命题，表达为命题逻辑子句不是永真式。</p><p>**为什么？**在命题逻辑中，我们不去研究原子命题内部的联系，也就是我们默认所有原子命题都是互相不关联的。</p><p>但是，在现实里，绝大多数原子命题之间都是相互关联的。</p><p>因此我们引入谓词逻辑。</p><h2 id="谓词逻辑命题的组成？">谓词逻辑命题的组成？</h2><p>先陈列概念：</p><div class="note note-primary">            <p><strong>主词、谓词</strong>。<strong>论域</strong>。<strong>个体</strong>。<strong>个体变元</strong>、<strong>常元</strong>。<strong>函数、多元谓词</strong>。<strong>量词、全称量词、存在量词。</strong></p><p>用’所有’和’存在’量词约束的<strong>原子命题</strong>或<strong>复合命题</strong>称为<strong>量化命题</strong>。</p><p>原子命题、复合命题和量化命题统称为<strong>命题</strong>。</p>          </div><p>一个谓词逻辑命题应该由以下几部分组成：</p><ol><li>论域（非常重要！）</li><li>谓词（自己定义）</li><li>量词（根据自然语言来决定）</li><li>变元（或常元）</li><li>完整的公式</li></ol><div class="note note-success">            <p>一些概念辨析：</p><p>原子公式指代的是什么取决于讨论的逻辑类型。</p>          </div><h2 id="谓词逻辑命题公式语法">谓词逻辑命题公式语法</h2><p>基础的就不归纳了，要是写不对可以remake了</p><p>重点讨论几个问题</p><h3 id="全称跟蕴含，存在跟合取">全称跟蕴含，存在跟合取</h3><p>如果是全称判断,特征谓词后应该用蕴含-&gt;连接</p><p>如果是存在判断,特征谓词后应该用合取^连接</p><h3 id="约束变元、自由变元和辖域">约束变元、自由变元和辖域</h3><p>如果公式中某变元x被某量词约束，则称该变元为约束变元，否则则称其为自由变元</p><p>辖域就是指某约束的约束范围，主要取决于括号怎么打</p><p>Q中自由变元的集合为Var（Q）</p><p>不出现变元的项称为<strong>基项</strong></p><p>没有自由变元的公式称为<strong>语句</strong>(或者<strong>闭公式</strong>)</p><p>没有约束变元的公式称为<strong>开公式</strong></p><p><strong>(注意: 一个公式可以同时是或者同时不是开公式或者闭公式)</strong></p><p>没有自由变元的合式公式是命题</p><p>含有自由变元的合式公式是<strong>命题形式</strong></p><h3 id="代入">代入</h3><p>可以带入某变元/常元/项</p><p>前提: <strong>可代入</strong></p><p><strong>可代入</strong> : 不要用那些已经被用过的字母!</p><h3 id="闭包和存在闭包">闭包和存在闭包</h3><p>如果有Var(A) = {x1 , x2 ,x3}</p><p>闭包:  ∀x1 ∀ x2 ∀ x3A</p><p>存在闭包: ∃x1∃x2∃x3A</p><h3 id="复杂度">复杂度</h3><p>项或者一个谓词(原子公式) 0</p><p>!或者量词 +1</p><p>其他连接词 取高+1</p><h2 id="谓词逻辑公式的语义">谓词逻辑公式的语义</h2><h3 id="概念辨析">概念辨析</h3><p>命题公式 = 合式公式</p><p>当合式公式被指派 (即确定了真值), 才叫命题</p><p>之前做的大多是自然语言的逻辑公式化, 因此不需要指派,因为自然语言已经帮忙指派了</p><p>但是其实应该把一个逻辑公式抽象出来看,切断其与现实的联系, 一个公式就是一个逻辑模型, 通过不同的指派来赋予其意义.</p><h3 id="指派">指派</h3><div class="note note-primary">            <p>指派函数σ:</p><p>将联结词符号指派为逻辑联结词</p><p>将量词符号指派为逻辑量词</p><p>将谓词符号指派为谓词</p><p>将函词符号指派为函词</p><p>将个体符号指派为对象</p>          </div><h3 id="有效式、重言式、矛盾式">有效式、重言式、矛盾式</h3><p>对于任意指派为真：有效式</p><p>对于任意指派为假： 矛盾式</p><p>如果有效式的有效性是完全由逻辑词的性质决定，叫做重言式</p><h2 id="谓词逻辑公式的语义、演算和等价">谓词逻辑公式的语义、演算和等价</h2><p>重难点！</p><p>区别于命题逻辑的等值式，谓词逻辑特有的等值式主要围绕量词。</p><h3 id="常用的量词等值式">常用的量词等值式</h3><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/684560f864512caa.png" alt=""></p><h3 id="量词辖域规则（这个有点奇怪？">量词辖域规则（这个有点奇怪？)</h3><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/7983758277b3b06b.png" alt=""></p><p>总结一下： 只需要记5和7，当R被推出时，如果要拆就会互换，别的都直接拆掉就好了。</p><h3 id="推论关系语义">推论关系语义</h3><p>大多数都是很直觉的东西，不需要多背。</p><p><strong>定理1</strong></p><p>Q╞ R 当且仅当Q -&gt;R 是永真式。</p><p><strong>定理2</strong></p><p>╞ Q 当且仅当 Q 是永真式。</p><p><strong>定理3（演绎定理）</strong></p><p>Q ╞ R 当且仅当 ╞  Q -&gt; R</p><p><strong>定理4</strong></p><p>A &lt;-&gt; B当且仅当 A ╞ B且 B ╞ A。</p><p><strong>定理5（比较重要！）</strong></p><p>公式集G不可满足,当且仅当任何公式<strong>都是</strong>G的逻辑推论。</p><p>（很好理解！）</p><p><strong>定理6</strong></p><p>设Q是公式，x是变元。若 x不是公式集G中任何公式的自由变元，且 G╞Q，则 G╞ 任取x Q。</p><p>（比较好理解，和x都没关系呢）</p><p><strong>定理7</strong></p><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/d48341dc02b6ea84.png" alt=""></p><h2 id="论域、结构与模型">论域、结构与模型</h2><p>既然我们因为谓词逻辑这个数学概念，那么我们一定是期望它能帮助我们解决一些生活中常见但是难以解释的问题（至少在2000年前是这样）。</p><p>那么问题来了，谓词逻辑能帮我们干什么呢？</p><p>我觉得问题的答案非常显然！</p><p>在这个part，我们将会将自然语言建模化，拆分成连机器都能读懂，绝对公正准确（大雾）的逻辑语言！</p><p>那么，让我们来看看什么是语言模型：</p><div class="note note-success">            <p>给定领域知识的符号集合，即给定该领域的谓词和函词语言，称为一阶理论语言。记为</p><p>L=&lt;{逻辑联结词}, {量词},P,F,C&gt;</p><p>其中，P是谓词集合，F是函词集合，C是常元集合。</p>          </div><p>将该模型套入我们这套谓词逻辑中，就是：</p><p>L = &lt;{∨, ∧,!, -&gt;, &lt;-&gt; ,⊕}, {∀,∃},P,F,C&gt;  一阶谓词语言</p><h3 id="论域">论域</h3><p>首先，要明确研究领域范围，称之为论域。论域是指我们研究内容的整体，包括研究对象、对象之间的运算、对象之间的关系。</p><p>”论域“是一个数学系统，记为 D。</p><p>论域由以下三部分组成：</p><p>（1）一个非空对象集合 D，其对象称为个体。</p><p>（2）  一个关于 D  的函数集合，称为运算。</p><p>（3）一个关于 D的关系集合，称为谓词。</p><h3 id="解释">解释</h3><p>当语言和论域确定，我们就有了可以讨论的对象。那么，怎么讨论? 我们需要<strong>解释。</strong></p><p>设L是语言，D是论域，“解释 I”由以下四部分组成：</p><p>（1）每个常元符号 c，指派 D中一个常量 c。</p><p>（2）每个 n元函数符号 f，指派 D上一个 n 元函数 f  。</p><p>（3）每个 m元谓词符号 P,指派 D上一个 m元谓词 P。</p><p>（4）每个自由变元x，指派D上一个常量 c，称为赋值。</p><h3 id="结构">结构</h3><p>设 L是语言，给定 论域 D和 解释 I，称为“结构”。结构记为  S = &lt; D, I &gt;</p><h3 id="指派-2">指派</h3><p>解释和赋值（包含在解释中）都是一种为**“指派函数”**（简称指派），对合式公式 Q，指派 σ：Q→{0,1}  确定其真值，记为  σ(Q)。</p><h3 id="模型">模型</h3><p>设L是语言，给定 论域 D 和 指派 σ，称为“模型”，模型记为  M = &lt; D, σ &gt;。</p><p>设L是语言，给定 L上的模型 M = &lt; D, σ &gt;，合式公式Q若满足 σ(Q)=1, 则称 Q 在D 上有模型。</p><p>给定合式公式 Q ， 若模型 M = &lt; D, σ &gt;能使 σ(Q)=1,  则称 Q 关于模型 M 是可满足的，记为 ⊨MQ 。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>离散数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谓词逻辑</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串基础操作</title>
    <link href="/2022/05/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1>关于</h1><p>笔者一直认为，字符串应该是每个刚入门代码的人心里最大的噩梦。不论是一堆莫名其妙的报错，永远都猜不对的+1还是不+1，还是那几个有无数潜规则的字符串函数，没调过大半天都不好意思说掌握了字符串。</p><p>但是！字符串是入门还是很有道理的，因为真的很简单！只要心里逻辑清晰一点！就没问题！</p><p>全文都以C语言为示例，高级语言字符串操作越来越简单。</p><p>下面是笔者总结的一些易错、易混的概念和操作！</p><h1>正文</h1><h2 id="字符串的初始化">字符串的初始化</h2><p>下面能正确进行字符串赋值，并且能确保字符串以’\0’结尾的操作是[ ] 【 正确答案: c】<br>(A)  char s[5] = {“ABCDE”};<br>(B)  char s[5] = {’A’, ’B’, ’C’, ’D’, ’E’};<br>©  char *s; s = “ABCDE”;<br>(D)  char *s; scanf(“%s”, s);</p><div class="note note-success">            <p>解释：A、B 爆数组了 ，但是两种初始化方法都是OK的</p><p>D、<strong>操作野指针</strong></p><p>答应我，记得初始化指针！</p>          </div><h2 id="将字符串s中所有的字符“c”删除">将字符串s中所有的字符“c”删除</h2><p>比较Tricky的小函数吧，好用的</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//下面程序的功能是将字符串s中所有的字符“c”删除。</span><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i,j;<span class="hljs-keyword">for</span>(i=j=<span class="hljs-number">0</span>;s[i];i++)&#123;<span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27;c&#x27;</span>) s[j++] = s[i];&#125;s[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-keyword">return</span> s;&#125;</code></pre></div><h2 id="关于如何理解形参中的指针">关于如何理解形参中的指针</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//判断以下程序是否正确-----不正确!</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> *q)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-comment">//此处的q为形参q!影响不了实参q!深刻理解传指针和传值的区别!</span><span class="hljs-type">char</span> a[]=<span class="hljs-string">&quot;hello&quot;</span>;        q=a;&#125;<span class="hljs-built_in">main</span>()  &#123;           <span class="hljs-type">char</span> *p;           <span class="hljs-built_in">func</span>(p);           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,p);&#125;</code></pre></div><div class="note note-success">            <p>这里需要大家真的理解指针和数组名的含义才能辨析。</p><p>但其实也不难吧，就是很有迷惑性~</p>          </div><h2 id="手写strcat（闹着玩的）">手写strcat（闹着玩的）</h2><div class="code-wrapper"><pre><code class="hljs pgsql">//函数<span class="hljs-keyword">index</span>(<span class="hljs-type">char</span> s[],<span class="hljs-type">char</span> t[])检查字符串s中是否包含字符串t，若包含，则返回t在s中的开始位置(下标值)，否则返回<span class="hljs-number">-1</span>。//C 库函数 <span class="hljs-type">char</span> *strstr(const <span class="hljs-type">char</span> *haystack, const <span class="hljs-type">char</span> *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 <span class="hljs-string">&#x27;\0&#x27;</span>,若不包含,返回<span class="hljs-keyword">null</span>.<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>(<span class="hljs-type">char</span> s[],<span class="hljs-type">char</span> t[])&#123; <span class="hljs-type">int</span> i,j,k; <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>;i++) &#123;  <span class="hljs-keyword">for</span>(j=i,k=<span class="hljs-number">0</span>; s[j]!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;s[j]==t[k];j++,k++)   ;  <span class="hljs-keyword">if</span>(t[k] == <span class="hljs-string">&#x27;\0&#x27;</span>)   <span class="hljs-keyword">return</span> i; &#125; <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre></div><div class="note note-success">            <p>同样没什么好说的，理解不了可以放弃了</p><p>进阶： KMP查找（不过想说一句，在考试的时候用就是 “可以但有病”）</p>          </div><h2 id="invert函数">invert函数</h2><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> invert (<span class="hljs-built_in">char</span> <span class="hljs-built_in">str</span> [] )&#123; <span class="hljs-built_in">int</span> i,j,k; <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=strlen(<span class="hljs-built_in">str</span>)<span class="hljs-number">-1</span>;i&lt;j;i++,j--) &#123;  k=<span class="hljs-built_in">str</span>[i];  <span class="hljs-built_in">str</span>[i]=<span class="hljs-built_in">str</span>[j];  <span class="hljs-built_in">str</span>[j]=k; &#125;&#125;</code></pre></div><div class="note note-success">            <p>Easier than easier</p>          </div><h2 id="算术运算表达式-支持空格、连乘连除">算术运算表达式(支持空格、连乘连除)</h2><p>这道题就还是比较有难度了，下面我们来拆分一下本题的需求！</p><h3 id="1-处理数据的范围">1. 处理数据的范围</h3><p>支持浮点数吗？支持超大数吗？数组该开多大？该用int、long还是double？</p><p>浮点数： atoi函数面临失效风险，需要手写转换函数</p><p>高精计算： 这都值得单独开一篇来说了！</p><p>总之！做一道题，特别是这些脑筋急转弯题！非常需要考虑这个问题！</p><h3 id="2-处理表达式">2.处理表达式</h3><p>给你一个充满空格的表达式，你打算如何读入？又该如何储存？</p><p>我认为好的做法应该是getchar读入，顺便消去空格，以=为结尾</p><p>根据本学期所学的内容，将表达式无脑先转为后缀表达式存起来应该是聪明的做法！（因为有板子呀嘿嘿）</p><h3 id="3-中缀转后缀并计算">3.中缀转后缀并计算</h3><p>中缀转后缀应该是一个树的问题？idk，但是至少对于表达式而言，我们采用这样的方法：</p><div class="note note-primary">            <ol><li>从左至右进行遍历。</li><li>遇到运算数直接输出。</li><li>遇到左括号（作为最高优先级符号）直接入栈。</li><li>遇到右括号，弹出一切符号直到遇到左括号，然后把这对括号弹出但是不存。</li><li>遇到普通运算符，不断将其与栈顶元素比较，若高于栈顶则入栈，否则弹出当前栈顶，继续比较，直到高于栈顶或者栈空，入栈。</li><li>对象处理完毕，全部出栈。</li></ol>          </div><p>下面是一个示例（我自己的板子）：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//不支持高精度和浮点数！</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">//获取中缀表达式</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getExpresion</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">char</span> c;    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>((c = <span class="hljs-built_in">getchar</span>())!= <span class="hljs-string">&#x27;=&#x27;</span>)    &#123;        <span class="hljs-keyword">if</span>(c!=<span class="hljs-string">&#x27; &#x27;</span>)        &#123;            s[i++] = c;        &#125;    &#125;    s[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;&#125;<span class="hljs-comment">//进行转换</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">char</span> *t)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//规定符号优先级</span>    <span class="hljs-type">int</span> prior[<span class="hljs-number">300</span>] = &#123;<span class="hljs-number">0</span>&#125;;    prior[<span class="hljs-string">&#x27;+&#x27;</span>] = <span class="hljs-number">1</span>, prior[<span class="hljs-string">&#x27;-&#x27;</span>] = <span class="hljs-number">1</span>, prior[<span class="hljs-string">&#x27;*&#x27;</span>] = <span class="hljs-number">2</span>, prior[<span class="hljs-string">&#x27;/&#x27;</span>] = <span class="hljs-number">2</span>;    <span class="hljs-comment">//处理开始</span>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> stack[<span class="hljs-number">100000</span>] = &#123;<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;    <span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(s[i])    &#123;        <span class="hljs-keyword">if</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-comment">//如果是数字，直接输出</span>        &#123;            <span class="hljs-keyword">while</span>(s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)            &#123;                t[j++] = s[i++];            &#125;            t[j++] = <span class="hljs-string">&#x27; &#x27;</span>;            i--;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-comment">//如果是右括号</span>        &#123;            <span class="hljs-keyword">while</span>(stack[top]!=<span class="hljs-string">&#x27;(&#x27;</span>)            &#123;                t[j++] = stack[top--];            &#125;            top--;        &#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//如果是运算符或(</span>        &#123;            <span class="hljs-keyword">while</span>(top!=<span class="hljs-number">-1</span> &amp;&amp; prior[stack[top]]&gt;=prior[s[i]] &amp;&amp; stack[top]!=<span class="hljs-string">&#x27;(&#x27;</span>)            &#123;                t[j++] = stack[top--];            &#125;            stack[++top] = s[i];        &#125;        i++;    &#125;    <span class="hljs-keyword">while</span>(top!=<span class="hljs-number">-1</span>)    &#123;        t[j++] = stack[top--];    &#125;    t[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;&#125;<span class="hljs-comment">//计算</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">char</span> *t)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> stack[<span class="hljs-number">10000</span>];    <span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(t[i])    &#123;        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-type">char</span> temp[<span class="hljs-number">100</span>];        <span class="hljs-keyword">if</span>(t[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;t[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)        &#123;            <span class="hljs-keyword">while</span>(t[i]!=<span class="hljs-string">&#x27; &#x27;</span>)            &#123;                temp[j++] = t[i++];            &#125;            temp[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;            <span class="hljs-type">int</span> x = <span class="hljs-built_in">atoi</span>(temp);            stack[++top] = x;        &#125;<span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(t[i] == <span class="hljs-string">&#x27;+&#x27;</span>)            &#123;                <span class="hljs-type">int</span> x = stack[top--];                <span class="hljs-type">int</span> y = stack[top--];                stack[++top] = y + x;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[i] == <span class="hljs-string">&#x27;-&#x27;</span>)            &#123;                <span class="hljs-type">int</span> x = stack[top--];                <span class="hljs-type">int</span> y = stack[top--];                stack[++top] = y - x;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[i] == <span class="hljs-string">&#x27;*&#x27;</span>)            &#123;                <span class="hljs-type">int</span> x = stack[top--];                <span class="hljs-type">int</span> y = stack[top--];                stack[++top] = y * x;            &#125;<span class="hljs-keyword">else</span>            &#123;                <span class="hljs-type">int</span> x = stack[top--];                <span class="hljs-type">int</span> y = stack[top--];                <span class="hljs-comment">//printf(&quot;%d / %d\n&quot;, y, x);</span>                stack[++top] = y / x;            &#125;        &#125;        i++;    &#125;    <span class="hljs-keyword">return</span> stack[top--];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">char</span> s[<span class="hljs-number">100000</span>];    <span class="hljs-type">char</span> t[<span class="hljs-number">100000</span>];    <span class="hljs-built_in">getExpresion</span>(s);    <span class="hljs-built_in">puts</span>(s);    <span class="hljs-built_in">trans</span>(s, t);    <span class="hljs-built_in">puts</span>(t);    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">cal</span>(t);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);&#125;</code></pre></div><h2 id="高精度计算">高精度计算</h2><h3 id="加法">加法</h3><h3 id="减法">减法</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>字符串操作</tag>
      
      <tag>后缀表达式</tag>
      
      <tag>高精度计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在unity中通过使用EPPLUS写入和读取excel</title>
    <link href="/2022/05/07/%E5%9C%A8unity%E4%B8%AD%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8EPPLUS%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96excel/"/>
    <url>/2022/05/07/%E5%9C%A8unity%E4%B8%AD%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8EPPLUS%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96excel/</url>
    
    <content type="html"><![CDATA[<p>先咕着！</p><h1>前置准备：</h1><h1>代码</h1>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>epplus</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 面向对象编程课程笔记</title>
    <link href="/2022/05/06/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/06/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>C++与面向对象编程</h1><h2 id="1-A-better-C">1. A better C</h2><h3 id="1-1-Macro-宏">1.1 Macro(宏)</h3><h4 id="1-1-1-常量宏">1.1.1 常量宏</h4><p>#define PI 3.14  //no magic number</p><h4 id="1-1-2-函数宏">1.1.2 函数宏</h4><p>为了避免反复调用小函数(因为调用函数会有额外开销)</p><p>#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])</p><p>#define ADD(a,b)  a+b</p><p>//但是实际不好用,非常容易造成误读,不要写</p><h4 id="1-1-3-控制宏-开关">1.1.3 控制宏(开关)</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCAL_VER</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LOCAL_VER</span>cout&lt;&lt;<span class="hljs-string">&quot;connect ximenzi&quot;</span>&lt;&lt;endl;<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>cout&lt;&lt;<span class="hljs-string">&quot;connect other type&quot;</span>&lt;&lt;endl;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><p>头文件里有什么?</p><p>\\macro</p><p>\\function declearation 函数声明</p><div class="code-wrapper"><pre><code class="hljs">void fun();</code></pre></div><p>\\struct</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_H</span><span class="hljs-comment">//每个头文件都应当包含,为了防止结构重复声明</span><span class="hljs-comment">//坚决不允许不同头文件的防重引用宏重名</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<span class="hljs-type">int</span> data;Node* next&#125;</code></pre></div><p>(如果头文件被包含多次, 那么会引起重复声明redeclearation的问题)</p><p>//补充内容:</p><div class="code-wrapper"><pre><code class="hljs">a.c   --&gt;   a.ob.c   --&gt;   b.o   --&gt;    ab.execompiler     linker</code></pre></div><p>C++ 引用 C函数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c_fun</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">c_fun</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//头文件中通用写法</span><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">c_fun</span><span class="hljs-params">()</span></span>;<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span>&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><h3 id="1-2-C-小知识点">1.2 C++小知识点</h3><h4 id="1-2-1-About-function-in-CPP">1.2.1 About function  in CPP</h4><h5 id="1-2-1-1-Overloading-重载">1.2.1.1 Overloading 重载</h5><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//1.同名不同参</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><span class="hljs-function"></span>&#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><span class="hljs-function"></span>&#123;&#125;</code></pre></div><h5 id="1-2-1-2-Default-parameter">1.2.1.2 Default parameter</h5><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//可以只传2个也可以传3个</span><span class="hljs-comment">//当只有一个默认参数时,必须是最后一个</span><span class="hljs-comment">//最好把最不易变的放在最后面</span><span class="hljs-comment">//声明里有,函数体里就不能有</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b,<span class="hljs-built_in">int</span> c=<span class="hljs-number">5</span></span>)</span>&#123;&#125;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h5 id="1-2-1-3-占位符">1.2.1.3 占位符</h5><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//几乎没用</span><span class="hljs-comment">//一般只会出现在 同名函数,同参,但是含义不同,可以强制不同参做一个区分</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span>&#123;&#125;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;f(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="1-2-2-引用-reference">1.2.2 引用(reference)</h4><p>引用 ——<strong>一种安全的指针</strong></p><div class="code-wrapper"><pre><code class="hljs kotlin">int main()&#123;int *pl;int a = <span class="hljs-number">10</span>;int&amp; r = a;<span class="hljs-comment">//引用被强制必须初始化 </span><span class="hljs-comment">//引用是常量,只有初始化一个时候能赋值</span>r++;<span class="hljs-comment">//r++ == a++ r代表a的值</span><span class="hljs-comment">//那为什么说r是指针?</span><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a)</span></span>;cout&lt;&lt; a &lt;&lt;endl;<span class="hljs-comment">//输出11</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int&amp; m)</span></span><span class="hljs-comment">//借值之名,行指针之实</span>&#123;m++;&#125;<span class="hljs-comment">//指针是丑陋的,但是简明</span><span class="hljs-comment">//引用是简洁的,但是含糊不清</span></code></pre></div><h4 id="1-2-3-堆、栈和内存">1.2.3 堆、栈和内存</h4><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//memory</span><span class="hljs-comment">//代码区 占多少取决于文件有多大 (一般PC级以上不关心这个问题,不缺这点空间)</span><span class="hljs-comment">//全局变量区 </span><span class="hljs-built_in">int</span> g_i;<span class="hljs-comment">//不需要初始化,因为会被初始清空(全局变量初始化在main函数开始之前)</span><span class="hljs-comment">//运行内存(Runtime Memory)</span><span class="hljs-comment">//   stack    vs     heap(dynamic memory arrange)</span><span class="hljs-comment">// local var           malloc new</span><span class="hljs-comment">// 连续内存(快)         离散空间(有寻址机制)</span><span class="hljs-comment">//内存的碎片化(缺少连续的大的内存)--&gt;因而产生了极端的内存管理机制</span><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<span class="hljs-built_in">int</span> *p=&amp;g_i;cout&lt;&lt; *(p+<span class="hljs-number">100</span>) &lt;&lt; endl;<span class="hljs-comment">//输出0</span><span class="hljs-comment">//证明全局变量内存会被清空一大片!!这是为程序员提前腾出很多空间</span><span class="hljs-comment">//但是局部变量不会自己初始化,因为此时程序已经开始运行,要追求效率</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="2-封装">2. 封装</h2><h3 id="2-1-Everything-is-object-面向对象">2.1 Everything is object(面向对象)</h3><p>封装（1个类）、继承（类与类）、多态（类行为）</p><p>面向过程（以事为中心） 面向对象（C++、Java、Python）（物中心）</p><p>C语言时代的面向对象 struct ----&gt; 仅仅是相关数据的集合,与类型相关的操作还是独立于类型之外</p><p>C++ : class -&gt; 包含属性(attribute)和方法(method)-&gt;解决命名危机</p><p>类是唯一的抽象 , 对象是无穷多的实例.</p><p>类需要实例化成为对象</p><p>小知识: 我们关注的内存是runtime-memory, 不关心代码本身的大小</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<span class="hljs-type">int</span> Id;string name;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialStdu</span><span class="hljs-params">(<span class="hljs-type">int</span> aid,<span class="hljs-type">char</span> *aname)</span></span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::initialStud</span><span class="hljs-params">(<span class="hljs-type">int</span> aid,<span class="hljs-type">char</span> *aname)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">this</span>-&gt;Id = aid;<span class="hljs-keyword">this</span>-&gt;name = aname; <span class="hljs-comment">// the hiden this pointer</span><span class="hljs-comment">//等价于 name = aname;</span><span class="hljs-comment">// this == 调用者的地址</span><span class="hljs-comment">// this == &amp;s</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><span class="hljs-comment">//按1字节对齐,节省空间,便于运输,一般写在头文件</span><span class="hljs-comment">//但是会耽误性能</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-type">int</span> i;<span class="hljs-comment">//4</span><span class="hljs-type">double</span> d;<span class="hljs-comment">//8</span><span class="hljs-type">char</span> c;<span class="hljs-comment">//1</span><span class="hljs-comment">//这个顺序就是24字节</span><span class="hljs-type">int</span> i;<span class="hljs-comment">//4</span><span class="hljs-type">char</span> c;<span class="hljs-comment">//1</span><span class="hljs-type">double</span> d;<span class="hljs-comment">//8</span><span class="hljs-comment">//这个顺序就是16字节</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test::fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//对于sizeof没有影响,因为对于运行内存没有影响;</span><span class="hljs-comment">//分配内存规则: 按大对齐,按大分配</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Test) &lt;&lt; endl;<span class="hljs-comment">//sizeof()是一种运算符</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//结论: 类的大小只取决于属性</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Test&#123;<span class="hljs-built_in">int</span> a:<span class="hljs-number">1</span>;<span class="hljs-comment">//大小为4字节</span><span class="hljs-built_in">int</span> b:<span class="hljs-number">1</span>;<span class="hljs-comment">// 含义: a占1比特 (位结构)</span><span class="hljs-comment">// 含义: 由a,b以及剩下的30个字母同时表示一个int</span>&#125;;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Test) &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="2-2-访问控制-Access-control">2.2 访问控制(Access control)</h3><div class="code-wrapper"><pre><code class="hljs">我们不希望外部直接操作类内部的属性,因此我们为属性赋予访问权权限。</code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//class 和 struct 没有区别,除了若无说明,class默认private,struct默认public</span><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-comment">// self-definition type</span>&#123;<span class="hljs-keyword">private</span>:  <span class="hljs-comment">//私有</span><span class="hljs-built_in">char</span> *name;<span class="hljs-built_in">int</span> id;<span class="hljs-keyword">public</span>:   <span class="hljs-comment">//公有</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> aage</span>)</span>;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getAge</span>()</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ada">还有<span class="hljs-keyword">protected</span> 在继承的时候再介绍//对于外部为<span class="hljs-keyword">private</span>,对于子类为<span class="hljs-keyword">protected</span></code></pre></div><h3 id="2-2-想做一个软件-你需要学什么">2.2* 想做一个软件,你需要学什么</h3><p>硬件–&gt;操作系统(Windows,ios,linux,Android,(进程、线程、API))–&gt;应用知识(Database、socket、多线程、GUI)</p><p>1.数据库：sqllite  2.网络编程 udp socket  3. Linux多线程</p><h3 id="2-3-构造和构析函数">2.3 构造和构析函数</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-comment">// self-definition type</span>&#123;<span class="hljs-comment">//constructor</span>Student();<span class="hljs-comment">//也可以自定义构造函数</span>Student(<span class="hljs-built_in">int</span> aid, <span class="hljs-built_in">char</span>* aname)&#123;<span class="hljs-keyword">this</span>-&gt;id = aid;<span class="hljs-keyword">this</span>-&gt;name = aname&#125;<span class="hljs-comment">//Overloading</span>Student(<span class="hljs-built_in">int</span> aid)&#123;<span class="hljs-keyword">this</span>-&gt;id = aid;&#125;<span class="hljs-comment">//试图模仿默认构造函数 -&gt; 实际上起到了表明不需要传参的信息</span>Student();<span class="hljs-comment">//所以不是默认构造函数哦!!!!!</span><span class="hljs-keyword">private</span>:  <span class="hljs-comment">//私有</span><span class="hljs-built_in">char</span> *name;<span class="hljs-built_in">int</span> id;<span class="hljs-keyword">public</span>:   <span class="hljs-comment">//公有</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> aage</span>)</span>;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getAge</span>()</span>;&#125;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<span class="hljs-function">Student <span class="hljs-title">s</span>(<span class="hljs-params"><span class="hljs-number">102</span>, <span class="hljs-string">&quot;zhangsan&quot;</span></span>)</span>;<span class="hljs-function">Student <span class="hljs-title">s1</span>(<span class="hljs-params"><span class="hljs-number">102</span></span>)</span>;<span class="hljs-comment">//构造函数的隐式调用</span><span class="hljs-comment">//应当充分考虑对象的多样性,准备不同的构造函数应对不同的对象产生 ---&gt; Overloading</span>&#125;<span class="hljs-comment">//类不允许不初始化-&gt;存在默认构造函数,但是什么也不干</span><span class="hljs-comment">//运行区内存: 堆和栈(存放所有局部变量)</span><span class="hljs-comment">//局部变量不需要程序员来删除,会自行消亡 -&gt; 特点: 快 缺陷: 变量生命周期不可控</span><span class="hljs-comment">//申请堆内存: malloc 释放:free (C语言) 特点: 1.人为控制生命周期(典型如链表) 2.内存长度不固定 3.比栈慢</span><span class="hljs-comment">//C++: 申请堆内存:new 释放:delete   Java: 变量全放堆区 &amp; 自动释放</span><span class="hljs-comment">//链表解决了内存动态增长的问题: 数组定长,浪费内存或者会爆内存</span><span class="hljs-comment">//如果不释放,系统会自己杀内存(或者导致机器死机) -&gt; 内存泄漏</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-comment">//attribute</span><span class="hljs-built_in">int</span> i;<span class="hljs-comment">//value</span><span class="hljs-built_in">int</span> *p;<span class="hljs-comment">//handle句柄</span><span class="hljs-keyword">public</span>:Test(<span class="hljs-built_in">int</span> ai,<span class="hljs-built_in">int</span> aj);~Test();<span class="hljs-comment">//desructor</span>&#125;Test::Test&#123;i = ai;p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(aj);<span class="hljs-comment">//问题: 这个空间什么时候释放?</span><span class="hljs-comment">//如果忘记释放: 内存泄漏(memory leak)-&gt;严重影响系统的性能</span><span class="hljs-comment">//析构函数 destructor</span>&#125;<span class="hljs-comment">//实际情况</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wheel</span>&#123;<span class="hljs-built_in">int</span> i;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfDrivingSys</span>&#123;<span class="hljs-built_in">int</span> ii;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;Wheel w[<span class="hljs-number">4</span>];<span class="hljs-comment">//value</span>SelfDrivingSys *p_sys;<span class="hljs-comment">//handle</span><span class="hljs-comment">//使用变量还是句柄? 看是否为必有成员 -&gt; 否则如果没有的话,就浪费空间了。</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp">关于析构函数的一点小Tips<span class="hljs-comment">//1.析构会重载吗?</span><span class="hljs-comment">//答:不会,析构函数也不需要传参</span><span class="hljs-comment">//2.如果构造里有动态内存分配(new),那么一定有析构</span><span class="hljs-comment">//答:对。</span><span class="hljs-comment">//3.如果构造里面没有new,就不需要析构</span><span class="hljs-comment">//答:不对。析构会释放本类一切内存,包括中间产生的。</span><span class="hljs-comment">//4.不允许delete野指针,也不许重复delete指针</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-comment">//attribute</span><span class="hljs-type">int</span> i;<span class="hljs-type">int</span> *p;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> ai,<span class="hljs-type">int</span> aj);<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> ai);~<span class="hljs-built_in">Test</span>();<span class="hljs-comment">//desructor</span>&#125;Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> ai)&#123;i = ai;p = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//必须要加上! 即使没值可以赋,也要赋值!决不允许出现野指针!!!</span>&#125;Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> ai,<span class="hljs-type">int</span> aj)&#123;i = ai;p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(aj);&#125;</code></pre></div><h3 id="2-4-拷贝构造">2.4 拷贝构造</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-type">int</span> i;<span class="hljs-type">int</span>* p;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> ai,<span class="hljs-type">int</span> aj);<span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t);<span class="hljs-comment">//参数是一个Test引用常量</span>&#125;Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> ai,<span class="hljs-type">int</span> aj)&#123;i = ai;*p = aj;&#125;Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t)&#123;<span class="hljs-keyword">this</span>-&gt;i = t.i;<span class="hljs-keyword">this</span>-&gt;j = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*t.j);<span class="hljs-comment">//自己新建了内存空间,存放了t.j指向的值</span>&#125;<span class="hljs-comment">//bitewise copy 默认就是 浅拷贝</span><span class="hljs-comment">//如果有指针,会产生一个尴尬的问题!</span><span class="hljs-comment">//同一块内存被两个handle指向!!</span><span class="hljs-comment">//问题的实质是: 你copy了一个指针!你让t1和t2互相影响了!</span><span class="hljs-comment">//而且会产生重复释放的问题</span><span class="hljs-comment">//logical copy 深拷贝</span><span class="hljs-comment">//实现原理:你自己写一个好用的拷贝,别用系统默认的</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;<span class="hljs-comment">//拷贝构造(默认存在,不需要自己写)(和构造函数形式相似)</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs kotlin">void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Test t)</span></span><span class="hljs-comment">//pass by value(使用了拷贝构造)</span>&#123;<span class="hljs-keyword">return</span>;&#125;void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(Test&amp; t)</span></span><span class="hljs-comment">//pass by pointer</span>&#123;&#125;;<span class="hljs-comment">//   pass by value        vs.      pass by address</span><span class="hljs-comment">//功能   input                       input/output✔ </span><span class="hljs-comment">//性能   sizeof(value)               sizeof(int)✔</span><span class="hljs-comment">//其他   拷贝构造                      不需要拷贝构造✔</span><span class="hljs-comment">//conclusion : never pass by value</span><span class="hljs-comment">//针对self-definition type &lt;=&gt; build-in type(内嵌类型) 如int</span>int main()&#123;Test t1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(t1)</span></span>;<span class="hljs-comment">//如何传值进函数?-&gt;拷贝构造! 此处也会调用拷贝构造</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">//一个常用的方法</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Test</span>&#123;<span class="hljs-built_in">int</span> i;<span class="hljs-built_in">int</span>* p;Test(<span class="hljs-keyword">const</span> Test&amp; t);<span class="hljs-comment">//将拷贝构造私有声明</span><span class="hljs-comment">//强迫所有使用者不能使用该类的拷贝构造!</span><span class="hljs-keyword">public</span>:Test(<span class="hljs-built_in">int</span> ai,<span class="hljs-built_in">int</span> aj);&#125;Test::Test(<span class="hljs-built_in">int</span> ai,<span class="hljs-built_in">int</span> aj)&#123;i = ai;*p = aj;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp">一、<span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> &amp;a;<span class="hljs-comment">//不要返回一个局部变量的地址!函数结束了，a就释放掉了。</span>&#125;二、<span class="hljs-comment">//fly pointer 一定要初始化！！没有就赋值为NULL</span>三、<span class="hljs-comment">//re-free 不要重复释放</span>标准写法：为了防止重复释放<span class="hljs-keyword">if</span>（p!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">free</span>(p);        p = <span class="hljs-literal">NULL</span>;&#125;四、<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>);<span class="hljs-type">int</span> m=<span class="hljs-number">10</span>;p-&gt;j = &amp;m;<span class="hljs-comment">//p-&gt;j 和 m 不是同一个生命周期！！</span><span class="hljs-comment">//m为局部变量，而p-&gt;j是new出来的，不知道什么时候m就死了，但是p还活着，会引发大问题</span>&#125;</code></pre></div><h3 id="2-5-静态-static">2.5 静态(static)</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> <span class="hljs-type">static</span> local var; 静态局部变量 保值,计数<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; <span class="hljs-comment">//实现了类似全局变量的效果</span>                <span class="hljs-comment">//只被生成一次,程序结束释放</span>i++;cout &lt;&lt;i&lt;&lt; endl;&#125;<span class="hljs-comment">//和全局变量的区别</span><span class="hljs-comment">//全局变量在程序开始前生成</span><span class="hljs-comment">//static变量在程序运行中生成</span>   <span class="hljs-number">2.</span><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>; 静态函数<span class="hljs-comment">//一旦将文件修饰上static,使得本函数&#x27;只在&#x27;本文件中能够被调用</span><span class="hljs-comment">//编外:不同文件全局变量</span>    (<span class="hljs-keyword">extern</span>) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">str2int</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//函数的默认连接区域是全部区域</span>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_i;<span class="hljs-comment">//变量的默认连接区是本文件,如果不是在本文件出现的全局变量,那么必须加extern</span><span class="hljs-number">3.</span><span class="hljs-type">static</span> global <span class="hljs-type">int</span>;静态全局变量 <span class="hljs-comment">//仅允许本文件使用</span><span class="hljs-comment">//感觉没必要!</span>以上为C语言就有的~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<span class="hljs-number">4.</span><span class="hljs-type">static</span> data member;<span class="hljs-number">5.</span><span class="hljs-type">static</span> function member<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-type">static</span> <span class="hljs-type">int</span> i;<span class="hljs-comment">//static修饰</span><span class="hljs-type">int</span> j;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> aj);<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//可以不需要实例化,直接用类名访问!</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test::Test</span><span class="hljs-params">(<span class="hljs-type">int</span> aj)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//i = ai; 不允许构造共享空间</span>j = aj;&#125;<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Test::fun</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//一旦函数被static,函数内部只能访问静态成员,失去了this指针!</span>&#125;<span class="hljs-type">int</span> Test::i = <span class="hljs-number">100</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//如果想使t1,t2互相感知,可以使用 全局变量-&gt;全局互相感知的终极方案</span><span class="hljs-comment">//但是少用全局变量!!!会很容易错</span>Test::<span class="hljs-built_in">fun</span>();<span class="hljs-comment">//类名、对象都直接调用</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//可不可以使t1,t2共享一部分空间,以达到这个目的?</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs php">拓展: 这门课结课,可以接下来去学design pattern 设计模式 <span class="hljs-number">23</span>种framework 框架 如QT<span class="hljs-comment">//单件模式 ----&gt; 我们希望某一个类在全局只拥有唯一一个对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span></span><span class="hljs-class"></span>&#123;<span class="hljs-built_in">static</span> Single* <span class="hljs-built_in">self</span>;<span class="hljs-title function_ invoke__">Single</span>();<span class="hljs-keyword">public</span>:<span class="hljs-built_in">static</span> Single* <span class="hljs-title function_ invoke__">get_instance</span>();&#125;;Single* <span class="hljs-title class_">Single</span>::<span class="hljs-title function_ invoke__">get_instance</span>()&#123; <span class="hljs-keyword">if</span>(<span class="hljs-built_in">self</span> == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-built_in">self</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Single</span>(); &#125; <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>;&#125;Single* <span class="hljs-title class_">Single</span>::<span class="hljs-variable constant_">self</span> == <span class="hljs-literal">NULL</span>;</code></pre></div><h3 id="2-6-常量-const">2.6 常量(const)</h3><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">//const return value </span>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">const</span> int *i)</span></span>&#123;<span class="hljs-comment">//(*i)++; 常量不能赋值!不能做左值(left value);</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span>&#123;<span class="hljs-keyword">public</span>:void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-keyword">const</span> A other();<span class="hljs-comment">//const return value</span><span class="hljs-comment">//像int double这种内嵌类型默认为常量</span>&#125;int main()&#123;ClassB b;b.other().<span class="hljs-keyword">fun</span>();<span class="hljs-comment">//常量不能作左值,b.other返回const A,不能连锁调用了</span><span class="hljs-keyword">return</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Const</span>&#123;<span class="hljs-comment">//const int i;</span><span class="hljs-comment">//enum&#123;tcp,udp&#125;;//枚举,给类型取一个有意义的名字</span><span class="hljs-keyword">public</span>:void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">const</span>;<span class="hljs-comment">//声明此函数可以被常量对象直接调用</span>&#125;void Const::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">const</span>&#123;<span class="hljs-comment">//要求函数内部只能进行读操作,不能写入</span><span class="hljs-keyword">return</span>;&#125;int main()&#123;<span class="hljs-keyword">const</span> Cosnt c;<span class="hljs-comment">//创建了一个常量对象(不能修改)</span>c.<span class="hljs-keyword">fun</span>();<span class="hljs-comment">//会报error,因为不敢让常量对象调用函数-&gt;必须声明此函数为常量函数-&gt;在类体内部写</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-type">int</span>  *p;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Test</span>();&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test::Test</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">//先析构,把类申请的内存先释放</span><span class="hljs-comment">//再free,将类本身内存释放</span><span class="hljs-comment">//否则内存会泄露</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//malloc free 库函数 C</span><span class="hljs-comment">//new delete operator(运算符) C++</span><span class="hljs-comment">//Test* p1 = (Test*)malloc(sizeof(Test));//不会调用test的构造函数</span>Test* p1 = <span class="hljs-keyword">new</span> Test;<span class="hljs-comment">//new = malloc(分配空间) + constructor(构造对象)</span><span class="hljs-comment">//delete = destructor + free</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="作业一">作业一</h2><p>自学:UDP socket,完成两个计算机(或两个程序)之间的内容收发<br>发送内容1 : 一个字符串<br>发送内容2 : 一个数据对象</p><h2 id="3-继承">3. 继承</h2><p>inheritance &amp; composition</p><p>注重reuse 代码的复用</p><h3 id="软件的定价">软件的定价</h3><div class="code-wrapper"><pre><code class="hljs 1c"><span class="hljs-comment">//小插曲: 软件的定价</span><span class="hljs-comment">//1.人月(需要多少程序员工作多少个月)</span><span class="hljs-comment">//2.代码行数</span><span class="hljs-comment">//没有合理的计算方法,就随便吧</span></code></pre></div><h3 id="子类函数调用问题">子类函数调用问题</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//computer</span>对于复杂概念-&gt;分类(inheritance) &amp; 组成(composition)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>&#123;<span class="hljs-type">int</span> price;<span class="hljs-type">char</span>* brand;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_price</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-type">int</span> Computer::get_price&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;price;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Computer::service</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;SERVICE&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-comment">//inheritation</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Macbook</span>: <span class="hljs-keyword">public</span> Computer&#123;<span class="hljs-comment">//个性与共性-&gt;继承了Computer的共性</span>&#125;<span class="hljs-type">void</span> Macbook::service&#123;<span class="hljs-keyword">if</span>(year&lt;<span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;new Macbook&quot;</span>&lt;&lt;endl;<span class="hljs-keyword">else</span> Computer::<span class="hljs-built_in">service</span>(); <span class="hljs-comment">//复用了Computer的方法</span><span class="hljs-comment">//若父类定义了方法A,子类重定义了A,但是子类一定会用到父类的A!</span><span class="hljs-comment">//你既然选择了对方是你的父类,为什么不用父类的方法?</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Macbook mac;mac.<span class="hljs-built_in">get_price</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">//继承要小心重载</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<span class="hljs-keyword">public</span>:void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int i)</span></span>;&#125;;void Base::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;&#125;void Base::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int i)</span></span>&#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive</span>:<span class="hljs-type">:</span> <span class="hljs-title">pubic</span> <span class="hljs-title">Base</span>&#123;void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//子类没有定义父类的重载</span><span class="hljs-comment">//要不然都改,要不然别改</span>&#125;;int main()&#123;Drived d;d.<span class="hljs-keyword">fun</span>();d.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//爆error 因为子类没有定义父类的重载,无法判断你想干嘛</span>&#125;</code></pre></div><h3 id="继承中的构造构析问题">继承中的构造构析问题</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//类之间互相调用的构造构析</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Engine</span>(<span class="hljs-type">int</span> i);<span class="hljs-comment">//挤掉了默认构造</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;;Engine::<span class="hljs-built_in">Engine</span>(<span class="hljs-type">int</span> i)&#123;cout&lt;&lt;<span class="hljs-string">&quot;construct Engine&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Engine::run</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Engine is running&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;Engine e;<span class="hljs-comment">//Engine *p;</span><span class="hljs-comment">//复习一下:当一个车必然有引擎的时候,就直接用对象,不然用指针,维持一个handle就可以了</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//为什么要使用构造初始化列表？</span><span class="hljs-comment">//(组成的)构造初始化列表,此时e有名字</span>Car::<span class="hljs-built_in">Car</span>() : <span class="hljs-built_in">e</span>(<span class="hljs-number">1</span>)&#123;cout&lt;&lt;<span class="hljs-string">&quot;construct car&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::run</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;e.<span class="hljs-built_in">run</span>();<span class="hljs-comment">//reuse 复用成员类的代码,不会搞混car和engine的</span>cout&lt;&lt;<span class="hljs-string">&quot;car is running&quot;</span>&lt;&lt;endl;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-comment">//父类</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Base</span>&#123;<span class="hljs-built_in">int</span> i;<span class="hljs-keyword">public</span>:Base();&#125;;Base::Base()&#123;cout&lt;&lt; <span class="hljs-string">&quot;construct Base&quot;</span>;&#125;<span class="hljs-comment">//子类</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Drived:: <span class="hljs-symbol">pubic</span></span> <span class="hljs-symbol">Base</span>&#123;<span class="hljs-built_in">int</span> j;<span class="hljs-keyword">public</span>:Drived();&#125;;Drived::Drived()&#123;cout&lt;&lt; <span class="hljs-string">&quot;construct Drived&quot;</span>;&#125;<span class="hljs-built_in">int</span> main()&#123;Drived d;Base b;cout&lt;&lt;sizeof(Drived)&lt;&lt;endl;<span class="hljs-comment">//输出:8个字节,说明有i又有j-&gt;创建子类对象会不会调用父类构造函数呢?</span>   <span class="hljs-comment">//当然调用-&gt;顺序:先父类后子类 析构顺序:先子类后父类</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript">👆改造版<span class="hljs-comment">//父类</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Base</span>&#123;<span class="hljs-built_in">int</span> i;<span class="hljs-keyword">public</span>:Base(<span class="hljs-built_in">int</span> ai);<span class="hljs-comment">//注意</span>&#125;;Base::Base()&#123;cout&lt;&lt; <span class="hljs-string">&quot;construct Base&quot;</span>;&#125;<span class="hljs-comment">//子类</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Drived:: <span class="hljs-symbol">pubic</span></span> <span class="hljs-symbol">Base</span>&#123;<span class="hljs-built_in">int</span> j;<span class="hljs-keyword">public</span>:Drived(<span class="hljs-built_in">int</span> ai, <span class="hljs-built_in">int</span> aj);&#125;;<span class="hljs-comment">//construction initialization list (继承的)构造初始化列表</span>Drived::Drived(<span class="hljs-built_in">int</span> ai, <span class="hljs-built_in">int</span> aj)::Base(ai)<span class="hljs-comment">//指定父类构造</span>&#123;j = aj;cout&lt;&lt; <span class="hljs-string">&quot;construct Drived&quot;</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">Drived::Drived(int ai, int aj):Base(ai),j(aj)//可以在列表初始化成员变量</span><span class="hljs-comment">&#123; //类内的常量必须放在构造初始化列表里面初始化</span><span class="hljs-comment">cout&lt;&lt; &quot;construct Drived&quot;;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-built_in">int</span> main()&#123;Base b;Drived d;<span class="hljs-comment">//报错,因为父类没有默认构造了,所以必须指明调用哪个父类构造对象</span>cout&lt;&lt;sizeof(Drived)&lt;&lt;endl;&#125;<span class="hljs-comment">//总结:</span><span class="hljs-comment">//1. 子类对象构造时会先调用父类构造</span><span class="hljs-comment">//2. 如果构造子类对象时不希望用父类的默认构造,应用构造初始化列表表明如何调用构造函数</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-type">int</span> i;<span class="hljs-type">int</span> j;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a);&#125;;Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a):<span class="hljs-built_in">i</span>(j),<span class="hljs-built_in">j</span>(a)<span class="hljs-comment">//i为垃圾,j为4</span>&#123;&#125;Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a):<span class="hljs-built_in">j</span>(a),<span class="hljs-built_in">i</span>(j)<span class="hljs-comment">//i为垃圾,j为4</span>&#123;&#125;   <span class="hljs-comment">//初始化顺序不是按照你写的顺序决定的,而是按照定义的顺序初始化的</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;&#125;</code></pre></div><h3 id="继承中的访问控制">继承中的访问控制</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::fun</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Base::fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive</span>:: pubic Base<span class="hljs-comment">//这里的public是什么意思?不加会怎么样</span>&#123;<span class="hljs-comment">//默认为private,所以如果不加就会削弱子类对父类的访问权限,把父类public削弱为  //private,也就是完全访问不了父类了,仅仅为了维持语法的正确性在继承</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Drived d;d.<span class="hljs-built_in">fun</span>();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">//访问控制 -&gt; protected</span>对外界为<span class="hljs-keyword">private</span>,对子类为<span class="hljs-keyword">public</span></code></pre></div><h3 id="多重继承">多重继承</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base1</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">base2</span>&#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span>::Base1, Base2&#123;&#125;;<span class="hljs-comment">//既可以用f,也可以用h</span><span class="hljs-comment">//那万一Base2里面也有f怎么办?-&gt;报错</span><span class="hljs-comment">//常见的糟糕继承:菱形继承</span><span class="hljs-comment">//在你成为一个高手之前,千万不要轻易多重继承</span><span class="hljs-comment">//解决方法</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span>::Base1, Base2&#123;base2 b2; <span class="hljs-comment">//一个类内的datamember一定是它的属性吗? </span><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//b2仅仅是为了代码重用,没有意义</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-type">void</span> Drived::h&#123;b2.<span class="hljs-built_in">h</span>();&#125;</code></pre></div><h2 id="4-多态">4. 多态</h2><h3 id="Virtual-关键字实现多态">Virtual 关键字实现多态</h3><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//class Pet</span>&#123;<span class="hljs-type">int</span> age;<span class="hljs-type">char</span> *name;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/*virtual*/</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//late banding 1</span>  <span class="hljs-comment">//借助虚函数实现多态</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pet::Speak</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;Pet::Speak&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-comment">//猫</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Pet&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Speak</span>();&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cat::Speak</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;miao&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-comment">//狗</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Pet&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//父类virtual了子类会自动进行，但是一般要写出来强调。</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::Speak</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;wang&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-comment">//banding绑定：将函数的一次调用与函数入口地址相映射的过程，称为绑定。（由链接器负责）</span><span class="hljs-comment">//early banding 前绑定:</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Needle</span><span class="hljs-params">(Pet&amp; pet)</span><span class="hljs-comment">//late banding 2</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//传入dog,那么将执行dog的speak方法？ ---&gt; NO!此处为前绑定，只会执行父类的方法</span><span class="hljs-comment">//我们希望：</span><span class="hljs-comment">/*</span><span class="hljs-comment">if dog dog::Speak;</span><span class="hljs-comment">if cat cat::Speak;</span><span class="hljs-comment">*/</span><span class="hljs-comment">//我们需要：late banding</span>pet.<span class="hljs-built_in">Speak</span>();<span class="hljs-comment">//多态的体现</span>&#125;<span class="hljs-comment">//主函数</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Dog dog;<span class="hljs-comment">//Upcasting 向上类型转换：多态的前提 -&gt;Downcasting is dangerous</span><span class="hljs-built_in">Needle</span>(dog);<span class="hljs-comment">//dog 继承自 Pet , 可以这么用吗？</span>    <span class="hljs-comment">//可以！保证了Needle的复用</span>    <span class="hljs-comment">//子类不能削弱父类的接口</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//虚指针的初始化问题</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>&#123;<span class="hljs-type">int</span> age;<span class="hljs-type">char</span> *name; <span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//借助虚函数实现多态</span><span class="hljs-comment">//virtal void Sleep(); //无论写几个虚函数，都只占4字节，在对象的前四个字节</span><span class="hljs-comment">//因为只会生成一个指针，指向虚函数表（如果是子类，那么子类会有一个自己的函数表）</span><span class="hljs-comment">//证明：任何子类实例的前四个字节相同</span><span class="hljs-comment">//函数名是指向函数运行位置的指针</span>&#125;<span class="hljs-comment">//never pass by value！！！！！！</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Needle</span><span class="hljs-params">(Pet&amp; pet)</span><span class="hljs-comment">//如果去掉引用符号就错了！如果是传值，会调用Pet的拷贝构造函数,虚指针会被初始化为Pet的虚指针。</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//虚指针是在构造函数内隐式初始化的</span>pet.<span class="hljs-built_in">Speak</span>();<span class="hljs-comment">//多态的体现</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Dog dog1;Cat cat1;<span class="hljs-built_in">memcpy</span>(dog1,cat1,<span class="hljs-number">4</span>);<span class="hljs-comment">//通过把dog对象的前四个字节替换为猫的，让狗miaomiao叫</span>    <span class="hljs-comment">//在内存里以字节为单位拷贝用memcpy</span><span class="hljs-built_in">Needle</span>(dog1);<span class="hljs-comment">//miaomiao</span>dog1.<span class="hljs-built_in">Speak</span>();<span class="hljs-comment">//wangwang//此处没有多态，没有upcasting，就是前绑定</span>&#125;</code></pre></div><p><img src="image/C++%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/1649769916284.png" alt="1649769916284.png" title="图解"></p><h3 id="纯虚函数">纯虚函数</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//纯虚函数 -&gt; 解决抽象类不便于初始化的问题</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>&#123;<span class="hljs-type">int</span> age;<span class="hljs-type">char</span> *name; <span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//纯虚函数</span>&#125;<span class="hljs-comment">//若一个类中存在纯虚函数，称这个类为抽象类abstract class</span><span class="hljs-comment">//抽象类不能实例化!子类如果不去实现纯虚函数,那么也将不能实例化.</span><span class="hljs-comment">//抽象类的子类必须实现所有方法 错,只不过不实现不能实例化</span><span class="hljs-comment">//两大作用:</span><span class="hljs-comment">//1. 约定一个类家族的共性行为 //Java的抽象类</span><span class="hljs-comment">//如果不实现抽象类的方法,那么将无法实例化</span><span class="hljs-comment">//2. 连接本不相关的类家族,抽象其共性行为 //Java的接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><span class="hljs-comment">//动物类</span>&#123;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>: <span class="hljs-keyword">public</span> animal, <span class="hljs-keyword">public</span> FlyObject&#123;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">machine</span><span class="hljs-comment">//机器类</span>&#123;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">airplane</span>:<span class="hljs-keyword">public</span> machine, <span class="hljs-keyword">public</span> FlyObject&#123; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-comment">//共性:都能飞</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyObject</span>&#123;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(FlyObject&amp; obj)</span><span class="hljs-comment">//scan 想能够传入所有能飞的对象,怎么办? 纯虚函数+多重继承(辩证的理解)</span></span><span class="hljs-function"></span>&#123;obj.<span class="hljs-built_in">fly</span>();&#125;<span class="hljs-comment">//Java: 一个类只能有一个父类(杜绝多重继承),但是能实现多个接口(FlyObject只能算一个接口(interface))</span><span class="hljs-comment">//选择父类的原则:选择被upcasting最多的父类</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//考虑构造函数</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<span class="hljs-keyword">public</span>: <span class="hljs-built_in">Base</span>();<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>();&#125;;Base::~<span class="hljs-built_in">Base</span>()&#123;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span>&#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">Drived</span>();&#125;;Drived::~<span class="hljs-built_in">Drived</span>();<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(Base* p)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//如果Base析构没虚, 这里只会调用父类的.</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;Base b;Drived d;Base *p1 = <span class="hljs-keyword">new</span> Base;Drived *p2 = <span class="hljs-keyword">new</span> Drived;Base *p3 = <span class="hljs-keyword">new</span> Derived;<span class="hljs-comment">//new谁就调谁的构造函数,非常直觉,不是虚函数</span><span class="hljs-comment">//但是析构函数需要是虚函数!</span><span class="hljs-built_in">fun</span>(d);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//多态有损性能 对,但是带来了很多好处!</span><span class="hljs-comment">//若类内有一个虚函数,应该尽可能写虚函数 对.只有构造函数(?)和static不能写虚函数</span></code></pre></div><h2 id="5-设计模式">5. 设计模式</h2><h2 id="6-Windows-Programming">6. Windows Programming</h2><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">//异常处理Exception</span>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int m)</span></span> <span class="hljs-keyword">throw</span>(int)&#123;<span class="hljs-keyword">if</span>(m==<span class="hljs-number">5</span>)   <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;&#125;void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int* p)</span></span>&#123;<span class="hljs-comment">//头文件 #include&lt;assert.h&gt;</span>assert(p!=NULL) <span class="hljs-comment">//用于debug！避免出现程序卡死。</span><span class="hljs-comment">//可以通过定义宏 #NDEBUG 使代码中所有断言失效。</span><span class="hljs-keyword">if</span>(p == NULL)&#123;cout&lt;&lt;<span class="hljs-string">&quot;sorry&quot;</span>&lt;&lt;endl;&#125;&#125;int main()&#123;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<span class="hljs-keyword">catch</span>(int e)&#123;<span class="hljs-keyword">if</span>(e==<span class="hljs-number">1</span>)cout&lt;&lt;<span class="hljs-string">&quot;sorry!&quot;</span>&lt;&lt;endl;&#125;<span class="hljs-keyword">catch</span>(...)<span class="hljs-comment">//接受一切异常！</span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;sorry!&quot;</span>&lt;&lt;endl;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>面向对象</tag>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyRenderer 0&amp;1</title>
    <link href="/2022/05/05/TinyRenderer-0-1/"/>
    <url>/2022/05/05/TinyRenderer-0-1/</url>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>TinyRenderer是国外一个大佬写的几百行的软件光栅化渲染器，API模拟了OpenGL，主要目的在于理解OpenGL在后台干了什么。</p><p>通过复现这段大约500行的代码, 我想我能更加深入的了解图形学的底层原理.</p><p>有些话适合用中文,有些话适合用英文(包括一些引用),原谅我中英混杂(反正也不算是教程吧</p><p>(btw, I want to say that this is not just a simple translated version of the wiki on github, it is consist of my own feelings and thoughts.)</p><p>我的IDE(雾)使用的是VScode搭配自带的插件, 多文件编译直接使用了自带的插件C/C++ Project Generator.</p><p>顺带一提，里面贴的代码都是我自己写的，可能不够工整和正确，如果需要能保证规范正确的源代码请访问<a href="https://github.com/ssloy/tinyrenderer/wiki">该项目的GitHub</a>。</p><h1>TinyRenderer 0 : draw a ponit on your screen</h1><div class="note note-success">            <p>Since the goal is to minimize external dependencies, I am allowed to only work with <a href="http://en.wikipedia.org/wiki/Truevision_TGA">TGA</a> files. It’s one of the simplest formats that supports images in RGB/RGBA/black and white formats. So, as a starting point, I’ll obtain a simple way to work with pictures. You should note that the only functionality available at the very beginning (in addition to loading and saving images) is the capability to set the color of one pixel.</p>          </div><p>There are no functions for drawing line segments and triangles. I’ll have to do all of this by hand.</p><h2 id="Include-tgas-file">Include tgas file</h2><p>因为开始这个项目需要对tga文件的读取和保存功能，我们需要先下载 <code>tgaimage.h</code>和 <code>tgaimage.cpp</code>两个文件，并放入我们的项目中。引入后，可能需要先熟悉一下自带的方法，以备之后使用所需。</p><p>此外，我为了在电脑上直接查看tga类型的文件，还在网上下载了一个tga view软件。</p><h2 id="just-draw-a-point">just draw a point</h2><p>因为这一步太简单，我没什么好说的。</p><p>直接复制啦~</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tgaimage.h&quot;</span></span><span class="hljs-type">const</span> TGAColor white = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-type">const</span> TGAColor red   = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">255</span>);<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;        <span class="hljs-function">TGAImage <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, TGAImage::RGB)</span></span>;        image.<span class="hljs-built_in">set</span>(<span class="hljs-number">52</span>, <span class="hljs-number">41</span>, red);        image.<span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// i want to have the origin at the left bottom corner of the image</span>        image.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;output.tga&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h1>TinyRenderer 1 : draw a line</h1><p>在本章节中,作者总共进行了5次尝试:</p><h2 id="1-画一条普通的线">1. 画一条普通的线</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-type">float</span> t=<span class="hljs-number">0.</span>; t&lt;<span class="hljs-number">1.</span>; t+=<span class="hljs-number">.01</span>) &#123;         <span class="hljs-type">int</span> x = x0 + (x1-x0)*t;         <span class="hljs-type">int</span> y = y0 + (y1-y0)*t;         image.<span class="hljs-built_in">set</span>(x, y, color);     &#125; &#125;</code></pre></div><p>这种算法固然可以,但是由于我们很难决定t的增量值:</p><div class="code-wrapper"><pre><code class="hljs">当t的增量过小,产生大量资源浪费当t的增量过大,线条割裂感严重</code></pre></div><p>因此这是一种低效的算法</p><p>进行改良:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=x0; x&lt;=x1; x++) &#123;         <span class="hljs-type">float</span> t = (x-x0)/(<span class="hljs-type">float</span>)(x1-x0);         <span class="hljs-type">int</span> y = y0*(<span class="hljs-number">1.</span>-t) + y1*t;         image.<span class="hljs-built_in">set</span>(x, y, color);     &#125; &#125;</code></pre></div><p>此时,t的大小自动产生,不需要我们自己设置了!但是产生了新的问题:</p><h2 id="2-同时画三条线-各自具备自己的特点">2.同时画三条线,各自具备自己的特点:</h2><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">line</span>(<span class="hljs-number">13</span>, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">40</span>, image, white); <span class="hljs-attribute">line</span>(<span class="hljs-number">20</span>, <span class="hljs-number">13</span>, <span class="hljs-number">40</span>, <span class="hljs-number">80</span>, image, red); <span class="hljs-attribute">line</span>(<span class="hljs-number">80</span>, <span class="hljs-number">40</span>, <span class="hljs-number">13</span>, <span class="hljs-number">20</span>, image, red);</code></pre></div><p><img src="https://s3.bmp.ovh/imgs/2022/05/14/31d795e4522403f6.png" alt=""></p><p>此时可以看到, 结果和我们预想的明显不同, 那么发生了什么问题呢?</p><p>第一条线, 和第一次尝试一样没有区别, 成功</p><p>第二条线是一条陡峭(steep)的线,此时我们可以看到线段非常明显的产生割裂—&gt;x的增量小,y的增量大,明显,应该考虑利用y生成x</p><p>第三条线完全没出现: 因为是从右到左给的点,函数不兼容!</p><p>有没有什么办法,可以使其具有对称性(交换两点的位置得到相同的直线)和不受线段斜率影响呢?</p><h2 id="3-进行算法的改良">3.进行算法的改良</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123;     <span class="hljs-type">bool</span> steep = <span class="hljs-literal">false</span>;     <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(x0-x1)&lt;std::<span class="hljs-built_in">abs</span>(y0-y1)) &#123; <span class="hljs-comment">// if the line is steep, we transpose the image </span>        std::<span class="hljs-built_in">swap</span>(x0, y0);         std::<span class="hljs-built_in">swap</span>(x1, y1);         steep = <span class="hljs-literal">true</span>;     &#125;     <span class="hljs-keyword">if</span> (x0&gt;x1) &#123; <span class="hljs-comment">// make it left−to−right </span>        std::<span class="hljs-built_in">swap</span>(x0, x1);         std::<span class="hljs-built_in">swap</span>(y0, y1);     &#125;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=x0; x&lt;=x1; x++) &#123;         <span class="hljs-type">float</span> t = (x-x0)/(<span class="hljs-type">float</span>)(x1-x0);         <span class="hljs-type">int</span> y = y0*(<span class="hljs-number">1.</span>-t) + y1*t;         <span class="hljs-keyword">if</span> (steep) &#123;             image.<span class="hljs-built_in">set</span>(y, x, color); <span class="hljs-comment">// if transposed, de−transpose </span>        &#125; <span class="hljs-keyword">else</span> &#123;             image.<span class="hljs-built_in">set</span>(x, y, color);         &#125;     &#125; &#125;</code></pre></div><p>可以看到,此时我们解决了以上两种情况,但是,到此为止了吗?</p><p>图形学是一个性能敏感的学科!尤其是实时渲染, 非常看重fps,因此,我们尝试着优化一下性能吧?</p><p>不急,先看看哪部分最值得优化:</p><div class="code-wrapper"><pre><code class="hljs zephir">%   cumulative   <span class="hljs-keyword">self</span>              <span class="hljs-keyword">self</span>     total  time   seconds   seconds    calls  ms/call  ms/call  name  <span class="hljs-number">69.16</span>      <span class="hljs-number">2.95</span>     <span class="hljs-number">2.95</span>  <span class="hljs-number">3000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  line(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, TGAImage&amp;, TGAColor)  <span class="hljs-number">19.46</span>      <span class="hljs-number">3.78</span>     <span class="hljs-number">0.83</span> <span class="hljs-number">204000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  TGAImage::set(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, TGAColor)   <span class="hljs-number">8.91</span>      <span class="hljs-number">4.16</span>     <span class="hljs-number">0.38</span> <span class="hljs-number">207000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  TGAColor::TGAColor(TGAColor <span class="hljs-keyword">const</span>&amp;)   <span class="hljs-number">1.64</span>      <span class="hljs-number">4.23</span>     <span class="hljs-number">0.07</span>        <span class="hljs-number">2</span>    <span class="hljs-number">35.04</span>    <span class="hljs-number">35.04</span>  TGAColor::TGAColor(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)   <span class="hljs-number">0.94</span>      <span class="hljs-number">4.27</span>     <span class="hljs-number">0.04</span>                             TGAImage::get(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</code></pre></div><p>可以看到, 画线段的line函数花费了70%的时间!(果然是我们函数写的太丑了</p><p>下面我们来看看看如何优化吧!</p><h2 id="4-算法的性能优化">4.算法的性能优化</h2><p>先上代码!</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123;     <span class="hljs-type">bool</span> steep = <span class="hljs-literal">false</span>;     <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(x0-x1)&lt;std::<span class="hljs-built_in">abs</span>(y0-y1)) &#123;         std::<span class="hljs-built_in">swap</span>(x0, y0);         std::<span class="hljs-built_in">swap</span>(x1, y1);         steep = <span class="hljs-literal">true</span>;     &#125;     <span class="hljs-keyword">if</span> (x0&gt;x1) &#123;         std::<span class="hljs-built_in">swap</span>(x0, x1);         std::<span class="hljs-built_in">swap</span>(y0, y1);     &#125;     <span class="hljs-type">int</span> dx = x1-x0;     <span class="hljs-type">int</span> dy = y1-y0;     <span class="hljs-type">float</span> derror = std::<span class="hljs-built_in">abs</span>(dy/<span class="hljs-built_in">float</span>(dx));     <span class="hljs-type">float</span> error = <span class="hljs-number">0</span>;     <span class="hljs-type">int</span> y = y0;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=x0; x&lt;=x1; x++) &#123;         <span class="hljs-keyword">if</span> (steep) &#123;             image.<span class="hljs-built_in">set</span>(y, x, color);         &#125; <span class="hljs-keyword">else</span> &#123;             image.<span class="hljs-built_in">set</span>(x, y, color);         &#125;         error += derror;         <span class="hljs-keyword">if</span> (error&gt;<span class="hljs-number">.5</span>) &#123;             y += (y1&gt;y0?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);             error -= <span class="hljs-number">1.</span>;         &#125;     &#125; &#125;</code></pre></div><p>区别在哪里?</p><p>在最新的函数里,我们将dx,dy提出来做了计算,这样就不用在循环里做反复的计算了!可以想象,应该能省小一半的时间吧!</p><div class="code-wrapper"><pre><code class="hljs pgsql">%   cumulative   self              self     total  <span class="hljs-type">time</span>   seconds   seconds    calls  ms/<span class="hljs-keyword">call</span>  ms/<span class="hljs-keyword">call</span>  <span class="hljs-type">name</span>  <span class="hljs-number">38.79</span>      <span class="hljs-number">0.93</span>     <span class="hljs-number">0.93</span>  <span class="hljs-number">3000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  line(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, TGAImage&amp;, TGAColor)  <span class="hljs-number">37.54</span>      <span class="hljs-number">1.83</span>     <span class="hljs-number">0.90</span> <span class="hljs-number">204000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  TGAImage::<span class="hljs-keyword">set</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, TGAColor)  <span class="hljs-number">19.60</span>      <span class="hljs-number">2.30</span>     <span class="hljs-number">0.47</span> <span class="hljs-number">204000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  TGAColor::TGAColor(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)   <span class="hljs-number">2.09</span>      <span class="hljs-number">2.35</span>     <span class="hljs-number">0.05</span>        <span class="hljs-number">2</span>    <span class="hljs-number">25.03</span>    <span class="hljs-number">25.03</span>  TGAColor::TGAColor(unsigned <span class="hljs-type">char</span>, unsigned <span class="hljs-type">char</span>, unsigned <span class="hljs-type">char</span>, unsigned <span class="hljs-type">char</span>)   <span class="hljs-number">1.25</span>      <span class="hljs-number">2.38</span>     <span class="hljs-number">0.03</span>                             TGAImage::<span class="hljs-keyword">get</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</code></pre></div><p>果不其然!省了一大半的时间!</p><p>还能不能继续省呢?</p><p>可以! C++语言中, 浮点数计算时间远超整型数!</p><p>既然像素一定是整数,为什么我们要用浮点数!不如取整吧!</p><h2 id="5-Bresenham’s-Line-Drawing-Algorithm">5.Bresenham’s Line Drawing Algorithm</h2><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123;     <span class="hljs-type">bool</span> steep = <span class="hljs-literal">false</span>;     <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(x0-x1)&lt;std::<span class="hljs-built_in">abs</span>(y0-y1)) &#123;         std::<span class="hljs-built_in">swap</span>(x0, y0);         std::<span class="hljs-built_in">swap</span>(x1, y1);         steep = <span class="hljs-literal">true</span>;     &#125;     <span class="hljs-keyword">if</span> (x0&gt;x1) &#123;         std::<span class="hljs-built_in">swap</span>(x0, x1);         std::<span class="hljs-built_in">swap</span>(y0, y1);     &#125;     <span class="hljs-type">int</span> dx = x1-x0;     <span class="hljs-type">int</span> dy = y1-y0;     <span class="hljs-type">int</span> derror2 = std::<span class="hljs-built_in">abs</span>(dy)*<span class="hljs-number">2</span>;     <span class="hljs-type">int</span> error2 = <span class="hljs-number">0</span>;     <span class="hljs-type">int</span> y = y0;     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x=x0; x&lt;=x1; x++) &#123;         <span class="hljs-keyword">if</span> (steep) &#123;             image.<span class="hljs-built_in">set</span>(y, x, color);         &#125; <span class="hljs-keyword">else</span> &#123;             image.<span class="hljs-built_in">set</span>(x, y, color);         &#125;         error2 += derror2;         <span class="hljs-keyword">if</span> (error2 &gt; dx) &#123;             y += (y1&gt;y0?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);             error2 -= dx*<span class="hljs-number">2</span>;         &#125;     &#125; &#125;</code></pre></div><p>嗯嗯, 摆脱了浮点数,再来看看时间:</p><div class="code-wrapper"><pre><code class="hljs zephir">%   cumulative   <span class="hljs-keyword">self</span>              <span class="hljs-keyword">self</span>     total  time   seconds   seconds    calls  ms/call  ms/call  name  <span class="hljs-number">42.77</span>      <span class="hljs-number">0.91</span>     <span class="hljs-number">0.91</span> <span class="hljs-number">204000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  TGAImage::set(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, TGAColor)  <span class="hljs-number">30.08</span>      <span class="hljs-number">1.55</span>     <span class="hljs-number">0.64</span>  <span class="hljs-number">3000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  line(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, TGAImage&amp;, TGAColor)  <span class="hljs-number">21.62</span>      <span class="hljs-number">2.01</span>     <span class="hljs-number">0.46</span> <span class="hljs-number">204000000</span>     <span class="hljs-number">0.00</span>     <span class="hljs-number">0.00</span>  TGAColor::TGAColor(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)   <span class="hljs-number">1.88</span>      <span class="hljs-number">2.05</span>     <span class="hljs-number">0.04</span>        <span class="hljs-number">2</span>    <span class="hljs-number">20.02</span>    <span class="hljs-number">20.02</span>  TGAColor::TGAColor(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)</code></pre></div><p>又快了不少! 甚至掉下耗时第一名了!真厉害!</p><h2 id="6-总结">6.总结</h2><p>结合五次尝试,我说说我自己的感想吧:</p><ol><li>光栅化是以屏幕为基础的,也就是说心里一定要有像素的概念! 现实世界不能无限细分,有些数学会被限制拳脚,但也因此我们能产生像bresenham算法这样化零为整的偷懒方法!</li><li>性能优化比想象的重要. 图形学的算法几乎都是极度复杂的递归或者迭代算法,一个小小的改变就能极大影响速度<br>通过两个简单的改动,我们将line()函数优化到了原来的1/5.</li><li>考虑一定要周全. 图形学是一个不在乎边界条件的学科,但是也是一个非常严谨的学科. 一个函数的不严谨会在无数次调用中发挥巨大的杀伤力</li></ol><p><strong>这里我必须告诫我自己: 你一定要能动手写代码!千万不能照抄! 一定要能自己写! 看着简单但其实不写是不会发现坑的!</strong></p><p>最后贴一下自己的代码:</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//bresenham&#x27;s line drawing algorithem</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">line</span><span class="hljs-params">(<span class="hljs-type">int</span> x0, <span class="hljs-type">int</span> y0, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, TGAImage &amp;image, TGAColor color)</span> </span>&#123;    <span class="hljs-type">bool</span> steep = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(x0-x1)&lt;std::<span class="hljs-built_in">abs</span>(y0-y1)) &#123;        std::<span class="hljs-built_in">swap</span>(x0, y0);        std::<span class="hljs-built_in">swap</span>(x1, y1);        steep = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (x0&gt;x1) &#123;        std::<span class="hljs-built_in">swap</span>(x0, x1);        std::<span class="hljs-built_in">swap</span>(y0, y1);    &#125;    <span class="hljs-type">int</span> dy = y1 - y0;    <span class="hljs-type">int</span> dx = x1 - x0;    <span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> derror = std::<span class="hljs-built_in">abs</span>(dy) * <span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = x0,y = y0; x &lt;= x1; x++)    &#123;          <span class="hljs-keyword">if</span> (steep) &#123;            image.<span class="hljs-built_in">set</span>(y, x, color);        &#125; <span class="hljs-keyword">else</span> &#123;            image.<span class="hljs-built_in">set</span>(x, y, color);        &#125;        error += derror;        <span class="hljs-keyword">if</span>(errno&gt;dx)        &#123;            y += (y1&gt;y0?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);             error -= dx*<span class="hljs-number">2</span>;         &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>图形学</category>
      
      <category>TinyRenderer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>C++</tag>
      
      <tag>TinyRenderer</tag>
      
      <tag>软件光栅化渲染器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在unity中使用MYsql</title>
    <link href="/2022/04/01/%E5%9C%A8unity%E4%B8%AD%E4%BD%BF%E7%94%A8MYsql/"/>
    <url>/2022/04/01/%E5%9C%A8unity%E4%B8%AD%E4%BD%BF%E7%94%A8MYsql/</url>
    
    <content type="html"><![CDATA[<p>咕咕咕</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
