---
title: 目标代码生成
date: 2023-11-19 12:18:22
excerpt: 从零开始的编译器之目标代码生成
tags: [编译技术,MIPS,代码生成]
categories: [技术,编译技术]
topic: compiler
---

# 目标代码生成之MIPS

## 总体结构

所有MIPS代码生成的部分都属于包`backend`，结构如下：

<img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231212142956012.png" alt="image-20231212142956012" style="zoom:50%;" />

接下来我们具体介绍一下：

1. `MIPSInst`包：这个包用于存放MPIS的指令，分为Syscall指令，I型指令，J型指令，和R型指令，这四个类又继承于基类`MInstruction`。
2. `MIPSTable`包：这个包用于存放MIPS生成过程中的符号表和符号类。
3. `MIPSValues`包：这个包用于存放MIPS生成中的Value类。所有Value都要实现接口`MValue`，包括MemAddr、Label、MInstruction、MFucntion、MBasicBlock、Register等。此外，还有接口`Immediate`用于表示MIPS中的立即数，`FrameStack`中的占位符`Placeholder`类和`ImmediateNumber`类实现了这个接口。
4. `BackController`类：这个类用于生成和管理`MIPSBuilder`、`RegisterManager`等单例类，并控制文件的读写。
5. `MIPSBuilder`类：这个类是生成MIPS代码的主类，通过分析此前生成的LLVM代码来生成对应的MIPS代码。
6. `RegisterManager`类：这个类用于管理和分配寄存器。

## 指令的翻译

在开始翻译之前，我们首先需要理清思路。以一段简单的C语言代码为例：

```c
int a=2,b[3]={1,2,3},c;
int main(){
    int x=1,y=2;
    y = x+y;
    return 0;
}
```

生成LLVM中间代码为：

```assembly
@a = dso_local global i32 2
@b = dso_local global [3 x i32] [i32 1, i32 2, i32 3]
@c = dso_local global i32 0

define dso_local i32 @main (){
	%1 = alloca i32
	store i32 1, i32* %1
	%2 = alloca i32
	store i32 2, i32* %2
	%3 = load i32, i32* %1
	%4 = load i32, i32* %2
	%5 = add i32 %3, %4
	store i32 %5, i32* %2
	ret i32 0
}
```

> ⚠️注意：我们的任务是将生成的LLVM中间代码翻译为MIPS汇编代码，因此不应该在生成时继续依赖原始的C代码。

可以看出，在目标代码生成的过程中，我们需要存放在符号表里的是全局变量和使用`alloc`指令申请的变量（即C语言中的局部变量）

因为在此阶段我们不考虑优化，因此全部的局部变量我们都存放在内存中。

故符号表为：

| name | symbolType |
| ---- | ---------- |
| a    | GLOBAL     |
| b    | GLOBAL     |
| c    | GLOBAL     |
| %1   | MEM        |
| %2   | MEM        |

由于我们在编写LLVM时每次访问某个变量都会重新申请寄存器存放其值，LLVM中每个寄存器（除了存放变量地址的寄存器外）都只会被访问一次。通过这个性质，我们容易知道，当代码中同时未被访问的临时寄存器不超过10个（MIPS中只有10个$t寄存器）时，临时变量都不需要写入内存。

在目标代码生成阶段，**我们暂时有理由相信同时需要准备的临时寄存器不超过10个**。因为这样的样例非常强。把寄存器的分配统一留到后面代码优化时可能是个更节省时间的选择。

基于如上假设，指令的翻译将会变的非常简单。

### alloc

```assembly
	%1 = alloca i32
```

显然，这对应着一个需要存入内存和符号表的变量，但是没有被使用。因此，我们只需要在符号表记录下其位置，而不需要翻译为任何命令。

值得注意的是，对于普通变量和数组指针，我们只需要申请一个word的空间就够了，但是对于局部数组，我们要根据数组内元素的数量申请n个wrod。

### store

赋值有四种情况：

1. 给局部普通变量赋值
2. 给局部数组变量赋值
3. 给全局普通变量赋值
4. 给全局数组变量赋值
5. 给参数普通和数组变量赋值

我们来依次分析这四种情况：

**情况一： 给局部普通变量赋值**

```c
int k=1;
```

LLVM

```assembly
	%7 = alloca i32
	store i32 1, i32* %7
```

这种情况下，%7所对应的一定是MIPS栈空间的一段内存地址，且符号表中已经记录，直接查表即可。

此外，如果store的值是常量(除了0)的话，要先把常量load进临时寄存器，然后再sw。

MIPS

```assembly
	li $t0 1
	sw $t0 offset($fp)
```

**情况二： 给局部数组变量赋值**

```c
    int p[1]={1};
```

```assembly
	%8 = alloca [1 x i32]
	%9 = getelementptr [1 x i32], [1 x i32]* %8, i32 0, i32 0
	store i32 1, i32* %9
```

这种情况下，此前我们一定已经翻译了`%9 = getelementptr [1 x i32], [1 x i32]* %8, i32 0, i32 0`这条指令。这条取址指令也不用翻译为任何MIPS指令，只需要将标识符`%9`和其对应的地址记录在符号表中。因此查表就可以得到%9对应的偏移

```assembly
  li $t0 1
  sw $t0 offset($fp)
```

**情况三： 给全局普通变量赋值**

```c
//a是全局变量
a = 3;
```

```assembly
	store i32 3, i32* @a
```

这种情况下，我们的做法甚至更简单。

```assembly
  li $t0 3
  sw $t0 a
```

**情况四： 给全局数组变量赋值**

```c
//b是全局数组
b[2] = 10
```

```assembly
	%8 = getelementptr [3 x i32], [3 x i32]* @b, i32 0, i32 2
	store i32 10, i32* %8
```

这种情况下，此前我们一定已经翻译了`%8 = getelementptr [3 x i32], [3 x i32]* @b, i32 0, i32 2`这条指令。这条取址指令也不用翻译为任何MIPS指令，只需要将标识符`%8`和其对应的地址记录在符号表中。因此查表就可以得到%8对应的地址。

```assembly
  li $t0 10
  sw $t0 offset(b)
```

**情况五：给参数普通和数组变量赋值**

```c
void fun(int a, int b[]){
  a = 5;
	b[0] = 10;
}
```

这一点会比较神奇。我们知道llvm对于传参的处理是要先保存在本地的寄存器中，然后再进行取用，这其实与MIPS的机制不太符合。

因为MIPS每个函数的栈帧会专门留出传参区域供后续函数使用，因此重复的保存似乎显得非常多余。

```assembly
define dso_local void @fun (i32 %0, i32* %1){
	//保存参数
	%3 = alloca i32
	store i32 %0, i32* %3
	%4 = alloca i32*
	store i32* %1, i32** %4
	//函数开始
	store i32 5, i32* %3
	%5 = load i32*, i32** %4
	%6 = getelementptr i32, i32* %5, i32 0
	store i32 10, i32* %6
	ret void
}
```

因此，我们在保存参数的阶段可以不要直接翻译，而是把`%3`，`%4`及其对应的内存地址直接存入符号表。

这样，对于`  a = 5;`的处理就与前文完全一致，为

```assembly
  li $t0 10
  sw $t0 %3
```

而对于`b[0] = 10;`我们反推回去：`%6`一定存放了其对应的地址记录，`%5`存放了`%4`对应的地址，故也与前文无异。

**所以总结下来，store的翻译不会因为情况不同而产生不同的处理方式，直接查表即可。**

最后补充一下rt不是立即数的情况，如：

```assembly
	store i32 %7, i32* %8
```

这种情况下，`%7`也成了需要查表访问的对象。根据LLVM的性质，我们知道在此之前一定会有一个`load`语句帮我们将`%7`放在临时寄存器中并记录在符号表里，因此我们直接查表使用即可。

### load

只会有这三种情况

```assembly
load i32, i32* %4 
load i32*, i32** %5
load [3 x i32]*, [3 x i32]** %6
```

调用load时，我们有理由相信`%4 %5 %6`三个标识符已经在表里了。

所以直接查表翻译即可。

### getelementptr

在LLVM中，只有在使用数组的时候会用到getelementptr，因此我们考虑全局数组、局部数组和参数数组三种情况：

1. **全局数组和局部数组**

```assembly
	%16 = getelementptr [3 x i32], [3 x i32]* @b, i32 0, i32 2
	%17 = load i32, i32* %16

	%18 = getelementptr [2 x i32], [2 x i32]* %8, i32 0, i32 0
	%19 = load i32, i32* %18
```

对于全局数组来说，基地址即为`@b`，而在mips中直接根据维度计算出偏移即可，因此可以翻译为：

```
	addi $t0 b 3*0+1*2
	lw $t1 $t0
	
	addi $t0 getReg(%8) 2*0+1*0
	lw $t2 $t0
```

但是需要注意的是，`getelementptr`后面的偏移量有可能不是常数而是寄存器的值，这时候就得先取出来了。

2. **参数数组**

这部分比较复杂，先不说明。若有时间再具体介绍。

## 总结

MIPS生成指导书给出的教程比较简略，因此需要发挥自己的主观能动性，先学习和了解MIPS的基本知识，如寄存器用法、函数调用等，然后根据自己的中间代码进行生成。生成的我累死了。
