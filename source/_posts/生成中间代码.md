---
title: 中间代码生成
date: 2023-11-15 10:39:05
excerpt: 从零开始的编译器之中间代码生成
categories: [技术, 编译技术]
tags: [中间代码, LLVM, 代码生成]
topic: compiler
---

# LLVM中间代码生成

## 总体结构

中间代码生成器相关的类我全部放在了包`IR`中，结构如下：

<img src="https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231212135953120.png" alt="image-20231212135953120" style="zoom:25%;" />

其中：

1. `IRTable`包中存放了中间代码生成过程中使用的符号表结构以及符号类。
2. `Value`包中存放了LLVM中所有的Value类，其中`IRValue`是所有Value的基类，Fucntion、BasicBlock和Value分别代表LLVM中的函数、基本块和临时寄存器。
   1. `ConstVal`和`GlobalVar`代表常量和全局变量，继承自Value。
   2. `Instruction`包中存放了所有的LLVM指令类。指令类存在一个基类`Instruction`,所有的指令类都继承自这个基类。
   3. `Use`和`User`是为了代码优化，后续应该还会继续优化，因此先按下不表。
3. `MideController`是整个过程的控制类，也负责生成和管理`Visitor`和`IRBuildFactory`的单例和文件的读写。
4. `Visitor`和`IRBuildFactory`两个类相互协助生成LLVM，其中`Visitor`分析抽象语法树，`IRBuildFactory`根据Visitor得到的信息生成对应的LLVM代码。

因为指导书的内容已经较为详细具体，因此这里仅补充一个专题。

## 专题：变量的声明和使用

这部分比较难，所以开一个专题专门分析一下。

### 一、普通类型变量

普通类型变量即`Btype`类型变量，因其不涉及指针和数据的操作，是最简单的变量类型。

源程序：

```c
int a0 = 0;

void func1(int a){
    return;
}

int main() {
    int a1 =1;
    a0 = 2;
    a1 = 3;
    func1(a0);
    func1(a1);
	return 0;
}
```

#### 1. 全局变量

让我们将目光聚焦于生成的LLVM代码的全局变量部分：
```assembly
@a0 = global i32 0, align 4

define i32 @main() {
	...
  store i32 2, i32* @a0, align 4
  %3 = load i32, i32* @a0, align 4
  call void @func1(i32 %3)
	...
}
```

可以看到，声明时，全局变量标识符`@a0	`存放了其内存地址，类型为`Btype*`。

为其赋值时可直接使用`  store i32 2, i32* @a0, align 4`

取其值时可直接使用`  %3 = load i32, i32* @a0, align 4`。

#### 2. 局部变量

```assembly
define i32 @main() {
  %2 = alloca i32, align 4
  store i32 1, i32* %2, align 4
  store i32 3, i32* %2, align 4
  %4 = load i32, i32* %2, align 4
  call void @func1(i32 %4)
}
```

可以看到，为了声明一个局部变量，我们需要使用到`  %2 = alloca i32, align 4`

此时`%2`寄存器存放了这个局部变量在内存中的指针，故`%2`的类型为`Btype*`。

同理，当我们想要给局部变量赋值时，只要向这段地址写入对应的值即可，`  store i32 3, i32* %2, align 4`，特别地，局部变量的初始化也可以看做是为其赋值。

取其值时可直接使用`%4 = load i32, i32* %2, align 4`。

### 二、数组类型变量

这部分非常复杂，话不多说，上代码。

```c
int a0[1];
int b0[1][1];

void func1(int a, int b[]){
    return;
}

void func2(int a, int b[], int c[][1]){
    a;
    b[0];
    c[0][0];

    func1(b[0], c[0]);
    func2(a, b, c);
    return;
}

int main() {
    int a1[1] = {0};
    int b1[1][1] = {{0}};

    a0[0] = 1;
    b0[0][0] = 1;

    a1[0] = 1;
    b1[0][0] = 1;

    func1(a0[0], a0);
    func1(a1[0], a1);

    func2(b0[0][0], b0[0], b0);
    func2(b1[0][0], b1[0], b1);

	return 0;
}
```

#### 1. 全局数组

```assembly
@a0 = global [1 x i32] zeroinitializer, align 4
@b0 = global [1 x [1 x i32]] zeroinitializer, align 4

define i32 @main() {
	...
  store i32 1, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0), align 4
  store i32 1, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4
	...
  %9 = load i32, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0), align 4
  call void @func1(i32 %9, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0))
  ...
  %13 = load i32, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4
  call void @func2(i32 %13, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), [1 x i32]* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0))
  ret i32 0
}
```

首先，在声明上，`@a0`和`@b0`仍然存放着对应数组的指针，类型分别为`[1 x i32]*`和`[1 x [1 x i32]]*`。

这里我们先假设赋值语句只会对数组中的**一个基本类型值**进行赋值，那么，赋值的过程如下：

1. 根据数组标识符后的偏移值取得该“基本类型值”的内存中的指针
2. 向这段地址写入值

```assembly
store i32 1, i32* getelementptr inbounds ([1 x i32], [1 x i32]* @a0, i64 0, i64 0), align 4
store i32 1, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4
```

使用其值时，逻辑会更加复杂。

这里我们以`b0`为例：

1. 当我们要取`b[0][0]`时：

```assembly
%13 = load i32, i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0), align 4
```

2. 当我们要取`b[0]`时：

按照朴素的理解，猜想应该是：

```assembly
[1 x 32i]* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0)
```

但是其实应该是：

```assembly
i32* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0, i64 0)
```

可以看到，这两个命令对地址`@b0`的getelementptr操作完全相同，只是`b[0][0]`多了一个取值的操作。

也就是说，在取址会故意多取一层，这与我们在处理函数形参时完全对应。

3. 同样的，直接取`b0`时：

```assembly
[1 x i32]* getelementptr inbounds ([1 x [1 x i32]], [1 x [1 x i32]]* @b0, i64 0, i64 0)
```

#### 2. 局部数组

```assembly
define i32 @main() #0 {
	...
  %2 = alloca [1 x i32], align 4
  %3 = alloca [1 x [1 x i32]], align 4
  %4 = bitcast [1 x i32]* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %4, i8 0, i64 4, i1 false)
  %5 = bitcast [1 x [1 x i32]]* %3 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %5, i8 0, i64 4, i1 false)
  ...
  %6 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0
  %8 = getelementptr inbounds [1 x i32], [1 x i32]* %7, i64 0, i64 0
  store i32 1, i32* %8, align 4
  ...
  %10 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0
  %11 = load i32, i32* %10, align 4
  %12 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0
  call void @func1(i32 %11, i32* %12)
	...
  %14 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0
  %15 = getelementptr inbounds [1 x i32], [1 x i32]* %14, i64 0, i64 0
  %16 = load i32, i32* %15, align 4
  %17 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 1
  %18 = getelementptr inbounds [1 x i32], [1 x i32]* %17, i64 0, i64 0
  %19 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0
  call void @func2(i32 %16, i32* %18, [1 x i32]* %19)
  ret i32 0
}
```

首先在声明时，与普通类型变量类似，数组类型变量也会先申请空间：
```assembly
  %2 = alloca [1 x i32], align 4
  %3 = alloca [1 x [1 x i32]], align 4
```

这段代码中的初始化部分引入了新的复杂指令和函数，故先不看。我们也可以采用赋值和`zeroinitialier`来进行初始化。

那么怎么对数组元素进行赋值呢？与全局数组类似，先取得对应元素的指针，然后直接赋值即可：
```assembly
  %6 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0
  %8 = getelementptr inbounds [1 x i32], [1 x i32]* %7, i64 0, i64 0
  store i32 1, i32* %8, align 4
```

最后，**使用的方法**也和全局数组一致完全一致，这里就不再赘述。

### 三、函数中的形参

```assembly
define void @func2(i32 %0, i32* %1, [1 x i32]* %2) #0 {
  %4 = alloca i32, align 4
  %5 = alloca i32*, align 8
  %6 = alloca [1 x i32]*, align 8
  store i32 %0, i32* %4, align 4
  store i32* %1, i32** %5, align 8
  store [1 x i32]* %2, [1 x i32]** %6, align 8
  %7 = load i32, i32* %4, align 4
  %8 = load i32*, i32** %5, align 8
  %9 = getelementptr inbounds i32, i32* %8, i64 0
  %10 = load i32, i32* %9, align 4
  %11 = load [1 x i32]*, [1 x i32]** %6, align 8
  %12 = getelementptr inbounds [1 x i32], [1 x i32]* %11, i64 0
  %13 = getelementptr inbounds [1 x i32], [1 x i32]* %12, i64 0, i64 0
  %14 = load i32, i32* %13, align 4
  %15 = load i32*, i32** %5, align 8
  %16 = getelementptr inbounds i32, i32* %15, i64 0
  %17 = load i32, i32* %16, align 4
  %18 = load [1 x i32]*, [1 x i32]** %6, align 8
  %19 = getelementptr inbounds [1 x i32], [1 x i32]* %18, i64 0
  %20 = getelementptr inbounds [1 x i32], [1 x i32]* %19, i64 0, i64 0
  call void @func1(i32 %17, i32* %20)
  %21 = load i32, i32* %4, align 4
  %22 = load i32*, i32** %5, align 8
  %23 = load [1 x i32]*, [1 x i32]** %6, align 8
  call void @func2(i32 %21, i32* %22, [1 x i32]* %23)
  ret void
}
```

可以看到，函数`@func2`一共接受了三种类型的参数：`i32`, `i32*`, `[1 x i32]*`，我们分别来看看如何使用。

#### 1. 普通类型变量

```assembly
define void @func2(i32 %0, i32* %1, [1 x i32]* %2) #0 {
  %4 = alloca i32, align 4
  store i32 %0, i32* %4, align 4
  ...
  }
```

可以看到，我们只要新建一个局部变量来接受此变量即可。

#### 2. 数组类型变量

首先我们需要注意到，无论数组类型形参的如何定义，始终都会以指针的形式出现。

如下两种写法最后生成的llvm代码会完全一致。

```c
void func2(int a, int b[], int c[][1]);
void func2(int a, int b[1], int c[1][1]);
```

首先，我们仍然需要新建局部变量来存放指针类型的值：

```assembly
  %5 = alloca i32*, align 8
  %6 = alloca [1 x i32]*, align 8
  store i32* %1, i32** %5, align 8
  store [1 x i32]* %2, [1 x i32]** %6, align 8
```

接下来让我们看看赋值,已经知道赋值的流程为：取得元素地址->store，

回忆一下怎么给普通的数组元素赋值：

```assembly
  %6 = getelementptr inbounds [1 x i32], [1 x i32]* %2, i64 0, i64 0
  store i32 1, i32* %6, align 4
  %7 = getelementptr inbounds [1 x [1 x i32]], [1 x [1 x i32]]* %3, i64 0, i64 0
  %8 = getelementptr inbounds [1 x i32], [1 x i32]* %7, i64 0, i64 0
  store i32 1, i32* %8, align 4
```

这里的`%2`和`%3`寄存器的数据类型是`[1 x i32]*`和`[1 x [1 x i32]]*`，而我们的`%5`和`%6`的数据类型分别是`i32**`和`[1 x i32]**`。

因此，我们要先使用load取得`%8`和`%9`，类型分别为`i32*`和`[1 x i32]*`，再使用`getelementptr`拿到对应位置的元素。

```assembly
  %8 = load i32*, i32** %5, align 8
  %9 = getelementptr inbounds i32, i32* %8, i64 0
  store i32 1, i32* %9, align 4
  
  %10 = load [1 x i32]*, [1 x i32]** %6, align 8
  %11 = getelementptr inbounds [1 x i32], [1 x i32]* %10, i64 0
  %12 = getelementptr inbounds [1 x i32], [1 x i32]* %11, i64 0, i64 0
  store i32 2, i32* %12, align 4
```

在使用上，与之前的数组类似，分为以下几种情况：这里我们以`c`为例：

1. 当我们要取`c[0][0]`时：

```assembly
  %11 = load [1 x i32]*, [1 x i32]** %6, align 8
  %12 = getelementptr inbounds [1 x i32], [1 x i32]* %11, i64 0
  %13 = getelementptr inbounds [1 x i32], [1 x i32]* %12, i64 0, i64 0
  %14 = load i32, i32* %13, align 4
```

2. 当我们要取`c[0]`时：

```assembly
  %18 = load [1 x i32]*, [1 x i32]** %6, align 8
  %19 = getelementptr inbounds [1 x i32], [1 x i32]* %18, i64 0
  %20 = getelementptr inbounds [1 x i32], [1 x i32]* %19, i64 0, i64 0
```

可以看到，这两个命令对地址`@c`的getelementptr操作完全相同，只是`c[0][0]`多了一个取值的操作。

也就是说，在取址会故意多取一层，这与我们在处理函数形参时完全对应。

3. 同样的，直接取`b0`时：

```assembly
  %23 = load [1 x i32]*, [1 x i32]** %6, align 8
```

## 总结

这次的实验真的很难，而且时间也比较紧凑。

主要的难点主要是数组、尤其是参数数组的处理以及逻辑语句，包括短路求值的处理，建议一边写文档一遍梳理思路，再写代码。

