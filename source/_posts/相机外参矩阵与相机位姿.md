---
title: 相机外参矩阵与相机位姿
date: 2024-10-17 11:12:51
tags:
---
## 外参矩阵与相机位姿

外参矩阵又称**w2c(world to camera)矩阵**，作用是将世界坐标系的点变换到相机坐标系。由一个3×3的单位正交旋转矩阵R和3×1的平移矢量t组成。记相机坐标为$P_{c}$ ,世界坐标为$P_{w}$ ,则有：

$$
P_{c}=\left[\begin{array}{ll}
R & t
\end{array}\right]\left[\begin{array}{c}
P_{w} \\
1
\end{array}\right]
$$

其中：

$$
[R \mid \boldsymbol{t}]=\left[\begin{array}{ccc|c}
r_{1,1} & r_{1,2} & r_{1,3} & t_{1} \\
r_{2,1} & r_{2,2} & r_{2,3} & t_{2} \\
r_{3,1} & r_{3,2} & r_{3,3} & t_{3}
\end{array}\right]
$$

通常在矩阵的底部加一行(0,0,0,1)。这样就变成了方阵，这样我们就可以将矩阵进一步分解为旋转和平移，并且可以支持齐次运算：

$$
\begin{aligned}
{\left[\begin{array}{c|c}
\mathrm{R} & \boldsymbol{t} \\
\hline \mathbf{0} & \mathbf{1}
\end{array}\right] } & =\left[\begin{array}{l|l}
\mathbf{1} & \boldsymbol{t} \\
\hline \mathbf{0} & \mathbf{1}
\end{array}\right] \times\left[\begin{array}{c|c}
\mathrm{R} & \mathbf{0} \\
\hline \mathbf{0} & \mathbf{1}
\end{array}\right] \\
& =\left[\begin{array}{ccc|c}
1 & 0 & 0 & \mathrm{t}_{1} \\
0 & 1 & 0 & \mathrm{t}_{2} \\
0 & 0 & 1 & \mathrm{t}_{3} \\
\hline 0 & 0 & 0 & 1
\end{array}\right] \times\left[\begin{array}{ccc|c}
r_{1,1} & r_{1,2} & r_{1,3} & 0 \\
r_{2,1} & r_{2,2} & r_{2,3} & 0 \\
r_{3,1} & r_{3,2} & r_{3,3} & 0 \\
\hline 0 & 0 & 0 & 1
\end{array}\right]
\end{aligned}
$$

相机外参矩阵的逆矩阵被称为**camera-to-world(c2w)矩阵，也称为相机位姿**，其作用是把相机坐标系的点变换到世界坐标系。c2w矩阵也可以写成旋转矩阵和平移矢量的组合，记c2w的旋转矩阵为$R_C$ ，平移矢量为$C$。则：

$$
P_{w}=\left[\begin{array}{ll}
R_c & C
\end{array}\right]\left[\begin{array}{c}
P_{c} \\
1
\end{array}\right]
$$

**c2w矩阵的值直接描述了相机坐标系的朝向和原点**，因此称为相机位姿。具体的，旋转矩阵的第一列到第三列分别表示了相机坐标系的X, Y, Z轴在世界坐标系下对应的方向；平移向量表示的是相机原点在世界坐标系的对应位置。

![img](https://pic4.zhimg.com/80/v2-36c5b487873fe31427ad559f8c43f957_1440w.webp)

尝试进行下列计算帮助自己理解。刚刚讲到c2w是将相机坐标系的向量变换到世界坐标系下，那我们如果将c2w作用到(即左乘)相机坐标系下的X轴[1,0,0,0]，Y轴[0,1,0,0], Z轴[0,0,1,0]，以及原点[0,0,0,1]（注意方向向量的齐次坐标第四维等于0，点坐标第四维等于1），我们会得到它们在世界坐标系的坐标表示：

```text
[R, T][1, 0, 0, 0]^T = [r11, r21, r31]^T # X轴对应的是c2w矩阵的第一列
[R, T][0, 1, 0, 0]^T = [r12, r22, r32]^T # Y轴对应的是c2w矩阵的第二列
[R, T][0, 0, 1, 0]^T = [r13, r23, r33]^T # Z轴对应的是c2w矩阵的第三列
[R, T][0, 0, 0, 1]^T = [t1, t2, t3]^T    # 原点对应的是c2w矩阵的第四列
```

## c2w和w2c的转换

两者关系为互为逆矩阵：

$$
\begin{array}{l}
\begin{aligned}
{\left[\begin{array}{c|c}
\mathrm{R} & \boldsymbol{t} \\
\hline \mathbf{0} & 1
\end{array}\right] } & =\left[\begin{array}{c|c}
\mathrm{R}_{\mathrm{c}} & \mathrm{C} \\
\hline \mathbf{0} & 1
\end{array}\right]^{-1} \\
& =\left[\left[\begin{array}{c|c}
\mathrm{I} & \mathrm{C} \\
\hline \mathbf{0} & 1
\end{array}\right]\left[\begin{array}{c|c}
\mathrm{R}_{\mathrm{c}} & 0 \\
\hline \mathbf{0} & 1
\end{array}\right]\right]^{-1} \\
& =\left[\begin{array}{c|c}
\mathrm{R}_{\mathrm{c}} & 0 \\
\hline \mathbf{0} & 1
\end{array}\right]^{-1}\left[\begin{array}{c|c}
\mathrm{I} & \mathrm{C} \\
\hline \mathbf{0} & 1
\end{array}\right]^{-1} \\
& =\left[\begin{array}{c|c}
\mathrm{R}_{c}^{\top} & 0 \\
\hline \mathbf{0} & 1
\end{array}\right]\left[\begin{array}{c|c}
1 & -\mathrm{C} \\
\hline \mathbf{0} & 1
\end{array}\right] \\
& =\left[\begin{array}{c|c}
\mathrm{R}_{c}^{\top} & -\mathrm{R}_{c}^{\top} \mathrm{C} \\
\hline \mathbf{0} & 1
\end{array}\right]
\end{aligned}
\end{array}
$$

如果要将w2c转c2w，只需将上面的过程反过来就可以了。

因此得到：

$$
\begin{array}{l}
\mathrm{R}=\mathrm{R}_{\mathrm{C}}^{\top} \\
t=-\mathrm{RC}
\end{array}
$$

## 移动相机

在ViewCrafter这项工作中，我们需要移动摄像机绕着中心点旋转，来获取一个连贯的视图。

![fig](https://github.com/Drexubery/ViewCrafter/raw/main/assets/doc_world.png)

首先我们要确认中心点$P_o$，图中中心点即为世界坐标系原点，因此不需要进行转化，但是如相机绕的中心点并非原点，则步骤如下：

1. 首先，我们需要将相机移至中心点；
2. 使用旋转矩阵对相机角度进行调整；
3. 最后将相机平移回原来的坐标系。

代码化如下：

```python
def sphere2pose(center_pos, c2ws_input, theta, phi, r, device):
    c2ws = copy.deepcopy(c2ws_input)
  
    center_pos = torch.tensor(center_pos).to(device)
    c2ws[:, :3, 3] -= center_pos
    c2ws[:,2,3] += r

    theta = torch.deg2rad(torch.tensor(theta)).to(device)
    sin_value_x = torch.sin(theta)
    cos_value_x = torch.cos(theta)
    rot_mat_x = torch.tensor([[1, 0, 0, 0],
                    [0, cos_value_x, -sin_value_x, 0],
                    [0, sin_value_x, cos_value_x, 0],
                    [0, 0, 0, 1]]).unsqueeze(0).repeat(c2ws.shape[0],1,1).to(device)
  
    phi = torch.deg2rad(torch.tensor(phi)).to(device)
    sin_value_y = torch.sin(phi)
    cos_value_y = torch.cos(phi)
    rot_mat_y = torch.tensor([[cos_value_y, 0, sin_value_y, 0],
                    [0, 1, 0, 0],
                    [-sin_value_y, 0, cos_value_y, 0],
                    [0, 0, 0, 1]]).unsqueeze(0).repeat(c2ws.shape[0],1,1).to(device)

    c2ws = torch.matmul(rot_mat_x,c2ws)
    c2ws = torch.matmul(rot_mat_y,c2ws)
    c2ws[:, :3, 3] += center_pos
    return c2ws 
```
