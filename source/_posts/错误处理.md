---
title: 错误处理和符号表
date: 2023-10-09 15:15:42
excerpt: 从零开始的编译器之错误处理
categories: [技术, 编译技术]
tags: [错误处理]
topic: compiler
---

# 错误处理和符号表

## 前言

之前的部分一直都没管错误处理和符号表，其实这也是不太对的，因为这两个部分会贯穿我们编译的全过程。

![image-20231010104043778](https://zzq-typora-picgo.oss-cn-beijing.aliyuncs.com/Image/image-20231010104043778.png)

本次实验的目的就是去补充错误处理和符号表这两个之前未曾完善的部分。

## 错误处理

| 错误类型                             | 错误类别码 | 解释                                                         | 对应文法及出错符号 ( … 表示省略该条规则后续部分)             |
| ------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 非法符号                             | a          | 格式字符串中出现非法字符报错行号为 **<FormatString>** 所在行数。 | <FormatString> → ‘“‘{<Char>}’”                               |
| 名字重定义                           | b          | 函数名或者变量名在**当前作用域**下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 **<Ident>** 所在行数。 | <ConstDef>→<Ident> … <VarDef>→<Ident> … <Ident> … <FuncDef>→<FuncType><Ident> … <FuncFParam> → <BType> <Ident> … |
| 未定义的名字                         | c          | 使用了未定义的标识符报错行号为 **<Ident>** 所在行数。        | <LVal>→<Ident> … <UnaryExp>→<Ident> …                        |
| 函数参数个数不匹配                   | d          | 函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的**函数名**所在行数。 | <UnaryExp>→<Ident>‘(’[<FuncRParams>]‘)’                      |
| 函数参数类型不匹配                   | e          | 函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的**函数名**所在行数。 | <UnaryExp>→<Ident>‘(’[<FuncRParams>]‘)’                      |
| 无返回值的函数存在不匹配的return语句 | f          | 报错行号为 **‘return’** 所在行号。                           | <Stmt>→‘return’ {‘[’<Exp>’]’}‘;’                             |
| 有返回值的函数缺少return语句         | g          | 只需要考虑函数末尾是否存在return语句，**无需考虑数据流**。报错行号为函数**结尾的’}’** 所在行号。 | <FuncDef> → <FuncType> <Ident> ‘(’ [<FuncFParams>] ‘)’ <Block> <MainFuncDef> → ‘int’ ‘main’ ‘(’ ‘)’ <Block> |
| 不能改变常量的值                     | h          | <LVal>为常量时，不能对其修改。报错行号为 **<LVal>** 所在行号。 | <Stmt>→<LVal>‘=’ <Exp>‘;’ <Stmt>→<LVal>‘=’ ‘getint’ ‘(’ ‘)’ ‘;’ |
| 缺少分号                             | i          | 报错行号为分号**前一个非终结符**所在行号。                   | <Stmt>,<ConstDecl>及<VarDecl>中的’;’                         |
| 缺少右小括号’)’                      | j          | 报错行号为右小括号**前一个非终结符**所在行号。               | 函数调用(<UnaryExp>)、函数定义(<FuncDef>)及<Stmt>中的’)’     |
| 缺少右中括号’]’                      | k          | 报错行号为右中括号**前一个非终结符**所在行号。               | 数组定义(<ConstDef>,<VarDef>,<FuncFParam>)和使用(<LVal>)中的’]’ |
| printf中格式字符与表达式个数不匹配   | l          | 报错行号为 **‘printf’** 所在行号。                           | <Stmt> →‘printf’‘(’<FormatString>{,<Exp>}’)’‘;’              |
| 在非循环块中使用break和continue语句  | m          | 报错行号为 **‘break’** 与 **’continue’** 所在行号。          | <Stmt>→‘break’‘;’ <Stmt>→‘continue’‘;’                       |

### 错误的分类

根据以上的错误规则，我们可以将错误分为三类：

1. 在词法分析阶段可以检查的错误：a
2. 在语法分析阶段可以检查的错误：i、j、k
3. 需要借助符号表进行检查的错误：其他错误

其中第一类和第三类错误我们可以在语义分析中一边建立符号表，一边进行检测；而第二类错误我们必须要在语法分析阶段就识别并局部化，否则会影响到后续的工作。

### 错误的局部化

在正确构建语法树的前提下，第一类和第三类错误的局部化是自动的。唯有第二类错误可能严重破坏语法树的构建，导致程序RE或者构建出完全错误的语法树，所以我们这里需要着重分析一下**第二类错误**。

在之前的代码中，我有不少地方的判断都是依赖于`;])`这三个符号，如果这三个符号发生缺失，程序有时会RE，有时会导致语法树完全畸形。

此外，如果缺少这三个符号，语法树会不完整，导致在错误处理时取对应位置的结点时会取到错误的结点。

这里我采取的措施是：

1. 在语法分析时，遇到要处理回溯的问题时，**不要使用**`;])`这三个符号做判断。（尽管这样会变得更简单）
1. 如果发现了这三个符号缺失，添加错误后在语法树中**手动补充这个缺失**。（因为这三个符号的有无并不影响实际的分析，补充后后期工作会变得更加简洁）

### 函数内部的错误检查

虽然说正统的栈式符号表中，函数被调用时才开始建符号表。但是在我们的SysY语言中，在函数的定义处直接建表检查也是可以的，甚至会简化一些流程，因此这里我就偷懒直接检查了。

## 总体设计

因为此处的错误处理需要处理的错误较少，仅需要粗粒度的判断即可。如果在之前递归下降子程序的类中进行设计，不仅工作量巨大，并且由于并不知道遍历抽象语法树时的最终要求，在之后生成中间代码的步骤中还可能面临多处重构的风险，故我单独将这部分抽出来，单独遍历一遍来找错误，以减少编码量和重构风险。

注意，这样的设计在总体来看不是最优的，而且会导致结构性地对错误的遗漏和性能的下降（Maybe），但是从完成任务的角度，我认为这样的设计是蛮不错的。

具体来说，我建立了两个类：

`SysYException`和`ExceptionHandler`，显然地，`SysYException`是错误类，而对语法树遍历找错误、错误的添加和输出等任务主要在`ExceptionHandler`类中完成。

此外，错误处理的分析需要先建立符号表，所以我还在`frontend`中添加了一个`symbolTable`包，包括`SymbolTable`,`Symbol`,`VarSymbol`和`FuncSymbol`四个类。

`SymbolTable`是符号表类，用于存储符号表。

`Symbol`是符号基类，`VarSymbol`和`FuncSymbol`都继承于它，分别为变量符号和函数符号。

此时的文件树为：

```
-MyCompiler
	- exception
    - SysException.java
    - ExceptionHandler.java
  - frontend
    - tree
    	- BasicNode.java
    	... //其他节点类
    - symbolTable
    	- Symbol
    	- SymbolTable
    	- VarSymbol
    	- FuncSymbol
    - Unit.java
    - Factory.java
    - Tokens.java
    - Tokenizer.java
    - Scanner.java
  - backend
  - Compiler.java
```

### SymbolTable

```java
public class SymbolTable {
    private final Map<String, Symbol> symbolMap = new HashMap<>(); //符号表主体
    private final SymbolTable parent; //指向父节点
    private final boolean inLoop;	//是否在循环中

  	//指定符号表是否在循环中
    public SymbolTable(SymbolTable parent, boolean inLoop) {}

  	//继承父符号表的循环情况
    public SymbolTable(SymbolTable parent) {...}

    public Symbol findSymbol(String name){...}

    public boolean isInLoop(){...}

    public Symbol findSymbolInAll(String name){...}

    public void addSymbol(Symbol symbol){...}

}
```

### Symbol

```java
public abstract class Symbol {

    public final String name;
  
    public Symbol(String name) {
        this.name = name;
    }
}
//变量类符号
public class VarSymbol extends Symbol {

    public final int dimension;
    public final boolean isConst;

    public VarSymbol(String name, int dimension, boolean isConst) {...}
}
//函数类符号
public class FuncSymbol extends Symbol{

    public final returnType retType;

    public final List<FuncFParam> params;
    public final Block block;

    public FuncSymbol(String name, returnType retType, List<FuncFParam> params, Block block) {...}

    public enum returnType{
        INT,
        VOID;
    }

}
```

### ExceptionHandler

```java
public class ExceptionHandler {
    private final BufferedWriter bufferedWriter;
    private final List<SysYException> errors = new ArrayList<>(); //存放所有的错误
    private final SymbolTable rootTable = new SymbolTable(null, false); //全局符号表

    public ExceptionHandler(BufferedWriter bufferedWriter) {...}
		//添加错误
    public void addError(SysYException e) {...}
		//获得错误数
    public int size() {...}
		//打印全部错误，便与调试
    public void printErrors() throws IOException {...}
  	//遍历抽象语法树分析错误
    public void analyseError(CompUnit compUnit) {
        for (int i = 0; i < compUnit.derivations.size(); i++) {
            Unit unit = compUnit.derivations.get(i);
            if (unit instanceof ConstDecl) {
                analyseConstDecl(rootTable, (ConstDecl) unit);
            } else if (unit instanceof VarDecl) {
                analyseVarDecl(rootTable, (VarDecl) unit);
            } else if (unit instanceof FuncDef) {
                analyseFuncDef(rootTable, (FuncDef) unit);
            } else if (unit instanceof MainFuncDef) {
                analyseMainFuncDef(rootTable, (MainFuncDef) unit);
            }
        }
    }
  	//更多的analyse函数，递归遍历抽象语法树
  	...
    //一些重要的工具函数，用于简化代码
    ...
}
```

### SysYException

```java
public class SysYException extends Exception implements Comparable<SysYException>{
    public ExceptionKind kind;
    public int line;

    public SysYException(ExceptionKind kind, int line) {
        this.kind = kind;
        this.line = line;
    }

    @Override
    public String toString(){
        return line+" "+kind.code;
    }

    @Override
    public int compareTo(SysYException o) {
        return Integer.compare(this.line, o.line);
    }


    public enum ExceptionKind {
        ILLEGAL_SYMBOL("a", "格式字符串中出现非法字符"),
				...
        ERROR("unexpected error", "未知错误");
        public final String code;
        public final String description;

        ExceptionKind(String s, String description) {
            this.code = s;
            this.description = description;
        }
    }
}

```

## 总结

这次实验比语法分析感觉有又困难了一些，而且想通过测试的调试难度也明显增加，太可怕了。。。

这更突出一开始构思好架构，增加代码的完善性和稳健性的重要性。
