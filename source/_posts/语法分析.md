---
title: 语法分析
date: 2023-09-30 23:10:09
excerpt: 从零开始的编译器之语法分析
tags: [编译技术,词法分析]
categories: [技术,编译技术]
topic: compiler
---

# 语法分析

## 前言

在上一次实验中，我们完成了词法分析，并在Scanner中保存了Token表，这是极好的。

今天的任务是再次遍历所有token，形成对应的语法树。我使用的分析方法是递归下降子程序法，而需要注意的问题是程序中存在的左递归和回溯。

## 分析语法

要构造对应的语法树，我们首先必须充分了解想要分析的语法规则。

实验中的语法规则如下表所示：

| 名称         | 符号         | 推导结果                                                     | 备注                    |
| ------------ | ------------ | ------------------------------------------------------------ | ----------------------- |
| 编译单元     | CompUnit     | {Decl} {FuncDef} MainFuncDef                                 |                         |
| 声明         | Decl         | ConstDecl<br />VarDecl                                       |                         |
| 常量声明     | ConstDecl    | 'const' BType ConstDef { ',' ConstDef } ';'                  |                         |
| 基本类型     | BType        | 'int'                                                        |                         |
| 常数定义     | ConstDef     | Ident { '[' ConstExp ']' } '=' ConstInitVal                  |                         |
| 常量初值     | ConstInitVal | ConstExp<br />'{' [ ConstInitVal { ',' ConstInitVal } ] '}'  |                         |
| 变量声明     | VarDecl      | BType VarDef { ',' VarDef } ';'<br />Ident { '[' ConstExp ']' } '=' InitVal |                         |
| 变量初值     | InitVal      | Exp<br />'{' [ InitVal { ',' InitVal } ] '}'                 |                         |
| 函数定义     | FuncDef      | FuncType Ident '(' [FuncFParams] ')' Block                   |                         |
| 主函数定义   | MainFuncDef  | 'int' 'main' '(' ')' Block                                   |                         |
| 函数类型     | FuncType     | 'void' <br />'int'                                           |                         |
| 函数形参表   | FuncFParams  | FuncFParam { ',' FuncFParam }                                |                         |
| 函数形参     | FuncFParam   | BType Ident ['[' ']' { '[' ConstExp ']' }]                   |                         |
| 语句块       | Block        | '{' { BlockItem } '}'                                        |                         |
| 语句块项     | BlockItem    | Decl <br />Stmt                                              |                         |
| 语句         | Stmt         | LVal '=' Exp ';' <br />[Exp]  ';'<br />Block<br />'if' '(' Cond ')' Stmt [ 'else' Stmt ]<br />'for' '(' [ForStmt] ';' [Cond] ';' [forStmt] ')' Stmt<br />'break' ';'<br />'continue' ';'<br />'return' [Exp] ';'<br />LVal '=' 'getint''('')'';'<br />'printf''('FormatString{','Exp}')'';' | 左递归                  |
| 语句         | ForStmt      | LVal '=' Exp                                                 |                         |
| 表达式       | Exp          | AddExp                                                       |                         |
| 条件表达式   | Cond         | LOrExp                                                       |                         |
| 左值表达式   | LVal         | Ident {'[' Exp ']'}                                          |                         |
| 基本表达式   | PrimaryExp   | '(' Exp ')'<br />LVal<br />Number                            |                         |
| 数值         | Number       | IntConst                                                     |                         |
| 一元表达式   | UnaryExp     | PrimaryExp<br />Ident '(' [FuncRParams] ')'<br />UnaryOp UnaryExp |                         |
| 单目运算符   | UnaryOp      | '+'  <br />'-'<br />'!'                                      | '!'仅出现在条件表达式中 |
| 函数实参表   | FuncRParams  | Exp { ',' Exp }                                              |                         |
| 乘除模表达式 | MulExp       | UnaryExp<br /> ('*' \| '/'  \| '%' ) UnaryExp                | 左递归                  |
| 加减表达式   | AddExp       | MulExp<br />AddExp ('+' \| '−') MulExp                       | 左递归                  |
| 关系表达式   | RelExp       | AddExp<br />RelExp ('<' \| '>'  \| '<=' \| '>=') AddExp      | 左递归                  |
| 相等性表达式 | EqExp        | RelExp<br />EqExp ('==' \| '!=') RelExp                      | 左递归                  |
| 逻辑与表达式 | LAndExp      | EqExp<br />LAndExp '&&' EqExp                                | 左递归                  |
| 逻辑或表达式 | LOrExp       | LAndExp <br />LOrExp '\|\|' LAndExp                          | 左递归                  |
| 常量表达式   | ConstExp     | AddExp                                                       | 使用的Ident 必须是常量  |

### 左递归问题

其中我们可以看到表达式的部分出现了很多左递归，这里我们使用改写BNF范式的做法。改写后如下所示：

| 名称         | 符号    | 推导结果                                      |
| ------------ | ------- | --------------------------------------------- |
| 乘除模表达式 | MulExp  | UnaryExp { ('*' \|  '/' \| '%' ) UnaryExp}    |
| 加减表达式   | AddExp  | MulExp { ('+' \| '-') MulExp}                 |
| 关系表达式   | RelExp  | AddExp { ('<' \| '>' \| '<=' \| '>=') AddExp} |
| 相等性表达式 | EqExp   | RelExp { ('==' \| '!=') RelExp}               |
| 逻辑与表达式 | LAndExp | EqExp { '&&' EqExp}                           |
| 关系表达式   | LOrExp  | LAndExp { '\|\|' LAndExp}                     |

需要注意的是，这样做可能会导致语法树的结构较原来发生变化。输出时必须以原语法树为准!!

> **以AddExp为例，按照`MulExp { ('+' \| '-') MulExp}`这样的产生式进行分析，右边的{ ('+' | '-') MulExp}重复几次，实际上就需要嵌套地生成几个AddExp。因此，我们必须在程序中格外注意这一点。**

### 回溯问题

在多产生式的情况下，一个问题是回溯问题。我们可以通过求产生式FIRST集来预测和解决回溯问题，举个例子：

| 名称       | 符号       | 产生式FIRST集                                                | 备注 |
| ---------- | ---------- | ------------------------------------------------------------ | ---- |
| 编译单元   | CompUnit   | Decl: {"const", "int"} FuncDef:{"void", "int"} MainFuncDef:{"int"} | 回溯 |
| 一元表达式 | UnaryExp   | PrimaryExp:{"(", Ident, "0",...,"9"}    {Ident}   UnaryOp:{"+","-","!"} | 回溯 |
| 基本表达式 | PrimaryExp | {'('}  LVal:{Ident} Number:{IntConst}                        | 回溯 |
| 语句块项   | BlockItem  | Decl: {"const", "int"}  Stmt{}                               | 回溯 |
| 语句       | Stmt       | 略                                                           | 回溯 |

这种情况下，应该使用再继续向前看，直到出现不一致时，方可区分到底是哪个产生式。

另一种方法是通过改写产生式来解决这个问题，但是这样做的问题是会破坏原来的产生式，导致想把输出调成原来的样子还要做一些额外的设计。考虑到我们并不追求性能，那就还是使用粗暴一些的方式来减少编码的难度吧！

这里值得特别说说的是Stmt，因为它的产生式实在是太复杂！

这里我们单拉出来分析分析：

Stmt

- Block
- 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
- 'for' '(' [ForStmt] ';' [Cond] ';' [forStmt] ')' Stmt
- 'break' ';' | 'continue' ';'
- 'return' [Exp] ';'
- 'printf''('FormatString{','Exp}')'';'
- LVal '=' Exp ';'
- [Exp] ';'
- LVal '=' 'getint''('')'';'

在LVal之前的都还比较简单，但是最后三条确实非常难以区分，这里给出我的思路：

1. 如果当前的token为';'，那么产生式一定为 ';'
2. 因为Exp可以推导出LVal，因此想直接区分两者会非常困难。但是，考虑到LVal后一定会接'='，而Exp后一定会接';'，因此可以考虑先把第一个语法成分放着，转而去判断后面的token，从而区分Exp和Val。
3. 怎么才能“把第一个语法成分放着”，毕竟我们也不知道Exp和LVal的长度？一种思路是使用Exp去直接分析，由于LVal可以通过Exp推出，因此两种可能性都不会报错。当确定类型后，我们再改回正确的类型即可。

## 总体结构

**调整**

1. 在上次的基础上调整了`exception`包的位置，感觉应该不止前端会出现异常，所以放在外面了。
2. `Factory`类现在保存了`Parser`类的单例。

**新增**

1. `Unit`接口。Unit是语法分析的基本单位，无论是终结符还是非终结符都实现了`Unit`接口。
2. `Pareser`类。这个类是语法分析的主要执行者，使用了递归下降子程序的方法来进行语法分析。
3. `tree`包。包内有语法成分的基本类`BasicNode`，实现了`Unit`；以及所有的语法树的节点类，所有的语法节点都继承`BasicNode`。

目前的文件结构为：

```
-MyCompiler
	- exception
    -SysException.java
  - frontend
    - tree
    	- BasicNode.java
    	... //其他节点类
    - Unit.java
    - Factory.java
    - Tokens.java
    - Tokenizer.java
    - Scanner.java
  - backend
  - Compiler.java
```

### Parser

`Pareser`类是语法分析的主要执行者，使用了递归下降子程序的方法来进行语法分析。

```java
public class Parser {
    private final Scanner scanner;
    private final ExceptionHandler exceptionHandler;
    public CompUnit compUnit;
    private final BufferedWriter bufferedWriter;

    public Parser(Scanner scanner, ExceptionHandler exceptionHandler, BufferedWriter bw) {...}

  	//在判断后将token插入语法树
    private void putAfterAssert(ArrayList<Unit> nodes, Tokens.Token token, Tokens.TokenKind kind) throws SysYException {...}

  	//语法分析主函数
    public void syntaxAnalyse(boolean print) throws SysYException, IOException {
      ...
    	//调用parseCompUnit(),开始递归子程序分析
    }

    private CompUnit parseCompUnit() throws SysYException {...}
  
  	//其他子程序定义
  	...
      
    //一些简化代码的工具函数
    ...
}
```

### BasicNode

`BasicNode`是所有语法树节点的父类，规定了所有节点的共有属性和方法。

SysY文法中每一个非终结符都对应了一个语法树节点类。

```java
public class BasicNode implements Unit {
    public final String name;	//该节点的名字
    public final List<Unit> derivations; //保存下每个结点的子结点

    public BasicNode(String name, List<Unit> units) {
        this.name = name;
        this.derivations = new ArrayList<>(units);
    }
    
  	//一次性输出整棵树
    @Override
    public String toString() {
        return derivations.stream()
                .map(Unit::toString)
                .reduce((s1, s2) -> s1 + "\n" + s2).orElse("") + "\n<" + name + ">";
    }

}

//CompUnit示例
public class CompUnit extends BasicNode{
    public CompUnit(List<Unit> units) {
        super("CompUnit", units);
    }

}
```

## 总结

这次实验开始上强度了，完整地构造语法树确实要花不少功夫。一个比较突出的感悟是比较合理的类的设计和工具方法的实现确实能够很大程度上让开发变得更加简单和丝滑。
