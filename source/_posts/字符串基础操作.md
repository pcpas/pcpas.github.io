---
title: 字符串基础操作
excerpt: 字符串！非常容易debug到崩溃嘻嘻
date: 2022-05-07 20:08:38
categories: [技术, 数据结构]
tags: [字符串操作, 后缀表达式, 高精度计算]
---
# 关于

笔者一直认为，字符串应该是每个刚入门代码的人心里最大的噩梦。不论是一堆莫名其妙的报错，永远都猜不对的+1还是不+1，还是那几个有无数潜规则的字符串函数，没调过大半天都不好意思说掌握了字符串。

但是！字符串是入门还是很有道理的，因为真的很简单！只要心里逻辑清晰一点！就没问题！

全文都以C语言为示例，高级语言字符串操作越来越简单。

下面是笔者总结的一些易错、易混的概念和操作！

# 正文

## 字符串的初始化

下面能正确进行字符串赋值，并且能确保字符串以’\0’结尾的操作是[ ] 【 正确答案: c】
(A)  char s[5] = {"ABCDE"};
(B)  char s[5] = {’A’, ’B’, ’C’, ’D’, ’E’};
(C)  char *s; s = "ABCDE";
(D)  char *s; scanf("%s", s);

{% blockquote %}

解释：A、B 爆数组了 ，但是两种初始化方法都是OK的

D、**操作野指针**

答应我，记得初始化指针！

{% endblockquote %}

## 将字符串s中所有的字符“c”删除

比较Tricky的小函数吧，好用的

```cpp
//下面程序的功能是将字符串s中所有的字符“c”删除。
char* delete(char *s)
{
int i,j;
for(i=j=0;s[i];i++)
{
if(s[i]!='c') s[j++] = s[i];
}
s[j] = '\0';
return s;
}
```

## 关于如何理解形参中的指针

```cpp
//判断以下程序是否正确-----不正确!
#include <stdio.h>
void func(char *q)
{
   	//此处的q为形参q!影响不了实参q!深刻理解传指针和传值的区别!
	char a[]="hello";
        q=a;
}
main()  
{
           char *p;
           func(p);
           printf("%s\n",p);
} 
```

{% blockquote %}

这里需要大家真的理解指针和数组名的含义才能辨析。

但其实也不难吧，就是很有迷惑性~

{% endblockquote %}

## 手写strcat（闹着玩的）

```
//函数index(char s[],char t[])检查字符串s中是否包含字符串t，若包含，则返回t在s中的开始位置(下标值)，否则返回-1。
//C 库函数 char *strstr(const char *haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 '\0',若不包含,返回null.

int index(char s[],char t[])
{
 int i,j,k;
 for(i=0;s[i]!='\0';i++)
 {
  for(j=i,k=0; s[j]!='\0'&&s[j]==t[k];j++,k++)
   ;
  if(t[k] == '\0')
   return i;
 }
 return -1;
}
```

{% blockquote %}

同样没什么好说的，理解不了可以放弃了

进阶： KMP查找（不过想说一句，在考试的时候用就是 “可以但有病”）

{% endblockquote %}

## invert函数

```
void invert (char str [] )
{
 int i,j,k;
 for(i=0,j=strlen(str)-1;i<j;i++,j--)
 {
  k=str[i];
  str[i]=str[j];
  str[j]=k;
 }
}
```

{% blockquote %}

Easier than easier

{% endblockquote %}

## 算术运算表达式(支持空格、连乘连除)

这道题就还是比较有难度了，下面我们来拆分一下本题的需求！

### 1. 处理数据的范围

支持浮点数吗？支持超大数吗？数组该开多大？该用int、long还是double？

浮点数： atoi函数面临失效风险，需要手写转换函数

高精计算： 这都值得单独开一篇来说了！

总之！做一道题，特别是这些脑筋急转弯题！非常需要考虑这个问题！

### 2.处理表达式

给你一个充满空格的表达式，你打算如何读入？又该如何储存？

我认为好的做法应该是getchar读入，顺便消去空格，以=为结尾

根据本学期所学的内容，将表达式无脑先转为后缀表达式存起来应该是聪明的做法！（因为有板子呀嘿嘿）

### 3.中缀转后缀并计算

中缀转后缀应该是一个树的问题？idk，但是至少对于表达式而言，我们采用这样的方法：

{% blockquote %} 

1. 从左至右进行遍历。
2. 遇到运算数直接输出。
3. 遇到左括号（作为最高优先级符号）直接入栈。
4. 遇到右括号，弹出一切符号直到遇到左括号，然后把这对括号弹出但是不存。
5. 遇到普通运算符，不断将其与栈顶元素比较，若高于栈顶则入栈，否则弹出当前栈顶，继续比较，直到高于栈顶或者栈空，入栈。
6. 对象处理完毕，全部出栈。

{% endblockquote %}

下面是一个示例（我自己的板子）：

```cpp

//不支持高精度和浮点数！
#include<stdio.h>
#include<stdlib.h>
//获取中缀表达式
void getExpresion(char* s)
{
    char c;
    int i = 0;
    while((c = getchar())!= '=')
    {
        if(c!=' ')
        {
            s[i++] = c;
        }
    }
    s[i] = '\0';
}
//进行转换
void trans(char *s, char *t) 
{
    //规定符号优先级
    int prior[300] = {0};
    prior['+'] = 1, prior['-'] = 1, prior['*'] = 2, prior['/'] = 2;
    //处理开始
    int i = 0, j = 0;
    char stack[100000] = {'\0'};
    int top = -1;
    while(s[i])
    {
        if(s[i]>='0'&&s[i]<='9') //如果是数字，直接输出
        {
            while(s[i]>='0'&&s[i]<='9')
            {
                t[j++] = s[i++];
            }
            t[j++] = ' ';
            i--;
        }else if(s[i]==')')//如果是右括号
        {
            while(stack[top]!='(')
            {
                t[j++] = stack[top--];
            }
            top--;
        }else//如果是运算符或(
        {
            while(top!=-1 && prior[stack[top]]>=prior[s[i]] && stack[top]!='(')
            {
                t[j++] = stack[top--];
            }
            stack[++top] = s[i];
        }
        i++;
    }
    while(top!=-1)
    {
        t[j++] = stack[top--];
    }
    t[j] = '\0';
}
//计算
int cal(char *t)
{
    int i = 0;
    int stack[10000];
    int top = -1;
    while(t[i])
    {
        int j = 0;
        char temp[100];
        if(t[i]>='0'&&t[i]<='9')
        {
            while(t[i]!=' ')
            {
                temp[j++] = t[i++];
            }
            temp[j] = '\0';
            int x = atoi(temp);
            stack[++top] = x;
        }else
        {
            if(t[i] == '+')
            {
                int x = stack[top--];
                int y = stack[top--];
                stack[++top] = y + x;
            }else if(t[i] == '-')
            {
                int x = stack[top--];
                int y = stack[top--];
                stack[++top] = y - x;
            }else if(t[i] == '*')
            {
                int x = stack[top--];
                int y = stack[top--];
                stack[++top] = y * x;
            }else
            {
                int x = stack[top--];
                int y = stack[top--];
                //printf("%d / %d\n", y, x);
                stack[++top] = y / x;
            }
        }
        i++;
    }
    return stack[top--];
}
int main()
{
    char s[100000];
    char t[100000];
    getExpresion(s);
    puts(s);
    trans(s, t);
    puts(t);
    int ans = cal(t);
    printf("%d", ans);
}
```

## 高精度计算

### 加法

### 减法
