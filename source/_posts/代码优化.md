---
title: 代码优化
date: 2023-11-26 13:48:34
excerpt: 从零开始的编译器之代码优化
categories: [技术, 编译技术]
tags: [代码优化, MIPS]
topic: compiler
---

# 代码优化

## 前言

写代码优化真的很难。尤其是如果在前期自作聪明地用一些“简便方法”完成了代码生成，而没有保存足够的信息，或者生成的结构有问题的话，可能会非常非常痛苦。一定要保持头脑足够清醒。

此外，另一个重要的事情是保证优化之间相互兼容。有些优化可能会破坏原有的结构和信息，导致接下来的优化无法叠加上去，这一点一定要考虑清楚。

下面简单介绍一下我做的优化。

## 中端优化

### 函数内联

将简单的叶函数直接内联到调用者的代码块中，减少栈保存的开销。

### 尾递归优化

尾递归是指递归函数中的递归调用发生在函数的最后一步。编译器可以将尾递归优化为迭代形式，从而避免递归调用造成的额外开销。针对迭代，也就是循环形式，则使用循环外提。

### 循环外提

对于循环中无需进行循环的代码进行外提，从而减少代码的重复执行次数。

### 常量传播

这个优化说实话比较简单，并且非常容易直接集成在代码生成时完成。基本思路为在代码生成时如果遇到可以计算的常量就直接算出来，而不是申请寄存器来存放常量计算的结果。此处不赘述。

值得注意的是常数数组的优化。不仅直接取其中元素时可以直接优化为常量，如果将常数数组作为参数传递给函数，函数中取其中的值也可以优化为常量。

### 死代码删除

死代码删除分为三步：

1. 删除掉不可达基本块、函数。
2. 构建定义使用链。
3. 根据定义使用链删除掉无用的死代码。

删除死代码需要遍历有用函数中的每条指令，并沿着def-use链构建有用指令的**闭包**。最基本的一些有用指令包括alloc指令、br指令，ret指令，调用函数的call指令。

寻找闭包的过程其实是一个递归：先将基本的有用指令进行标记，随后标记每条有用指令用到的value，并接着递归寻找其用到的value，从而构建一个有用指令的闭包。

然后将不在闭包内的所有指令全部删除即可。记得维护整体的数据结构的信息，因为之后还有别的优化要做。

### 消除公共表达式

我只做了基本块内的消除公共表达式。

消除公共表达式可以分为两步：

1. 构建基本块的DAG图
2. 根据DAG图导出指令

### 窥孔优化

我只做了比较简单的窥孔优化。

中端：

1. 删除条件恒为假的`br`指令。
2. 将条件恒为真的`br`指令去掉条件，这样在翻译为mips时就不会翻译成`bnz。`

## 后端优化

### 寄存器分配

设定`s0-5`（或者任何你喜欢的寄存器）为全局寄存器，其他可用寄存器为临时寄存器。

使用此前计算出的基本块的in和out集合构建冲突图，使用图着色算法为变量分配全局寄存器。

这里笔者只做到了基本块程度的冲突图，因此分配的精细度有欠缺，体现在竞速点里非常明显。因此建议还是做一下精确到每条指令的图着色，会对竞速的分数大有益处！

### 窥孔优化

1. 删除没用的J指令。
2. 优化for循环的基本块顺序以减少J指令。
3. 删除形如`addui $t1 $t1 0`或者`move $t0 $t0`的无用指令。
4. 合并冗余的指令。

###  乘除模优化

- 乘法优化为对操作数为常数的指令进行优化，方法是乘法转换为左移和加法操作
- 除法优化为将指令转化为乘法指令再进行乘法指令优化
- 取模运算转化为乘除指令再优化：$a \ % \ b = a -a/b$

#### 其他的小优化

还做了一些小优化，比如说MIPS叶子函数不需要保存ra；调用函数时只保存尽可能少的寄存器等，此处不一一列举。

## 总结

一开始在MIPS生成时写了一个简单的寄存器分配，没有引入全局寄存器，而是将全部的全局变量存入内存。我居然没有意识到这是不够的，反而觉得已经达到了最优，因此一直没有做最重要的图着色寄存器分配。后面意识到的时候已经来不及了，只能匆匆做一个简单版，效果很差。因此我认为优化一定要先做一些显然普适、有效的大优化，再慢慢由浅入深；此外先想好再动手也是很重要的一点。
