

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="TinyRendererWIki 6&amp;7">
<meta property="og:type" content="article">
<meta property="og:title" content="TinyRenderer 6&amp;7">
<meta property="og:url" content="http://example.com/2022/08/31/TinyRenderer-6-7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TinyRendererWIki 6&amp;7">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/08/31/88113a7c13ebb342.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/a51d60c7d28aa665.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/24d8531246467622.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/879521a02efd38ca.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/77e0fde064a19dc0.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/34a77862e0fac16d.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/5d0696b25eb6b6d6.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/03/2416957d30229da8.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/05/c075281389264e5c.png">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2022/09/05/74ca9782bd5a04b9.png">
<meta property="article:published_time" content="2022-08-31T08:16:16.000Z">
<meta property="article:modified_time" content="2022-09-06T10:12:50.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="图形学">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="TinyRenderer">
<meta property="article:tag" content="软件光栅化渲染器">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2022/08/31/88113a7c13ebb342.png">
  
  
  
  <title>TinyRenderer 6&amp;7 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="TinyRenderer 6&amp;7"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-31 16:16" pubdate>
          2022年8月31日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          45 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">TinyRenderer 6&amp;7</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Lesson-6-Shaders-for-the-software-renderer"><a href="#Lesson-6-Shaders-for-the-software-renderer" class="headerlink" title="Lesson 6: Shaders for the software renderer"></a>Lesson 6: Shaders for the software renderer</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>L6很重要。不仅是因为我们结束了数学部分进入了渲染，也是因为在此处我们对代码进行了分析和重构。</p>
<h2 id="Refactoring-the-source-code"><a href="#Refactoring-the-source-code" class="headerlink" title="Refactoring the source code"></a>Refactoring the source code</h2><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>作者在这里对代码进行了一个分析和总结，并表示：代码写的<strong>太多太乱</strong>了！</p>
<p>很巧，笔者也是这么觉得的，甚至，笔者的代码量接近原作者的两倍！！！！！好伤心！！！！</p>
<p>既然如此，就跟着作者的指引来重构一下自己小小渲染器的内容吧~我们应该只把有关渲染的一些<strong>可调整</strong>的参数和某些特定、需要修改的任务放在主函数中，而那些只是提供一个接口的渲染、计算函数不需要进一步修改，就将其放在别的特定的文件内就可以了。</p>
<p>想要做到这一点，就必须深刻理解整个渲染的过程。所以，跟着笔者的脚步对整个渲染进行一个梳理吧！</p>
<h3 id="前置文件"><a href="#前置文件" class="headerlink" title="前置文件"></a>前置文件</h3><p>首先，想要完成渲染需要三个头文件的支持：</p>
<div class="code-wrapper"><pre><code class="hljs stylus">Geometry<span class="hljs-selector-class">.h</span>
<span class="hljs-comment">//这个头文件提供了一系列的数学计算函数，为向量和矩阵的计算提供了巨大的便利</span>
tgaimage<span class="hljs-selector-class">.h</span>
<span class="hljs-comment">//这个头文件允许我们读写tga图像</span>
model<span class="hljs-selector-class">.h</span>
<span class="hljs-comment">//这个头文件给了我们一个读取模型的途径</span></code></pre></div>

<p>这三个头文件不需要我们倾注太多心思，因为是基础性的，但是也可以花时间研究一下。特别是<code>model.h</code> ，因为只有深刻理解我们如何储存模型的数据，才能做到合理的取用这些数据，这也是前几节课的一个难点。</p>
<p>首先我们要理解一个需要被渲染的模型是怎么构成的：</p>
<ol>
<li><p>模型 —–&gt; 无数的三角形面 —–&gt; 每个面由三个顶点组成 ：顶点坐标</p>
</li>
<li><p>模型每个面（或点）的法线</p>
</li>
<li><p>模型需要贴图（纹理），无数个纹理坐标（与顶点坐标一一对应）</p>
</li>
<li><p>模型是三维的，贴图是二维的，因此才需要一一对应关系进行转换：对应表</p>
</li>
</ol>
<p>在一个模型文件中（.obj），包含以下信息：</p>
<p>（初始模型的坐标均在一个[-1,1]^3的立方体内）</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>所有顶点的坐标（在物体自身的坐标系中）
v -<span class="hljs-number">0.171097</span> <span class="hljs-number">0.299996</span> <span class="hljs-number">0.415616</span>
……
<span class="hljs-comment"># 1258 vertices</span>

<span class="hljs-regexp">//</span>所有顶点对应的点在纹理贴图上的坐标（数量不相等，why？）
vt  <span class="hljs-number">0.532</span> <span class="hljs-number">0.923</span> <span class="hljs-number">0.000</span>
……
<span class="hljs-comment"># 1339 texture vertices</span>

<span class="hljs-regexp">//</span>所有法线向量（看来是每个顶点的法线）
vn  <span class="hljs-number">0.001</span> <span class="hljs-number">0.482</span> -<span class="hljs-number">0.876</span>
<span class="hljs-comment"># 1258 vertex normals</span>

<span class="hljs-regexp">//</span>每个面的信息
f <span class="hljs-number">1201</span><span class="hljs-regexp">/1249/</span><span class="hljs-number">1201</span> <span class="hljs-number">1202</span><span class="hljs-regexp">/1248/</span><span class="hljs-number">1202</span> <span class="hljs-number">1200</span><span class="hljs-regexp">/1246/</span><span class="hljs-number">1200</span>
<span class="hljs-regexp">//</span>格式： f （顶点索引<span class="hljs-regexp">/uv点索引/</span>法线索引）* <span class="hljs-number">3</span> （表示组成这个face的<span class="hljs-number">3</span>个顶点）
<span class="hljs-comment"># 2492 faces</span></code></pre></div>

<p>通过读取这个文件，我们自然能得到模型的一切信息。</p>
<p>欧克，这三个头文件相当于为我们清除了一切阻碍，我们需要做的就是聚精会神的剖析渲染的过程！</p>
<h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>这个过程我们用文字夹杂着代码的形式来说，同时因为是重新整理，所以顺序上没有那么循循善诱。</p>
<p>首先，我们要设定整个场景的参数：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//设定一些宏</span>
<span class="hljs-type">const</span> TGAColor white = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);
<span class="hljs-type">const</span> TGAColor red = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>);
<span class="hljs-type">const</span> TGAColor green = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">//初始化模型</span>
Model *model = <span class="hljs-literal">NULL</span>;
<span class="hljs-comment">//设定画布大小</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> width = <span class="hljs-number">800</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> height = <span class="hljs-number">800</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> depth = <span class="hljs-number">255</span>;
<span class="hljs-comment">//设定光源、照相机、坐标系</span>
Vec3f light_dir = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>).<span class="hljs-built_in">normalize</span>();
<span class="hljs-function">Vec3f <span class="hljs-title">camera</span><span class="hljs-params">(<span class="hljs-number">1.f</span>, <span class="hljs-number">1.f</span>, <span class="hljs-number">3.f</span>)</span></span>;
<span class="hljs-function">Vec3f <span class="hljs-title">center</span><span class="hljs-params">(<span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>)</span></span>;
<span class="hljs-function">Vec3f <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-number">0.f</span>, <span class="hljs-number">1.f</span>, <span class="hljs-number">0.f</span>)</span></span>;</code></pre></div>

<div class="note note-primary">
            <p>我想先强调一个渲染的最基本的概念：你所做的一切，都是为了得到屏幕上每个像素点的颜色。</p><p>我们做了一大堆一大堆的变化和计算，为了什么呢？没错，就是为了确定物体的每个点的屏幕坐标，这样屏幕上的像素点就可以根据周围这些点的纹理颜色设定自己的颜色了。</p><p>前面提过这个变换顺序：</p><div class="code-wrapper"><pre><code class="hljs cos">Viewport * Projection * <span class="hljs-keyword">View</span> * Model * vertex</code></pre></div><p>Model变换是为了将每个点的坐标从物体坐标转换到世界坐标；</p><p>View变换是为了将每个点的坐标从世界坐标转换到摄像机（眼睛）坐标系中；</p><p>Projection变换是为了将每个点透视投影到屏幕上。这里可能比较抽象：</p><p>我们认为眼睛是一个点，那么我们看到物体是满足近大远小的透视规律的，因为屏幕只是一个平面，因此物体在屏幕上的x,y坐标必然会受到深度的影响。投影就是为了算出每个点的屏幕坐标。</p><p>ViewPort变换是为了拉伸画面。我们知道，这些变换一直是在[-1,1]^3的立方体的前提下进行的，要把画面放大到指定的高度和宽度。至于深度，因为我们只需要知道相对关系，其实绝对数值意义不大，一般为255.</p><p>这样，就可以确定模型每个点的屏幕坐标了。屏幕的每个像素点依据附近的模型面（或点）的颜色计算出显示什么颜色，就ok了。</p>
          </div>

<p>下面咱们来一起看渲染的过程：</p>
<p>（蓝色的是我们无法改变的，而橘色的是我们可以随意改造的）</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/08/31/88113a7c13ebb342.png" srcset="/img/loading.gif" lazyload></p>
<p>我们现在已经获取到了顶点的数据，通过预处理后，使用Vertex Shader对其进行变换，使模型中每个点的坐标转换为屏幕坐标，并算出相应的光照。</p>
<p>接着fragment Shader将会读取其光照和原纹理，计算出像素点的实际颜色，并进行上色。</p>
<p>不对一些细枝末节的过程进行详细说明，我们就得到了勉强可看的渲染结果啦！</p>
<p>所以可以看出，过程其实是：</p>
<p>模型 ——&gt; 特定的shader进行渲染 ——&gt; 结果图</p>
<p>所以将shader抽离出来是很有必要的！</p>
<p>因此，建立shader模板类：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//创建一个shader模板类</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">IShader</span>
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IShader</span>();
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>= <span class="hljs-number">0</span>;
&#125;;</code></pre></div>

<p>同时，因为投影变换矩阵和画三角形的函数相对固定，我们也将其抽离出来：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">viewport</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span></span>
<span class="hljs-function"></span>&#123;
    Viewport = Matrix::<span class="hljs-built_in">identity</span>();
    <span class="hljs-comment">//将中心点移动到1/2width 和 1/2height的屏幕中央</span>
    Viewport[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = x + w / <span class="hljs-number">2.f</span>;
    Viewport[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = y + h / <span class="hljs-number">2.f</span>;
    <span class="hljs-comment">//深度</span>
    Viewport[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">255.f</span> / <span class="hljs-number">2.f</span>;
    <span class="hljs-comment">//将画幅拉伸到3/4屏幕那么大，留白一些</span>
    <span class="hljs-comment">//这里是可以自己调的， 老师就是3/4， 我认为这个大小是合适的</span>
    Viewport[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = w / <span class="hljs-number">2.f</span>;
    Viewport[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = h / <span class="hljs-number">2.f</span>;
    Viewport[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">255.f</span> / <span class="hljs-number">2.f</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">projection</span><span class="hljs-params">(<span class="hljs-type">float</span> coeff)</span></span>
<span class="hljs-function"></span>&#123;
    Projection = Matrix::<span class="hljs-built_in">identity</span>();
    Projection[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = coeff;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lookat</span><span class="hljs-params">(Vec3f eye, Vec3f center, Vec3f up)</span></span>
<span class="hljs-function"></span>&#123;
    Vec3f z = (eye - center).<span class="hljs-built_in">normalize</span>();
    Vec3f x = <span class="hljs-built_in">cross</span>(up, z).<span class="hljs-built_in">normalize</span>();
    Vec3f y = <span class="hljs-built_in">cross</span>(z, x).<span class="hljs-built_in">normalize</span>();
    ModelView = Matrix::<span class="hljs-built_in">identity</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    &#123;
        ModelView[<span class="hljs-number">0</span>][i] = x[i];
        ModelView[<span class="hljs-number">1</span>][i] = y[i];
        ModelView[<span class="hljs-number">2</span>][i] = z[i];
        ModelView[i][<span class="hljs-number">3</span>] = -center[i];
    &#125;
&#125;

<span class="hljs-function">Vec3f <span class="hljs-title">barycentric</span><span class="hljs-params">(Vec2f A, Vec2f B, Vec2f C, Vec2f P)</span></span>
<span class="hljs-function"></span>&#123;
    Vec3f s[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i--;)
    &#123;
        s[i][<span class="hljs-number">0</span>] = C[i] - A[i];
        s[i][<span class="hljs-number">1</span>] = B[i] - A[i];
        s[i][<span class="hljs-number">2</span>] = A[i] - P[i];
    &#125;
    Vec3f u = <span class="hljs-built_in">cross</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(u[<span class="hljs-number">2</span>]) &gt; <span class="hljs-number">1e-2</span>) <span class="hljs-comment">// dont forget that u[2] is integer. If it is zero then triangle ABC is degenerate</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">1.f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// in this case generate negative coordinates, it will be thrown away by the rasterizator</span>
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">triangle</span><span class="hljs-params">(Vec4f *pts, IShader &amp;shader, TGAImage &amp;image, TGAImage &amp;zbuffer)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-function">Vec2f <span class="hljs-title">bboxmin</span><span class="hljs-params">(std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max(), std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max())</span></span>;
    <span class="hljs-function">Vec2f <span class="hljs-title">bboxmax</span><span class="hljs-params">(-std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max(), -std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::max())</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)
        &#123;
            bboxmin[j] = std::<span class="hljs-built_in">min</span>(bboxmin[j], pts[i][j] / pts[i][<span class="hljs-number">3</span>]);
            bboxmax[j] = std::<span class="hljs-built_in">max</span>(bboxmax[j], pts[i][j] / pts[i][<span class="hljs-number">3</span>]);
        &#125;
    &#125;
    Vec2i P;
    TGAColor color;
    <span class="hljs-keyword">for</span> (P.x = bboxmin.x; P.x &lt;= bboxmax.x; P.x++)
    &#123;
        <span class="hljs-keyword">for</span> (P.y = bboxmin.y; P.y &lt;= bboxmax.y; P.y++)
        &#123;
            Vec3f c = <span class="hljs-built_in">barycentric</span>(<span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(pts[<span class="hljs-number">0</span>] / pts[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]), <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(pts[<span class="hljs-number">1</span>] / pts[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]), <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(pts[<span class="hljs-number">2</span>] / pts[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]), <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">2</span>&gt;(P));
            <span class="hljs-type">float</span> z = pts[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] * c.x + pts[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] * c.y + pts[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] * c.z;
            <span class="hljs-type">float</span> w = pts[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] * c.x + pts[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] * c.y + pts[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] * c.z;
            <span class="hljs-type">int</span> frag_depth = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">min</span>(<span class="hljs-number">255</span>, <span class="hljs-built_in">int</span>(z / w + <span class="hljs-number">.5</span>)));
            <span class="hljs-keyword">if</span> (c.x &lt; <span class="hljs-number">0</span> || c.y &lt; <span class="hljs-number">0</span> || c.z &lt; <span class="hljs-number">0</span> || zbuffer.<span class="hljs-built_in">get</span>(P.x, P.y)[<span class="hljs-number">0</span>] &gt; frag_depth)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-type">bool</span> discard = shader.<span class="hljs-built_in">fragment</span>(c, color);
            <span class="hljs-keyword">if</span> (!discard)<span class="hljs-comment">//为什么要弄一个bool？——方便丢弃像素（在之后的课程中会出现的）</span>
            &#123;
                zbuffer.<span class="hljs-built_in">set</span>(P.x, P.y, <span class="hljs-built_in">TGAColor</span>(frag_depth));
                image.<span class="hljs-built_in">set</span>(P.x, P.y, color);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>好了，此时我们的主函数是这样的：</p>
<p>（笔者这里非常偷懒的全部使用的老师的模板：因为笔者的几个头文件一开始是自己写的，在扩充的过程中成为屎山，且与主函数的协调都存在巨大问题。。。完全重构耗时太长，因此只能从这里先借鉴一下范本，有能力还是自己写，有助于深入了解。笔者已经上过GAMES101，很轻易能看懂，因此偷个小懒啦~）</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//高氏shader——最初级的shader</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">GouraudShader</span> : <span class="hljs-keyword">public</span> IShader &#123;
    Vec3f varying_intensity; <span class="hljs-comment">// written by vertex shader, read by fragment shader</span>

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>&#123;
        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert)); <span class="hljs-comment">// read the vertex from .obj file</span>
        gl_Vertex = Viewport*Projection*ModelView*gl_Vertex;     <span class="hljs-comment">// transform it to screen coordinates</span>
        varying_intensity[nthvert] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, model-&gt;<span class="hljs-built_in">normal</span>(iface, nthvert)*light_dir); <span class="hljs-comment">// get diffuse lighting intensity</span>
        <span class="hljs-keyword">return</span> gl_Vertex;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;
        <span class="hljs-type">float</span> intensity = varying_intensity*bar;   <span class="hljs-comment">// interpolate intensity for the current pixel</span>
        color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)*intensity; <span class="hljs-comment">// well duh</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                              <span class="hljs-comment">// no, we do not discard this pixel</span>
    &#125;
&#125;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;
    <span class="hljs-comment">//获取模型</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>==argc) &#123;
        model = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Model</span>(argv[<span class="hljs-number">1</span>]);
    &#125; <span class="hljs-keyword">else</span> &#123;
        model = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Model</span>(<span class="hljs-string">&quot;obj/african_head.obj&quot;</span>);
    &#125;
    <span class="hljs-comment">//初始化变换矩阵</span>
    <span class="hljs-built_in">lookat</span>(eye, center, up);
    <span class="hljs-built_in">viewport</span>(width/<span class="hljs-number">8</span>, height/<span class="hljs-number">8</span>, width*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>, height*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>);
    <span class="hljs-built_in">projection</span>(<span class="hljs-number">-1.f</span>/(eye-center).<span class="hljs-built_in">norm</span>());
    <span class="hljs-comment">//初始化光线</span>
    light_dir.<span class="hljs-built_in">normalize</span>();
    <span class="hljs-comment">//初始纹理和深度图</span>
    <span class="hljs-function">TGAImage <span class="hljs-title">image</span>  <span class="hljs-params">(width, height, TGAImage::RGB)</span></span>;
    <span class="hljs-function">TGAImage <span class="hljs-title">zbuffer</span><span class="hljs-params">(width, height, TGAImage::GRAYSCALE)</span></span>;
    <span class="hljs-comment">//获取高氏Shader</span>
    GouraudShader shader;
    <span class="hljs-comment">//借助shader渲染模型</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;model-&gt;<span class="hljs-built_in">nfaces</span>(); i++) &#123;
        Vec4f screen_coords[<span class="hljs-number">3</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">3</span>; j++) &#123;
            screen_coords[j] = shader.<span class="hljs-built_in">vertex</span>(i, j);
        &#125;
        <span class="hljs-built_in">triangle</span>(screen_coords, shader, image, zbuffer);
    &#125;
    <span class="hljs-comment">//输出</span>
    image.  <span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// to place the origin in the bottom left corner of the image</span>
    zbuffer.<span class="hljs-built_in">flip_vertically</span>();
    image.  <span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;output.tga&quot;</span>);
    zbuffer.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;zbuffer.tga&quot;</span>);

    <span class="hljs-keyword">delete</span> model;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<p>可以看到，我们这里使用的是高氏Shader，此后，我们会学习更多的Shader，同时我们自己也应该学会自己写Shader，比如我们马上就要迎来的下一课。</p>
<h2 id="修改Shader的第一次尝试"><a href="#修改Shader的第一次尝试" class="headerlink" title="修改Shader的第一次尝试"></a>修改Shader的第一次尝试</h2><p>尝试一下通过修改Shader来产生各种不同的渲染效果吧！</p>
<p>这是作者的示例：可以看到，作者只允许亮度有6个不同的值，而且初始颜色被设定为了橘黄色，可以想象这样会是一种厚涂的风格。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>
<span class="hljs-function"></span>&#123;
      <span class="hljs-type">float</span> intensity = varying_intensity*bar;
      <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.85</span>) intensity = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.60</span>) intensity = <span class="hljs-number">.80</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.45</span>) intensity = <span class="hljs-number">.60</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.30</span>) intensity = <span class="hljs-number">.45</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intensity&gt;<span class="hljs-number">.15</span>) intensity = <span class="hljs-number">.30</span>;
      <span class="hljs-keyword">else</span> intensity = <span class="hljs-number">0</span>;
      color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">155</span>, <span class="hljs-number">0</span>)*intensity;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  &#125;</code></pre></div>

<p><img src="https://s3.bmp.ovh/imgs/2022/09/03/a51d60c7d28aa665.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="Normalmapping"><a href="#Normalmapping" class="headerlink" title="Normalmapping"></a>Normalmapping</h2><p>textrue不仅可以储存RGB颜色，也可以存储别的，非常丰富的信息，比如法线。</p>
<img src="https://s3.bmp.ovh/imgs/2022/09/03/24d8531246467622.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>这就是一张典型的法线贴图，存放了每个点的法线信息。</p>
<p>既然说到法线，那我们就来扯一扯法线的问题。还记得之前我们说到的如果模型进行了坐标变换，那么法线也需要进行坐标变换吗?那为什么我们一直没有提到关于发现的坐标变换呢？一起来看看吧。</p>
<p>首先是一开始的高氏Shader：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GouraudShader</span> : <span class="hljs-keyword">public</span> IShader
&#123;
    Vec3f varying_intensity; <span class="hljs-comment">// written by vertex shader, read by fragment shader</span>

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span>
<span class="hljs-function">    </span>&#123;
        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));                               <span class="hljs-comment">// read the vertex from .obj file</span>
        gl_Vertex = Viewport * Projection * ModelView * gl_Vertex;                             <span class="hljs-comment">// transform it to screen coordinates</span>
        varying_intensity[nthvert] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, model-&gt;<span class="hljs-built_in">normal</span>(iface, nthvert) * light_dir); <span class="hljs-comment">// get diffuse lighting intensity</span>
        <span class="hljs-keyword">return</span> gl_Vertex;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-type">float</span> intensity = varying_intensity * bar;   <span class="hljs-comment">// interpolate intensity for the current pixel</span>
        color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>) * intensity; <span class="hljs-comment">// well duh</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                                <span class="hljs-comment">// no, we do not discard this pixel</span>
    &#125;
&#125;;
<span class="hljs-comment">//我们需要使用到法线的地方在哪里？—— 计算光照</span>
<span class="hljs-comment">//varying_intensity[nthvert] = std::max(0.f, model-&gt;normal(iface, nthvert) * light_dir); </span>
<span class="hljs-comment">//可以看到，我们根本没管这里点经过投影之后的法线变换，也没管光线在拉伸后的空间后的变化，因此效果确实会差一些！</span>
<span class="hljs-comment">//此处light_dir是否需要拉伸还是看你给的是什么坐标系下的light_dir.</span></code></pre></div>

<p>我们修改一下：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shader</span> : <span class="hljs-keyword">public</span> IShader
&#123;
    mat&lt;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_uv;  <span class="hljs-comment">// same as above</span>
    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_M;   <span class="hljs-comment">//  Projection*ModelView</span>
    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_MIT; <span class="hljs-comment">// (Projection*ModelView).invert_transpose()</span>

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span>
<span class="hljs-function">    </span>&#123;
        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));
        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert)); <span class="hljs-comment">// read the vertex from .obj file</span>
        <span class="hljs-keyword">return</span> Viewport * Projection * ModelView * gl_Vertex;    <span class="hljs-comment">// transform it to screen coordinates</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span>
<span class="hljs-function">    </span>&#123;
        Vec2f uv = varying_uv * bar; <span class="hljs-comment">// interpolate uv for the current pixel</span>
        Vec3f n = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_MIT * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(uv))).<span class="hljs-built_in">normalize</span>();
        Vec3f l = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_M * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(light_dir)).<span class="hljs-built_in">normalize</span>();
        <span class="hljs-type">float</span> intensity = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n * l);
        color = model-&gt;<span class="hljs-built_in">diffuse</span>(uv) * intensity; <span class="hljs-comment">// well duh</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                           <span class="hljs-comment">// no, we do not discard this pixel</span>
    &#125;
&#125;;

<span class="hljs-comment">//这里我们是怎么计算光照的呢？</span>
<span class="hljs-comment">//因为提供了法线贴图，所以不需要点对点的单独提取法线了，只要直接插值算出每个三角形对应的uv，颜色和法线都可以通过uv确定。取得三角形的法线后再直接和光线点乘得到系数。</span></code></pre></div>

<p>最后我们对比一下这两种方法的效果差距：</p>
<img src="https://s3.bmp.ovh/imgs/2022/09/03/879521a02efd38ca.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />

<img src="https://s3.bmp.ovh/imgs/2022/09/03/77e0fde064a19dc0.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />

<h2 id="Specular-mapping"><a href="#Specular-mapping" class="headerlink" title="Specular mapping"></a>Specular mapping</h2><p>我们看着这个人像，仍然不满意于渲染的结果。为什么呢？</p>
<p>光照还是不够真实！众所周知，光在打到物体时会发生反射，分为镜面反射和漫反射。而且我们是如何处理光照的？——非常直觉性的”法线和光线方向一致则亮，否则则暗”，这是一种模拟漫反射强度的有效方法，但是Phong提出了一个更好的光照模型，我们一起来学习一下：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/03/34a77862e0fac16d.png" srcset="/img/loading.gif" lazyload></p>
<img src="https://s3.bmp.ovh/imgs/2022/09/03/5d0696b25eb6b6d6.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>下面给出代码：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shader</span> : <span class="hljs-keyword">public</span> IShader &#123;
    mat&lt;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_uv;  <span class="hljs-comment">// same as above</span>
    mat&lt;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-type">float</span>&gt; uniform_M;   <span class="hljs-comment">//  Projection*ModelView</span>
    mat&lt;<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-type">float</span>&gt; uniform_MIT; <span class="hljs-comment">// (Projection*ModelView).invert_transpose()</span>

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>&#123;
        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));
        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert)); <span class="hljs-comment">// read the vertex from .obj file</span>
        <span class="hljs-keyword">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class="hljs-comment">// transform it to screen coordinates</span>
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;
        Vec2f uv = varying_uv*bar;
        Vec3f n = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_MIT*<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(uv))).<span class="hljs-built_in">normalize</span>();
        Vec3f l = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_M  *<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(light_dir        )).<span class="hljs-built_in">normalize</span>();
        Vec3f r = (n*(n*l*<span class="hljs-number">2.f</span>) - l).<span class="hljs-built_in">normalize</span>();   <span class="hljs-comment">// reflected light</span>
        <span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(r.z, <span class="hljs-number">0.0f</span>), model-&gt;<span class="hljs-built_in">specular</span>(uv));<span class="hljs-comment">//可以看到，又出现了一个高光贴图，用于给出每处的粗糙度，有助于让光滑的地方获得更强的反光。</span>
        <span class="hljs-type">float</span> diff = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n*l);
        TGAColor c = model-&gt;<span class="hljs-built_in">diffuse</span>(uv);
        color = c;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) color[i] = std::<span class="hljs-built_in">min</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">5</span> + c[i]*(diff + <span class="hljs-number">.6</span>*spec), <span class="hljs-number">255</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>

<p>这里作者写的</p>
<div class="code-wrapper"><pre><code class="hljs c++">Vec3f r = (n*(n*l*<span class="hljs-number">2.f</span>) - l).<span class="hljs-built_in">normalize</span>();
<span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(r.z, <span class="hljs-number">0.0f</span>), model-&gt;<span class="hljs-built_in">specular</span>(uv));</code></pre></div>

<p>感觉有点无厘头（</p>
<p>按理来说应该把r和v先求点乘，然后再power多次，得到高光才对。合理猜测是因为此时eye的位置比较取巧，所以才不需要考虑v，但是v还是很重要的。</p>
<p>最后出个结果吧。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/03/2416957d30229da8.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节课收获还是很多的！</p>
<p>我们已经可以渲染的像模像样了，但是还远远达不到“好”和“真实”。</p>
<p>我们虽然简单模拟了光，但是没有考虑阴影呢！</p>
<h1 id="Lesson-6bis-tangent-space-normal-mapping"><a href="#Lesson-6bis-tangent-space-normal-mapping" class="headerlink" title="Lesson 6bis: tangent space normal mapping"></a>Lesson 6bis: tangent space normal mapping</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>很神奇，中间插了一截来讲normalMapping，那我们在讲阴影之前就先看一看NormalMapping吧！</p>
<p>先链接一篇文章，因为这里涉及到了很多线性代数，数学不好的话肯定会很迷惑。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143321426">法线贴图那些事儿</a></p>
<p>我们思考一个问题：</p>
<p>如果我们想用这个模型做一段动画，那么该怎么获取每一帧物体的位置、纹理和法线呢？</p>
<p>首先是位置：每个三角面的位置由动画本身决定，不需要我们去获取。</p>
<p>纹理：每个三角形对应的uv贴图的坐标是一定的，在运动过程中纹理不会发生改变，因此不需要处理</p>
<p>法线：每个三角形的法线由三角形三个顶点的法线计算而来，而这由模型文件本身给出，因此，在三角形顶点跟随动画运动的过程中，法线无法确定了！</p>
<p>因此（不构成直接的因果关系，只是基于切线空间的法线贴图有这个好处），我们注意到了tangent space normal mapping！</p>
<p>切线空间的法线贴图存储着每个顶点的相对法向量，因此，无论顶点怎么动，只要用合适的数学将其提取出来，就一定会是正确的法向！</p>
<p>好了，接下来我们来学习一下吧！</p>
<h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><p>和往常一样，我不会展示具体的数学推导。（因为解释起来太麻烦+我也不一定正确)，所以指路<a target="_blank" rel="noopener" href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-6bis:-tangent-space-normal-mapping">原帖</a>。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//只有Shader发生了变化，其他部分和以前一样。</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shader</span> : <span class="hljs-keyword">public</span> IShader &#123;
    mat&lt;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_uv;  <span class="hljs-comment">// triangle uv coordinates, written by the vertex shader, read by the fragment shader</span>
    mat&lt;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_tri; <span class="hljs-comment">// triangle coordinates (clip coordinates), written by VS, read by FS</span>
    mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; varying_nrm; <span class="hljs-comment">// normal per vertex to be interpolated by FS</span>
    mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; ndc_tri;     <span class="hljs-comment">// triangle in normalized device coordinates</span>

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span> </span>&#123;
        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));
        varying_nrm.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;((Projection*ModelView).<span class="hljs-built_in">invert_transpose</span>()*<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(iface, nthvert), <span class="hljs-number">0.f</span>)));
        Vec4f gl_Vertex = Projection*ModelView*<span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));
        varying_tri.<span class="hljs-built_in">set_col</span>(nthvert, gl_Vertex);
        ndc_tri.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(gl_Vertex/gl_Vertex[<span class="hljs-number">3</span>]));
        <span class="hljs-keyword">return</span> gl_Vertex;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;
        Vec3f bn = (varying_nrm*bar).<span class="hljs-built_in">normalize</span>();
        Vec2f uv = varying_uv*bar;

        mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; A;
        A[<span class="hljs-number">0</span>] = ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">1</span>) - ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">0</span>);
        A[<span class="hljs-number">1</span>] = ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">2</span>) - ndc_tri.<span class="hljs-built_in">col</span>(<span class="hljs-number">0</span>);
        A[<span class="hljs-number">2</span>] = bn;

        mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; AI = A.<span class="hljs-built_in">invert</span>();

        Vec3f i = AI * <span class="hljs-built_in">Vec3f</span>(varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] - varying_uv[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);
        Vec3f j = AI * <span class="hljs-built_in">Vec3f</span>(varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - varying_uv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);

        mat&lt;<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-type">float</span>&gt; B;<span class="hljs-comment">//这就是切线空间的基了</span>
        B.<span class="hljs-built_in">set_col</span>(<span class="hljs-number">0</span>, i.<span class="hljs-built_in">normalize</span>());
        B.<span class="hljs-built_in">set_col</span>(<span class="hljs-number">1</span>, j.<span class="hljs-built_in">normalize</span>());
        B.<span class="hljs-built_in">set_col</span>(<span class="hljs-number">2</span>, bn);

        Vec3f n = (B*model-&gt;<span class="hljs-built_in">normal</span>(uv)).<span class="hljs-built_in">normalize</span>();

        <span class="hljs-type">float</span> diff = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n*light_dir);
        color = model-&gt;<span class="hljs-built_in">diffuse</span>(uv)*diff;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>



<h1 id="Lesson-7-Shadow-mapping"><a href="#Lesson-7-Shadow-mapping" class="headerlink" title="Lesson 7: Shadow mapping"></a>Lesson 7: Shadow mapping</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>这节课我们来学习添加阴影。（阴影分为硬阴影和软阴影，此处我们添加硬阴影）</p>
<h2 id="阴影形成原理"><a href="#阴影形成原理" class="headerlink" title="阴影形成原理"></a>阴影形成原理</h2><p>我们都知道，阴影的形成是因为光源发出的光线被中间的物体遮挡，因此形成了阴影。</p>
<p>借助这种想法，轻易的就可以理解阴影的求法：做一个类似于zBuffer的shadowBuffer，只渲染最上层的物体。</p>
<p>如何形成呢？我们可以将眼睛（eye）的位置放在光源，这样我们看过去储存的zBuffer其实就是要求的shadowBuffer。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DepthShader</span> : <span class="hljs-keyword">public</span> IShader
&#123;
    mat&lt;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_tri;

    <span class="hljs-built_in">DepthShader</span>():<span class="hljs-built_in">varying_tri</span>()&#123;&#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span>
<span class="hljs-function">    </span>&#123;
        Vec4f gl_Vertex = <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));
        gl_Vertex = shadowM * gl_Vertex;
        varying_tri.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(gl_Vertex / gl_Vertex[<span class="hljs-number">3</span>]));
        <span class="hljs-keyword">return</span> gl_Vertex;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span>
<span class="hljs-function">    </span>&#123;
        Vec3f p = varying_tri * bar;
        color = <span class="hljs-built_in">TGAColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>) * (p.z / <span class="hljs-number">255</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;

<span class="hljs-comment">//此处shadowM矩阵为： </span>
<span class="hljs-built_in">lookat</span>(light_dir, center, up);<span class="hljs-comment">//将眼睛放在光源处</span>
<span class="hljs-built_in">viewport</span>(width / <span class="hljs-number">8</span>, height / <span class="hljs-number">8</span>, width * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>, height * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>);
<span class="hljs-built_in">projection</span>(<span class="hljs-number">-1.f</span> / (eye - center).<span class="hljs-built_in">norm</span>());
shadowM = Viewport * Projection * ModelView;</code></pre></div>

<h2 id="修改Shader"><a href="#修改Shader" class="headerlink" title="修改Shader"></a>修改Shader</h2><p>那么如何修改我们的Shader也就很清晰了：在我们PhongShader的基础上添加一个前置步骤：计算ShadowBuffer，这样在PhongShader渲染时对于有阴影的部分就可以加以处理了。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//此处展示我们编写的新的PhongShader</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhongShader</span> : <span class="hljs-keyword">public</span> IShader
&#123;
    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_M;       <span class="hljs-comment">//  Projection*ModelView</span>
    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_MIT;     <span class="hljs-comment">// (Projection*ModelView).invert_transpose()</span>
    mat&lt;<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-type">float</span>&gt; uniform_Mshadow; <span class="hljs-comment">// transform framebuffer screen coordinates to shadowbuffer screen coordinates</span>
    mat&lt;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_uv;      <span class="hljs-comment">// triangle uv coordinates, written by the vertex shader, read by the fragment shader</span>
    mat&lt;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-type">float</span>&gt; varying_tri;     <span class="hljs-comment">// triangle coordinates before Viewport transform, written by VS, read by FS</span>

    <span class="hljs-built_in">PhongShader</span>(Matrix M, Matrix MIT, Matrix MS) : <span class="hljs-built_in">uniform_M</span>(M), <span class="hljs-built_in">uniform_MIT</span>(MIT), <span class="hljs-built_in">uniform_Mshadow</span>(MS), <span class="hljs-built_in">varying_uv</span>(), <span class="hljs-built_in">varying_tri</span>() &#123;&#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Vec4f <span class="hljs-title">vertex</span><span class="hljs-params">(<span class="hljs-type">int</span> iface, <span class="hljs-type">int</span> nthvert)</span></span>
<span class="hljs-function">    </span>&#123;
        varying_uv.<span class="hljs-built_in">set_col</span>(nthvert, model-&gt;<span class="hljs-built_in">uv</span>(iface, nthvert));
        Vec4f gl_Vertex = Viewport * Projection * ModelView * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">vert</span>(iface, nthvert));
        varying_tri.<span class="hljs-built_in">set_col</span>(nthvert, <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(gl_Vertex / gl_Vertex[<span class="hljs-number">3</span>]));
        <span class="hljs-keyword">return</span> gl_Vertex;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">fragment</span><span class="hljs-params">(Vec3f bar, TGAColor &amp;color)</span></span>
<span class="hljs-function">    </span>&#123;
        Vec4f sb_p = uniform_Mshadow * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(varying_tri * bar); <span class="hljs-comment">// corresponding point in the shadow buffer</span>
        sb_p = sb_p / sb_p[<span class="hljs-number">3</span>];                           
        <span class="hljs-type">float</span> shadow = <span class="hljs-number">.3</span> + <span class="hljs-number">.7</span> * (shadowDepth.<span class="hljs-built_in">get</span>((<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">0</span>], (<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>] &lt; (sb_p[<span class="hljs-number">2</span>]+<span class="hljs-number">10</span>)); <span class="hljs-comment">// magic coeff to avoid z-fighting</span>
        <span class="hljs-comment">//这里这个+10需要注意一下，之后会解释，是为防止z—fighting</span>
        <span class="hljs-comment">//可以看到，为了模仿软阴影，即使被遮挡住了也不会全黑，而是保留0.3的系数</span>
        Vec2f uv = varying_uv * bar;                                              <span class="hljs-comment">// interpolate uv for the current pixel</span>
        Vec3f n = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_MIT * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(model-&gt;<span class="hljs-built_in">normal</span>(uv))).<span class="hljs-built_in">normalize</span>(); <span class="hljs-comment">// normal</span>
        Vec3f l = <span class="hljs-built_in">proj</span>&lt;<span class="hljs-number">3</span>&gt;(uniform_M * <span class="hljs-built_in">embed</span>&lt;<span class="hljs-number">4</span>&gt;(light_dir)).<span class="hljs-built_in">normalize</span>();           <span class="hljs-comment">// light vector</span>
        Vec3f r = (n * (n * l * <span class="hljs-number">2.f</span>) - l).<span class="hljs-built_in">normalize</span>();                            <span class="hljs-comment">// reflected light</span>
        <span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(r.z, <span class="hljs-number">0.0f</span>), model-&gt;<span class="hljs-built_in">specular</span>(uv)); <span class="hljs-comment">//为什么只考虑z? 这里也是一个trick,因为眼睛一定在z轴上,只需要取z分量就可以了</span>
        <span class="hljs-type">float</span> diff = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, n * l);
        TGAColor c = model-&gt;<span class="hljs-built_in">diffuse</span>(uv);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
           color[i] = std::<span class="hljs-built_in">min</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">20</span> + c[i]*shadow*(<span class="hljs-number">1.2</span>*diff + <span class="hljs-number">.6</span>*spec), <span class="hljs-number">255</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>

<p>然后在主函数中进行渲染：</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// GetDepth</span>
<span class="hljs-built_in">lookat</span>(light_dir, center, up);
<span class="hljs-built_in">viewport</span>(width / <span class="hljs-number">8</span>, height / <span class="hljs-number">8</span>, width * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>, height * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>);
<span class="hljs-built_in">projection</span>(<span class="hljs-number">-1.f</span> / (eye - center).<span class="hljs-built_in">norm</span>());
shadowM = Viewport * Projection * ModelView;
DepthShader Dshader;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)
&#123;
    Vec4f screen_coords[<span class="hljs-number">3</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)
    &#123;
        screen_coords[j] = Dshader.<span class="hljs-built_in">vertex</span>(i, j);
    &#125;
    <span class="hljs-built_in">triangle</span>(screen_coords, Dshader, shadowImage, shadowDepth);
&#125;
shadowImage.<span class="hljs-built_in">flip_vertically</span>();
shadowImage.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;shadow.tga&quot;</span>);

<span class="hljs-comment">// PhongShading</span>
<span class="hljs-built_in">lookat</span>(eye, center, up);
<span class="hljs-function">PhongShader <span class="hljs-title">shader</span><span class="hljs-params">(ModelView, (Projection * ModelView).invert_transpose(), shadowM * (Viewport * Projection * ModelView).invert())</span></span>;
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; model-&gt;<span class="hljs-built_in">nfaces</span>(); i++)
&#123;
    Vec4f screen_coords[<span class="hljs-number">3</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)
    &#123;
        screen_coords[j] = shader.<span class="hljs-built_in">vertex</span>(i, j);
    &#125;
    <span class="hljs-built_in">triangle</span>(screen_coords, shader, image, depth);
&#125;
<span class="hljs-comment">//输出</span>
image.<span class="hljs-built_in">flip_vertically</span>(); <span class="hljs-comment">// to place the origin in the bottom left corner of the image</span>
image.<span class="hljs-built_in">write_tga_file</span>(<span class="hljs-string">&quot;output.tga&quot;</span>);
</code></pre></div>

<p>总的来说原理还是很好理解的，但是这里面的数学确实让人有点伤脑筋，外加这个wiki的作者的代码经常反反复复的重构和更新，导致在复现的过程中还是遇到不少麻烦，特别是会出现一些不太理解的magic的变量和数字。但是如果能清晰的理解里面的数学，把数学的部分封装好，我觉得应该能简单很多！</p>
<p>最后看两张成品图吧！</p>
<img src="https://s3.bmp.ovh/imgs/2022/09/05/c075281389264e5c.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://s3.bmp.ovh/imgs/2022/09/05/74ca9782bd5a04b9.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<h2 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h2><p>通过成品图（特别是第二张图）我们可以看到，模型身上有一些非常丑陋的闪烁的阴影，这是为什么呢？</p>
<p>这是一种特别的现象：Z-fighting。</p>
<p>链接一篇知乎专栏：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78769570">&lt;渲染基础&gt;-3D渲染中的Z-fighting现象</a></p>
<p>CSDN : <a target="_blank" rel="noopener" href="https://blog.csdn.net/chenweiyu11962/article/details/113542402">Z-Fighting问题解决方案实例</a></p>
<p>在作者的教程中，他直接添加了一个magic number：43.34来解决这个问题</p>
<p>这实际上是制造了一个偏移，这样可能可以整体性的去除一些闪烁？？不太懂</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> shadow = <span class="hljs-number">.3</span> + <span class="hljs-number">.7</span> * (shadowDepth.<span class="hljs-built_in">get</span>((<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">0</span>], (<span class="hljs-type">int</span>)sb_p[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>] &lt; (sb_p[<span class="hljs-number">2</span>]+<span class="hljs-number">10</span>)); <span class="hljs-comment">// magic coeff to avoid z-fighting</span></code></pre></div>

<p>我使用的+10，没有什么特别大的区别，但是可以看出这种方法只能一定程度上解决这个问题，该闪烁还是会闪烁。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%8A%80%E6%9C%AF/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="category-chain-item">图形学</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%8A%80%E6%9C%AF/%E5%9B%BE%E5%BD%A2%E5%AD%A6/TinyRenderer/" class="category-chain-item">TinyRenderer</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="print-no-link">#图形学</a>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/TinyRenderer/" class="print-no-link">#TinyRenderer</a>
      
        <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/" class="print-no-link">#软件光栅化渲染器</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>TinyRenderer 6&amp;7</div>
      <div>http://example.com/2022/08/31/TinyRenderer-6-7/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/06/TinyRenderer-8-9/" title="TinyRenderer 8&amp;9">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">TinyRenderer 8&amp;9</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/16/TinyRenderer-4-5/" title="TinyRenderer 4&amp;5">
                        <span class="hidden-mobile">TinyRenderer 4&amp;5</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
